<!DOCTYPE html>
<html>

<head>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<title>2019-10-21-进击ReactNative-徐如林-React源码解析</title>


<style type="text/css">
body {
  font-family: Helvetica, arial, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  padding-top: 10px;
  padding-bottom: 10px;
  background-color: white;
  padding: 30px; }

body > *:first-child {
  margin-top: 0 !important; }
body > *:last-child {
  margin-bottom: 0 !important; }

a {
  color: #4183C4; }
a.absent {
  color: #cc0000; }
a.anchor {
  display: block;
  padding-left: 30px;
  margin-left: -30px;
  cursor: pointer;
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0; }

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
  cursor: text;
  position: relative; }

h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor {
  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA09pVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoMTMuMCAyMDEyMDMwNS5tLjQxNSAyMDEyLzAzLzA1OjIxOjAwOjAwKSAgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OUM2NjlDQjI4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OUM2NjlDQjM4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo5QzY2OUNCMDg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo5QzY2OUNCMTg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PsQhXeAAAABfSURBVHjaYvz//z8DJYCRUgMYQAbAMBQIAvEqkBQWXI6sHqwHiwG70TTBxGaiWwjCTGgOUgJiF1J8wMRAIUA34B4Q76HUBelAfJYSA0CuMIEaRP8wGIkGMA54bgQIMACAmkXJi0hKJQAAAABJRU5ErkJggg==) no-repeat 10px center;
  text-decoration: none; }

h1 tt, h1 code {
  font-size: inherit; }

h2 tt, h2 code {
  font-size: inherit; }

h3 tt, h3 code {
  font-size: inherit; }

h4 tt, h4 code {
  font-size: inherit; }

h5 tt, h5 code {
  font-size: inherit; }

h6 tt, h6 code {
  font-size: inherit; }

h1 {
  font-size: 28px;
  color: black; }

h2 {
  font-size: 24px;
  border-bottom: 1px solid #cccccc;
  color: black; }

h3 {
  font-size: 18px; }

h4 {
  font-size: 16px; }

h5 {
  font-size: 14px; }

h6 {
  color: #777777;
  font-size: 14px; }

p, blockquote, ul, ol, dl, li, table, pre {
  margin: 15px 0; }

hr {
  background: transparent url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAECAYAAACtBE5DAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OENDRjNBN0E2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OENDRjNBN0I2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4Q0NGM0E3ODY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4Q0NGM0E3OTY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqqezsUAAAAfSURBVHjaYmRABcYwBiM2QSA4y4hNEKYDQxAEAAIMAHNGAzhkPOlYAAAAAElFTkSuQmCC) repeat-x 0 0;
  border: 0 none;
  color: #cccccc;
  height: 4px;
  padding: 0;
}

body > h2:first-child {
  margin-top: 0;
  padding-top: 0; }
body > h1:first-child {
  margin-top: 0;
  padding-top: 0; }
  body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0; }
body > h3:first-child, body > h4:first-child, body > h5:first-child, body > h6:first-child {
  margin-top: 0;
  padding-top: 0; }

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0; }

h1 p, h2 p, h3 p, h4 p, h5 p, h6 p {
  margin-top: 0; }

li p.first {
  display: inline-block; }
li {
  margin: 0; }
ul, ol {
  padding-left: 30px; }

ul :first-child, ol :first-child {
  margin-top: 0; }

dl {
  padding: 0; }
  dl dt {
    font-size: 14px;
    font-weight: bold;
    font-style: italic;
    padding: 0;
    margin: 15px 0 5px; }
    dl dt:first-child {
      padding: 0; }
    dl dt > :first-child {
      margin-top: 0; }
    dl dt > :last-child {
      margin-bottom: 0; }
  dl dd {
    margin: 0 0 15px;
    padding: 0 15px; }
    dl dd > :first-child {
      margin-top: 0; }
    dl dd > :last-child {
      margin-bottom: 0; }

blockquote {
  border-left: 4px solid #dddddd;
  padding: 0 15px;
  color: #777777; }
  blockquote > :first-child {
    margin-top: 0; }
  blockquote > :last-child {
    margin-bottom: 0; }

table {
  padding: 0;border-collapse: collapse; }
  table tr {
    border-top: 1px solid #cccccc;
    background-color: white;
    margin: 0;
    padding: 0; }
    table tr:nth-child(2n) {
      background-color: #f8f8f8; }
    table tr th {
      font-weight: bold;
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr td {
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr th :first-child, table tr td :first-child {
      margin-top: 0; }
    table tr th :last-child, table tr td :last-child {
      margin-bottom: 0; }

img {
  max-width: 100%; }

span.frame {
  display: block;
  overflow: hidden; }
  span.frame > span {
    border: 1px solid #dddddd;
    display: block;
    float: left;
    overflow: hidden;
    margin: 13px 0 0;
    padding: 7px;
    width: auto; }
  span.frame span img {
    display: block;
    float: left; }
  span.frame span span {
    clear: both;
    color: #333333;
    display: block;
    padding: 5px 0 0; }
span.align-center {
  display: block;
  overflow: hidden;
  clear: both; }
  span.align-center > span {
    display: block;
    overflow: hidden;
    margin: 13px auto 0;
    text-align: center; }
  span.align-center span img {
    margin: 0 auto;
    text-align: center; }
span.align-right {
  display: block;
  overflow: hidden;
  clear: both; }
  span.align-right > span {
    display: block;
    overflow: hidden;
    margin: 13px 0 0;
    text-align: right; }
  span.align-right span img {
    margin: 0;
    text-align: right; }
span.float-left {
  display: block;
  margin-right: 13px;
  overflow: hidden;
  float: left; }
  span.float-left span {
    margin: 13px 0 0; }
span.float-right {
  display: block;
  margin-left: 13px;
  overflow: hidden;
  float: right; }
  span.float-right > span {
    display: block;
    overflow: hidden;
    margin: 13px auto 0;
    text-align: right; }

code, tt {
  margin: 0 2px;
  padding: 0 5px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px; }

pre code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent; }

.highlight pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px; }

pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px; }
  pre code, pre tt {
    background-color: transparent;
    border: none; }

sup {
    font-size: 0.83em;
    vertical-align: super;
    line-height: 0;
}

kbd {
  display: inline-block;
  padding: 3px 5px;
  font-size: 11px;
  line-height: 10px;
  color: #555;
  vertical-align: middle;
  background-color: #fcfcfc;
  border: solid 1px #ccc;
  border-bottom-color: #bbb;
  border-radius: 3px;
  box-shadow: inset 0 -1px 0 #bbb
}

* {
	-webkit-print-color-adjust: exact;
}
@media screen and (min-width: 914px) {
    body {
        width: 854px;
        margin:0 auto;
    }
}
@media print {
	table, pre {
		page-break-inside: avoid;
	}
	pre {
		word-wrap: break-word;
	}
}
</style>


</head>

<body>

<hr>

<p>layout: post
title: 进击ReactNative-徐如林-React源码解析
key: 20191021
tags:
  - 蜻蜓切
  - ReactNative</p>

<h2 id="toc_0">  - 源码解析</h2>

<!-- 添加目录 http://blog.csdn.net/hengwei_vc/article/details/47122103 -->

<script src="/javascripts/jquery-2.1.4.min.js" type="text/javascript"></script>

<script src="/javascripts/toc.js" type="text/javascript"></script>

<script type="text/javascript">
$(document).ready(function() {
    $('#toc').toc();
}); </script>

<div id="toc"></div>

<div><TODOimg style="border-radius: 15px;box-shadow: darkgrey 0px 0px 10px 5px" src="http://TODOimg.mp.itc.cn/upload/20170718/89520d891b0441a885f129366a70d190_th.jpg"/><TODOimg style="position:absolute; width: 200px; border-radius: 500px; box-shadow: darkgrey 0px 0px 10px 5px; left: 80px; top: 200px;" src="https://shengshuqiang.github.io/assets/%E5%BE%90%E5%A6%82%E6%9E%97logo.png"/></div>

<p><br>有的人可能会不理解，大前端平台化的战火为谁而燃，吾辈何以为战？<br>专注于移动互联网大前端致富，一直是我们最崇高的理想，ReactNative首当其冲。<br>纵观行业风向，有磨刀霍霍者，有作壁上观者，有从入门到放弃者，有一把梭者，但是缺乏深潜微操者。<br>哈，是时候该我出手了。<br>祭出“<strong>大海航术</strong>”，经过一年来不懈钻研，基于react-devtools扩展<strong>插件</strong>，实时绘制运行时三棵树--<strong>Fiber双树</strong>、<strong>Virtual DOM树</strong>、<strong>React方法调用树</strong>，在上帝视角和时间旅行的引领下，冲破波诡云谲的Fiber迷航，日照大海现双龙。
{:.success}
<!--more--></p>

<p>// TODO 演进图</p>

<p>本文主要针对ReactNative（以下简称 RN）的React.js源码进行分析，先说清楚开发者接触到的API，然后再深挖对应底层实现逻辑，最后找找微操的空间。如果有对RN不太熟悉的朋友，建议看一下<a href="https://juejin.im/post/5b481f6b51882519ad6175c2">[译] 图解 React</a>、<a href="https://juejin.im/post/5b55cff3e51d453509561214">[译] 图解 React Native</a>、<a href="https://shengshuqiang.github.io/2019/01/07/%E8%BF%9B%E5%87%BBReactNative-%E7%96%BE%E5%A6%82%E9%A3%8E.html">《进击ReactNative-疾如风》</a>散散心，该文从“原理+实践，现学现做”的角度手写石器时代RN，粗线条描述跨平台套路，迂回包抄，相对比较轻松！本文则正面刚React源码，略显烧脑。</p>

<p>话说，做大事，就要用大斧头。先耍耍<a href="https://baijiahao.baidu.com/s?id=1609462546639223406&amp;wfr=spider&amp;for=pc">阿里“三板斧”</a>撼动一下。</p>

<h1 id="toc_1">定目标</h1>

<h2 id="toc_2">传道（攻坚方法论）</h2>

<p>路漫漫其修远兮，吾将上下而求索。除了物质财富，就是不断探索、抽象、践行、强化自己的方法论和价值观，只要把握住<strong>总结复盘</strong>的秘诀，成长就很快乐。</p>

<p>我攻坚RN的原动力，是借假修真。平台化技术最终王者也许花落Flutter或者小程序（还有很多人在纠结到底哪家强，耽误了学习，其实这好比考清华还是考北大，Top2高校有那么难选么，真正难选的是Top3高校），但这不重要，我能举一，必能反三，这就是霸道。我旨在强化出一套王者无界的方法论，如何从零将RN技能练到比肩高阶Android的熟练度，并且同样适用于进击Flutter和小程序。</p>

<h2 id="toc_3">授业（懂算法）</h2>

<p>现在市面上高水准的RN解析文章太少了（老外写的硬核文章居多），而且大多停留在理论层面，只给出算法理论和源码片段，根本无法深入实操，只能作者说啥就是啥，反正不明觉厉。也罢，自力更生啃源码必须提上日程。</p>

<p>我始终相信，只有源码才是唯一的真相，不二的注释，思想的火花，王者的农药。</p>

<p>后来，终于在眼泪中明白，源码大法好啊，得到的比想要的多得多（贫穷限制了我的想象）。往小的说，技术成长（自嗨）。往大的说，核心竞争力（钱）。</p>

<p>本文和你分享的是如何通过<strong>先进生产力</strong>相对轻松地看懂代码，区别于盲人摸象式的英文阅读，挑战一下：</p>

<ol>
<li><strong>承上</strong>（用户态--上层API怎么用）

<ul>
<li>组件中方法（constructor、setState、forceUpdate、render）的作用是什么？</li>
<li>生命周期调用时机是什么？</li>
<li>子组件变化，父组件和兄弟组件是否会刷新？state和props变化，有什么不一样？</li>
<li>PureComponent比Component好在哪里，怎么能做得更好？</li>
<li>最佳实践（JSX不创建临时函数，Immutable，性能优化）？</li>
</ul></li>
<li><strong>启下</strong>（内核态--底层原理怎么玩）

<ul>
<li>各种概念的含义，对应数据结构是什么？</li>
<li>深入浅出Fiber双树算法？</li>
<li>Diff算法在哪？</li>
<li>Native操作指令从哪来？</li>
</ul></li>
</ol>

<h2 id="toc_4">解惑（考考你）</h2>

<p>// TODO React常见问题和最佳实践
// TODO 简单直接提出犀利问题</p>

<p>聪明的童靴往往都会有一些亟需亲自操刀的疑问，我也不能免俗。问题有了，那答案呢？</p>

<h3 id="toc_5">组件</h3>

<ol>
<li>明明只写了几个组件，通过react-devtools看到的却是一堆布局，而且还有Context.Consumer，这些啥时候冒出来的，干啥的？</li>
<li>React组件和Native View看起来不是一一对应的，那么映射关系是什么？</li>
<li><a href="https://reactjs.org/docs/react-component.html#other-apis">组件普通API</a>调用时机、作用和最佳实践？</li>
</ol>

<p>{% highlight javascript linenos %}
// 组件类
class Component<P, S> {
    // 变量
    props;
    state;
    // 方法
    constructor(props, context);
    setState(state, callback): void;
    forceUpdate(callBack): void;
    render(): ReactNode;
}</p>

<p>{% endhighlight %}</p>

<h3 id="toc_6">生命周期</h3>

<ol>
<li>区分哪些方法只会调用一次，哪些可能会调用多次？哪些方法中能使用setState，哪些不能？</li>
<li>区分每个方法调用条件，是props改变还是state，是初始化，更新还是都有？</li>
<li>React16.3开始废弃和新增的方法是哪些，补位策略是什么？废弃方法现在还能不能用，新旧方法混用又怎样？</li>
<li><a href="https://reactjs.org/docs/react-component.html#the-component-lifecycle">组件生命周期API</a>调用时机、作用和最佳实践？</li>
</ol>

<p>{% highlight javascript linenos %}
// 静态生命周期
interface StaticLifecycle {
    getDerivedStateFromProps?: GetDerivedStateFromProps;
}
// 新生命周期
interface NewLifecycle<P, S, SS> {
    getSnapshotBeforeUpdate?(prevProps, prevState): SS | null;
    componentDidUpdate?(prevProps, prevState, snapshot): void;
}
// 废弃生命周期
interface DeprecatedLifecycle<P, S> {
    componentWillMount?(): void;
    UNSAFE<em>componentWillMount?(): void;
    componentWillReceiveProps?(nextProps, nextContext): void;
    UNSAFE</em>componentWillReceiveProps?(nextProps, nextContext): void;
    componentWillUpdate?(nextProps, nextState, nextContext): void;
    UNSAFE_componentWillUpdate?(nextProps, nextState, nextContext): void;
}
// 组件生命周期（继承新和废弃生命周期）
interface ComponentLifecycle<P, S, SS> extends NewLifecycle<P, S, SS>, DeprecatedLifecycle<P, S> {
    componentDidMount?(): void;
    shouldComponentUpdate?(nextProps, nextState, nextContext): boolean;
    componentWillUnmount?(): void;
    componentDidCatch?(error, errorInfo): void;
}
{% endhighlight %}</p>

<h3 id="toc_7">数据结构</h3>

<ol>
<li>区分Element、Instance、DOM、Component、Fiber的不同含义以及之间关系？</li>
<li>Fiber节点数据结构中各属性含义？</li>
</ol>

<h3 id="toc_8">Virtual DOM</h3>

<ol>
<li>Virtual DOM遇到了哪些假问题，又解决了哪些真问题？</li>
<li>React有棵DOM树，树在哪，怎么看，怎么操作对应Native View树？</li>
</ol>

<h3 id="toc_9">Diff算法</h3>

<ol>
<li>Diff算法的策略是什么，能得出哪些最佳实践？</li>
<li>都说React有个Diff算法（Tree Diff 分层求异；Component Diff 同类同树，异类异树；Element Diff 增删移复用key），代码在哪里，怎么比较的？</li>
</ol>

<h3 id="toc_10">原理</h3>

<ol>
<li>React高效在哪？怎么做到的？</li>
<li>React和Native的关联关系是什么？</li>
<li>Fiber双树是啥？凭什么这么牛？</li>
</ol>

<p><img style="border-radius: 10px;box-shadow: darkgrey 0px 0px 10px 5px" src="https://tTODOimgsa.baidu.com/tTODOimg?image&quality=80&size=b9999_10000&sec=1571497262025&di=4ae4817071de66ff8d666ece3b484ece&TODOimgtype=jpg&src=http%3A%2F%2FTODOimg0.TODOimgtn.bdTODOimg.com%2Fit%2Fu%3D3424028830%2C393276537%26fm%3D214%26gp%3D0.jpg"/></p>

<h1 id="toc_11">追过程</h1>

<h2 id="toc_12">学习</h2>

<p>我们不是一个人在战斗（想发财），切忌闭门造车，只有集思广益，站在在巨人的肩膀上才能事半功倍。</p>

<p>网上一顿关键字索引，找点时间，给点耐心，泛读 + 精读数十篇后，你的感觉才能慢慢滴上来。</p>

<p>本着<a href="https://new.qq.com/omn/20191006/20191006A0FQJK00.html"><strong>坚定看多，数量堆死力量</strong></a>，经过不间断的阅读输出，姿势见涨，比方说通过XMind自由缩放源码地图帮助理解、手写RN寻求理论加实践、抽象伪代码表述助力说清楚等。</p>

<p>硬广时间，安利一下我的<a href="https://shengshuqiang.github.io/">博客主页</a>和<a href="https://shengshuqiang.github.io/about.html">微信朋友圈</a>，欢迎相互切磋，共同进步。</p>

<p><img style="width: 50%; height: 50%; border-radius: 10px; box-shadow: darkgrey 0px 0px 10px 5px" src="https://shengshuqiang.github.io/assets/shengshuqiang-weixin.jpg"/></p>

<p><strong>Fiber架构里程碑</strong></p>

<p><strong>Why：</strong>一路狂奔式地更新，无暇处理用户响应，引发界面咔咔咔。</p>

<p><strong>What：</strong>Fiber（纤维），是比线程控制更精密的并发处理机制。支持更新过程碎片化，化整为零，允许紧急任务插队，可中断恢复。本质上，它还是一个工具，用来帮助开发者操纵DOM API，从而构建出页面。</p>

<p><strong>How Much：</strong>纵享丝滑。</p>

<p><strong>硬核：</strong>Lin Clark在2017 React大会的演讲<a href="https://www.bilibili.com/video/av40427580/">Lin Clark - A Cartoon Intro to Fiber - React Conf 2017</a>。这个内容太棒啦，墙裂建议大家看一看。网上大部分Fiber算法分析都引用了她的卡通图。</p>

<p><strong>术语</strong></p>

<p><a href="https://zh-hans.reactjs.org/docs/glossary.html#components"><strong><em>Component</em></strong></a>：组件，是可复用的小的代码片段，它们返回要在页面中渲染的React元素。分为<a href="https://reactjs.org/docs/react-api.html#components">类组件</a>（继承<a href="https://reactjs.org/docs/react-api.html#reactcomponent">Component</a>的普通组件和继承<a href="https://reactjs.org/docs/react-api.html#reactpurecomponent">PureComponent</a>的纯组件）和函数式组件（直接返回Element的函数）。</p>

<div><pre><code class="language-none">// 普通组件
class App extends React.Component {
    render() {
        return &lt;Text style={{color: &#39;black&#39;}}&gt;{&#39;点击数0&#39;}&lt;/Text&gt;;
    }
}</code></pre></div>

<div><pre><code class="language-none">// 纯组件
class App extends React.PureComponent {
    render() {
        return &lt;Text style={{color: &#39;black&#39;}}&gt;{&#39;点击数0&#39;}&lt;/Text&gt;;
    }
}</code></pre></div>

<div><pre><code class="language-none">// 函数式组件
const App = function () {
    return &lt;Text style={{color: &#39;black&#39;}}&gt;{&#39;点击数0&#39;}&lt;/Text&gt;;
}</code></pre></div>

<p><a href="https://zh-hans.reactjs.org/docs/glossary.html#jsx"><em>JSX</em></a>：是类Html标签式写法转化为纯对象Element函数调用式写法的语法糖。Babel会把JSX转译成一个名为 <a href="https://reactjs.org/docs/react-api.html#createelement">React.createElement</a> 函数调用.</p>

<div><pre><code class="language-none">class App extends React.Component {
    render() {
        // Babel转换JSX后
        return React.createElement(
            // 类型type
            {$$typeof: Symbol(react.forward_ref), displayName: &quot;Text&quot;, propTypes: {…}, render: ƒ},
            // 属性props
            {style: {color: &quot;black&quot;}, __source: {…}},
            // 子节点children
            &quot;点击数0&quot;
        );
    }
}</code></pre></div>

<p><strong><em>Instance</em></strong>：组件实例，组件类实例化的结果，ref指向组件实例（函数式组件不能实例化）。在生成Fiber节点时会调用new Component()创建。</p>

<div><pre><code class="language-none">// App
{
    forceUpdate: ƒ (),
    isReactComponent: ƒ (),
    setState: ƒ (),
    componentDidMount: ƒ (),
    componentWillUnmount: ƒ (),
    constructor: ƒ App(props),
    isMounted: (...),
    render: ƒ (),
    replaceState: (...),
    __proto__: Component
}</code></pre></div>

<p><a href="https://zh-hans.reactjs.org/docs/glossary.html#elements"><strong><em>Element</em></strong></a>：元素，描述了你在屏幕上想看到的内容。是DOM节点的一种纯对象描述，即虚拟DOM，对应组件render方法主要返回值。详见<a href="https://github.com/shengshuqiang/AdvanceOnReactNative/blob/master/AwesomeProject/node_modules/react/cjs/react.development.js#L753">React.createElement</a>。</p>

<div><pre><code class="language-none">// App
{
    // React Element唯一标识
    $$typeof: Symbol(react.element),
    // 开发者指定唯一标识，用于复用
    key: null,
    // 属性
    props: {rootTag: 241},
    // 引用
    ref: null,
    // 类型
    type: ƒ App(props),
    _owner: null,
    _store: {validated: true},
    _self: null,
    _source: {fileName: &quot;/Users/shengshuqiang/dream/AdvanceOnReactNative/Aw…native/Libraries/ReactNative/renderApplication.js&quot;, lineNumber: 38},
    __proto__: Object
}
// Text
{
    $$typeof: Symbol(react.element),
    key: null,
    props: {style: {color: &quot;black&quot;}, children: &quot;点击数0&quot;},
    ref: null,
    type: {$$typeof: Symbol(react.forward_ref), displayName: &quot;Text&quot;, propTypes: {…}, render: ƒ},
    _owner: FiberNode {id: 11, tag: 1, key: null, elementType: ƒ, type: ƒ, …},
    _store: {validated: false},
    _self: null,
    _source: {fileName: &quot;/Users/shengshuqiang/dream/AdvanceOnReactNative/AwesomeProject/App.js&quot;, lineNumber: 213},
    __proto__: Object
}</code></pre></div>

<p><strong><em>FiberNode</em></strong>：碎片化更新中可操作的细粒度节点，用于存储中间态计算结果，为“<strong>可紧急插队、可中断恢复</strong>”的页面刷新提供技术支持。详见<a href="https://github.com/shengshuqiang/AdvanceOnReactNative/blob/master/AwesomeProject/node_modules/react-native/Libraries/Renderer/oss/ReactNativeRenderer-dev.js#L6021">ReactNative.createFiberFromElement</a>。</p>

<div><pre><code class="language-none">// FiberNode
{
    actualDuration: 175.7499999985157,
    actualStartTime: 9793.884999999136,
    // 候补树，在调用render或setState后，会克隆出一个镜像fiber，diff产生出的变化会标记在镜像fiber上。而alternate就是链接当前fiber tree和镜像fiber tree, 用于断点恢复
    alternate: null,
    // 第一个子节点
    child: FiberNode {id: 12, tag: 11, key: null, elementType: {…}, type: {…}, …},
    // TODO
    childExpirationTime: 0,
    contextDependencies: null,
    // 副作用，增删改操作。Placement=2;Update=4;PlacementAndUpdate=6;Deletion=8;
    effectTag: 5,
    // 描述了它对应的组件。对于复合组件，类型是函数或类组件本身。对于宿主组件（div，span等），类型是字符串。定义此 Fiber 节点的函数或类。对于类组件，它指向构造函数，对于 DOM 元素，它指定 HTML 标记。我经常使用这个字段来理解 Fiber 节点与哪个元素相关。
    // ClassComponent对应为函数，如APPContainer()。ForwardRef、ContextConsumer、ContextProvider对应为对象，如{$$typeof: Symbol(react.forward_ref), render: ƒ, displayName: &quot;View&quot;}。HostComponent对应为字符串，如“RCTView”。HostText对应为null。
    elementType: ƒ App(props),
    // TODO
    expirationTime: 0,
    // 用来保存中断前后 effect 的状态，用户中断后恢复之前的操作。这个意思还是很迷糊的，因为 Fiber 使用了可中断的架构
    firstEffect: FiberNode {id: 13, tag: 1, key: null, elementType: ƒ, type: ƒ, …},
    // 我添加的Fiber节点唯一标识（采用id自增生成），用于生成Fiber双树
    id: 11,
    index: 0,
    // 复用标识
    key: null,
    // 参考firstEffect
    lastEffect: FiberNode {id: 13, tag: 1, key: null, elementType: ƒ, type: ƒ, …},
    // 在前一个渲染中用于创建输出的 Fiber 的 props
    memoizedProps: {rootTag: 191},
    // 用于创建输出的 Fiber 状态。处理更新时，它会反映当前在屏幕上呈现的状态
    memoizedState: null,
    mode: 4,
    // workInProgress tree上每个节点都有一个effect list，用来存放需要更新的内容。此节点更新完毕会向子节点或邻近节点合并 effect list
    nextEffect: FiberNode {id: 10, tag: 5, key: null, elementType: &quot;RCTView&quot;, type: &quot;RCTView&quot;, …},
    // props是函数的参数。一个 fiber 的pendingProps在执行开始时设置，并在结束时设置memoizedProps。已从 React 元素中的新数据更新并且需要应用于子组件或 DOM 元素的 props
    pendingProps: {rootTag: 191},
    ref: null,
    // 父节点
    return: FiberNode {id: 10, tag: 5, key: null, elementType: &quot;RCTView&quot;, type: &quot;RCTView&quot;, …},
    selfBaseDuration: 28.63000000070315,
    // 兄弟节点
    sibling: null,
    // 保存组件的类实例、DOM 节点或与 Fiber 节点关联的其他 React 元素类型的引用。总的来说，我们可以认为该属性用于保持与一个 Fiber 节点相关联的局部状态。(HostRoot对应{containerInfo}；ClassComponent对应为new的函数对象实例；HostComponent对应为ReactNativeFiberHostComponent，包含_children和_nativeTag；HostText对应为nativeTag）
    stateNode: hookClazz {props: {…}, context: {…}, refs: {…}, updater: {…}, _reactInternalFiber: FiberNode, …},
    // 它在协调算法中用于确定需要完成的工作。如前所述，工作取决于React元素的类型
    tag: 1,
    treeBaseDuration: 155.36499999871012,
    // 同elementType
    type: ƒ App(props),
    // state更新队列。状态更新、回调和 DOM 更新的队列
    updateQueue: null,
    _debugID: 12,
    _debugIsCurrentlyTiming: false,
    _debugOwner: null,
    _debugSource: {fileName: &quot;/Users/shengshuqiang/dream/AdvanceOnReactNative/Aw…native/Libraries/ReactNative/renderApplication.js&quot;, lineNumber: 38},
    __proto__: Object
}</code></pre></div>

<p><strong><em>DOM</em></strong>：文档对象模型（Document Object Model），简单说就是界面控件树（对应Html是DOM树，对应Native是View树）的节点。</p>

<div><pre><code class="language-none">UIManager.createView    [3,&quot;RCTRawText&quot;,1,{&quot;text&quot;:&quot;点击数0&quot;}]
UIManager.createView    [5,&quot;RCTText&quot;,1,{&quot;ellipsizeMode&quot;:&quot;tail&quot;,&quot;allowFontScaling&quot;:true,&quot;accessible&quot;:true,&quot;color&quot;:-16777216}]
UIManager.setChildren   [5,[3]]
UIManager.createView    [7,&quot;RCTView&quot;,1,{&quot;flex&quot;:1,&quot;pointerEvents&quot;:&quot;box-none&quot;,&quot;collapsable&quot;:true}]
UIManager.setChildren   [7,[5]]
UIManager.createView    [9,&quot;RCTView&quot;,1,{&quot;pointerEvents&quot;:&quot;box-none&quot;,&quot;flex&quot;:1}]
UIManager.setChildren   [9,[7]]
UIManager.setChildren   [1,[9]]</code></pre></div>

<p><TODOimg style="border-radius: 10px;box-shadow: darkgrey 0px 0px 10px 5px" src="https://shengshuqiang.github.io/assets/Component-Instance-Element-FiberNode.png"/></p>

<h2 id="toc_13">运行（Playground）</h2>

<p>搭一个自己专属的游乐场--本地可运行环境（我的是macOS电脑 + Android手机）。</p>

<ol>
<li>安装软件：Webstorm（前端开发环境）、AndroidStudio（Android开发环境，送Android模拟器）。</li>
<li>安装依赖：安装Xcode（iOS开发环境，送iPhone模拟器）就顺带解决了。</li>
<li>使用 React Native 命令行工具来创建一个名为&quot;AwesomeProject&quot;的新项目：<code>react-native init AwesomeProject</code>。</li>
<li>欧了，<a href="https://github.com/shengshuqiang/AdvanceOnReactNative/blob/master/AwesomeProject/App.js">简单Demo</a>（页面一个红色按钮，初始显示点击数0，点击切换为“汽车”图标）测试一下。该Demo主要用于观察初始渲染和用户点击渲染。<br><img style="border-radius: 10px;box-shadow: darkgrey 0px 0px 10px 5px;padding: 3px" src="https://shengshuqiang.github.io/assets/简单demo.gif"/></li>
<li>更多配置详见<a href="https://reactnative.cn/docs/getting-started.html">React Native 中文网-搭建开发环境</a>。</li>
</ol>

<h2 id="toc_14">源码</h2>

<p>我们来读源码（16.8.3 react，0.59.8 react-native）吧！</p>

<ul>
<li>RN上层JS代码主要实现在<a href="https://github.com/shengshuqiang/AdvanceOnReactNative/blob/master/AwesomeProject/node_modules/react-native/Libraries/Renderer/oss/ReactNativeRenderer-dev.js">ReactNativeRenderer-dev.js</a>这一个文件，代码行数2W出头（区区2W，好像压力也没辣么大）。</li>
<li><a href="https://github.com/shengshuqiang/AdvanceOnReactNative/blob/master/AwesomeProject/node_modules/react/cjs/react.development.js">react.development.js</a>：纯JS侧React相关定义和简单实现。</li>
<li><a href="https://github.com/shengshuqiang/AdvanceOnReactNative/blob/master/AwesomeProject/react.d.ts">react.d.ts</a>：接口定义，详见本地目录/Applications/WebStorm.app/Contents/plugins/JavaScriptLanguage/jsLanguageServicesImpl/external/react.d.ts。</li>
</ul>

<div><pre><code class="language-none">#  源码目录/Users/shengshuqiang/dream/AdvanceOnReactNative/AwesomeProject/node_modules
.
├── react
│   └── cjs
│       └── react.development.js # 纯JS侧React相关定义和简单实现
└── react-native
    ├── LICENSE
    └── Libraries
        ├── Components # 官方提供的各种组件，如View、ScrollView、Touchable等
        └── Renderer
            └── oss
                ├── GreateNavigationArt.js # “大海航术”核心实现，主要hook调用，打印调用栈日志和dump Fiber双树信息，约600行
                └── ReactNativeRenderer-dev.js # ReactNative上层JS代码核心实现，约2W行
</code></pre></div>

<h2 id="toc_15">迷航</h2>

<p>我的读码套路：读博客➢跑Demo➢打日志➢打断点➢大猜想➢证因果➢得结论。</p>

<ol>
<li>开局大量读技术博客，建立一个知识地图。</li>
<li>写个Demo先嗨一把，敲敲打打找点感觉。</li>
<li>为了避免从入门到放弃，一定要先日志抬头看路，后断点埋头搬砖。稍微复杂点的算法，通常上来就是一顿大循环和深递归，没有强目标导向，只能GG。</li>
<li>到了尽情发挥你野兽般的想象力（悟）的时候了，Why？What？How？</li>
<li>带着问题找答案，追根溯源。</li>
<li>再回首，总结复盘。回答有啥用，能不能自圆其说，可不可以唬住不懂的人（包括我自己），是不是假装懂了。</li>
</ol>

<p>说了这么多，我也记不住。抽象一下，这不就是在茫茫大海航行的技术么，就叫“<strong>航海术</strong>”吧。</p>

<p><img style="border-radius: 10px;box-shadow: darkgrey 0px 0px 10px 5px" src="https://tTODOimgsa.baidu.com/tTODOimg?image&quality=80&size=b9999_10000&sec=1573395220&di=4341e4831d06b5ebf7419b1a421589af&TODOimgtype=jpg&er=1&src=http%3A%2F%2Fpic.51yuansu.com%2Fpic3%2Fcover%2F03%2F69%2F16%2F5be630744b7fb_610.jpg"/></p>

<p>对付简单的算法，这招基本够用，否则就真的钱难挣了。但是，Fiber算法，真的难。第一个回合硬着头皮看下来，只知道一堆乱七八糟的调用，混杂着各种光怪陆离的属性，而且还用到了复杂的双树数据结构。</p>

<p>这些，小本子根本记不过来。来张我的笔记感受一下（不用细看，我也没打算讲这张图），一波操作下来，差不多要2天闭关专注的投入，要是被打断了，都找不到北。</p>

<p><img style="border-radius: 10px;box-shadow: darkgrey 0px 0px 10px 5px" src="https://km.meituan.net/212321734.png?contentType=1&contentId=207390791&attachmentId=212321735&originUrl=https://km.meituan.net/212321734.png&token=eAHjYBRYt4xZYeu5RZ8f6xpJJefn6hUn5mWXJmbqZZbopSam6CVnliSmpOZYKRgaGacYmiUmJltaGJkkW5haWqaaaCWZmhgbpaWYmxomOVkorLmype-5rgaTEUHFFkBbHVg8bi-4cPaRbpRCcpKxkaF5ipmJqZahiUGqAdASc8tUC5PENAMTgxTDJAAVXzT2**eAEVyMkRwDAIBLCWzHKZcsBA_yVkoqfoSTq1McojcRbPLQMqZ_8jcO1Oj01JdvHG3JFtvQZW_QA8NhHl&template=0&isDownload=false&isNewContent=false"/>](https://shengshuqiang.github.io/assets/深入ReactNative.xmind)</p>

<p>按这个套路，<strong>连</strong>日志<strong>加</strong>调试<strong>带</strong>瞎猜，发现装不下去了，我太难了。一度跌入绝望之谷，挣扎着把源码看了三遍（毕竟指望这一波发财），仍然没什么收获，等着顿悟吧。</p>

<h2 id="toc_16">微光</h2>

<p>直到那一天，我终于等到了这个变数--如果能可视化Fiber双树在运行时的状态变化，是否有望突破React技术壁垒？</p>

<p>脑子再活一点的我就想：“可不可以写个脚本把Fiber双树画出来”，随后的问题就是“能不能写个插件实时绘制运行时Fiber双树”，进一步“绘制实时方法调用树（看着有点像抽象语法树），有问题吗？”能有啥问题，没问题，那就干。</p>

<p><img style="border-radius: 10px;box-shadow: darkgrey 0px 0px 10px 5px" src="https://shengshuqiang.github.io/assets/绘制Fiber树Demo.png"/>](https://shengshuqiang.github.io/assets/DrawFiber/Drawfiber.1.1.html)</p>

<p>说到底，“<strong>海航术</strong>”通过日志和调试阅读源码的方向是没有问题的，有问题的是仅通过分析上万条日志信息，过程枯燥乏味，很难通过想象串联这么大量级的信息。如果借助工具提高生产力，可视化图像具象日志信息，那就能攻守易势。特别对于这种抽象的树形结构，没有什么比画图更通俗易懂了。</p>

<p>本着<strong>DRY（Dont Repeat Yourself）</strong>原则，一步步迭代插件。当然，过程是艰辛的，无法一蹴而就。能想到接入react-devtools插件，是因为李阳大牛推荐过该工具帮助分析Virtual DOM树，恰巧彼时团队内部也有童靴在扩展该工具。接入插件当时并没有把握，表面上是扩大战果，但也可能被拖入新的泥潭，舍本逐末。幸好运气不错，在瓶颈期通过董思文和陈卓双大牛的点拨下，灰常顺利的搞出来了。</p>

<p><img src="https://shengshuqiang.github.io/assets/ReactDeveloperToolsDemo.png" alt=""></p>

<p>这里必须给react-devtools点32个赞，这是我迄今见过最好的架构，我就一JS倔强青铜的水平，竟然看着文档能把源码跑起来（过程中编译相关小问题找大牛给解了），进一步把自己的脚本集成进去，模仿已有脚本一顿Ctrl+F、Ctrl+C、Ctrl+V就成了，延展性可见一斑，不服不行。</p>

<h2 id="toc_17">大海航术</h2>

<p>“<strong>海航术</strong>”的大方向（日志、调试、想象）是正确的，这个想象操作空间太大，是个非标品。“<strong>大海航术</strong>”的大就在可视化放飞想象力。</p>

<ol>
<li>以<strong>React方法调用树图</strong>为主线，监控每一个方法调用，不轻易放过任何一个细节，弄清楚他是谁、从哪来、到哪去。同时以Fiber节点操作为里程碑，dump出当前Fiber树（Fiber双树图数据源），衍生出可供<strong>时间旅行</strong>的慢动作回放，便于步步为营式探索。<br><img src="https://shengshuqiang.github.io/assets/React%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E6%A0%91%E5%9B%BE.png" alt=""></li>
<li>以<strong>Fiber双树图</strong>为小因果，讲清楚Fiber树的每次变化。Fiber算法的核心就是分段式操作Fiber树计算出副作用（DOM操作），然后一次提交（刷新页面）。带着问题去阅读是一种怎样的体验？<br><img src="https://shengshuqiang.github.io/assets/Fiber%E5%8F%8C%E6%A0%91%E5%9B%BE.png" alt=""></li>
<li>以<strong>Native View树图</strong>为大因果，说明白Native View树的每次变化。Fiber算法的目标就是生成操作Native View树的一系列指令。<br><img src="https://shengshuqiang.github.io/assets/NativeView%E6%A0%91%E5%9B%BE.png" alt=""></li>
</ol>

<p>让我们一起感受一下大海航术的视觉盛宴吧。
<a href="https://shengshuqiang.github.io/assets/DrawFiber/Drawfiber.2.0.html"><img src="https://shengshuqiang.github.io/assets/%E5%A4%A7%E6%B5%B7%E8%88%AA%E6%9C%AF%E5%8A%A8%E5%9B%BE.gif" alt=""></a></p>

<p><a href="https://shengshuqiang.github.io/assets/DrawFiber/Drawfiber.2.0.html"><img src="https://shengshuqiang.github.io/assets/%E5%A4%A7%E6%B5%B7%E8%88%AA%E6%9C%AF%E5%8A%A8%E5%9B%BE2.gif" alt=""></a></p>

<p>更多详见<a href="https://shengshuqiang.github.io/assets/DrawFiber/Drawfiber.2.0.html">Html Demo 页面</a>。</p>

<h2 id="toc_18">用户态（浅水区）</h2>

<p><a href="https://zh-hans.reactjs.org/docs/getting-started.html">React官方文档</a>和简单Debug能解决大部分问题（前提你得知道问题是什么），剩下的交给时间（时间是一种解药，也是一种毒药）。</p>

<p><a href="https://zh-hans.reactjs.org/docs/react-component.html#other-apis-1"><strong>组件API</strong></a></p>

<table>
<thead>
<tr>
<th>组件变量/方法</th>
<th>概念</th>
<th>调用时机</th>
<th>作用</th>
<th>最佳实践</th>
</tr>
</thead>

<tbody>
<tr>
<td><a href="https://zh-hans.reactjs.org/docs/glossary.html#props">props</a></td>
<td>属性</td>
<td>使用时设置属性<br>this.props读取</td>
<td>存储父组件传递的信息</td>
<td>1. UI组件，根据属性纯展示，没有内部逻辑</td>
</tr>
<tr>
<td><a href="https://zh-hans.reactjs.org/docs/glossary.html#state">state</a></td>
<td>状态</td>
<td>setState设置<br>this.state读取</td>
<td>存储自身维护的状态</td>
<td>1. 容器组件，纯逻辑处理，通过组合UI组件完成渲染<br>2. 构造函数直接this.state赋值。否则setState替代<br>3. <a href="https://zh-hans.reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#anti-pattern-unconditionally-copying-props-to-state">反面模式: 直接复制 prop 到 state</a></td>
</tr>
<tr>
<td><a href="https://zh-hans.reactjs.org/docs/react-component.html#constructor">constructor</a></td>
<td>构造函数</td>
<td>在React组件挂载之前</td>
<td>用于创建组件实例</td>
<td>1. 初始化state或进行方法绑定，否则不需要实现<br>2. 不是props传递的唯一入口（仅初始化调用，后续props更新不调用）<br>3. super(props)必须在使用this.props之前调用</td>
</tr>
<tr>
<td><a href="https://zh-hans.reactjs.org/docs/react-component.html#setstate">setState</a></td>
<td>设置状态</td>
<td>用户主动调用</td>
<td>将更改排入队列并通知重新渲染</td>
<td>1. 控制影响组件粒度，避免大规模刷新（性能杀手）<br>2. 区分哪些生命周期中不能调用setState，避免死循环<br>3. 仅影响组件显示状态的数据放在state里面，其他数据可用成员变量存储<br>4. 不总是立即更新组件，会批量推迟更新</td>
</tr>
<tr>
<td><a href="https://zh-hans.reactjs.org/docs/react-component.html#forceupdate">forceUpdate</a></td>
<td>强制更新</td>
<td>用户主动调用</td>
<td>跳过shouldComponentUpdate直接触发render</td>
<td>1. 谨慎使用<br>2. 如render方法依赖于其他数据，则可调用forceUpdate强制刷新</td>
</tr>
<tr>
<td><a href="https://zh-hans.reactjs.org/docs/react-component.html#render">render</a></td>
<td>渲染<br>唯一必须实现</td>
<td>Diff比较前</td>
<td>描述当前组件的颜值</td>
<td>1. 合理通过组件进行封装，确保可读性和可维护性<br>2. 减少inline-function<br>3. 养成良好的编程习惯（可扩展性、鲁棒性、可靠性、易用性、可移植性等）</td>
</tr>
</tbody>
</table>

<p><a href="https://zh-hans.reactjs.org/docs/react-component.html#the-component-lifecycle"><strong>生命周期</strong></a></p>

<p>每个组件都包含“生命周期方法”，你可以重写这些方法，以便于在运行过程中特定的阶段执行这些方法。</p>

<table>
<thead>
<tr>
<th>生命周期</th>
<th>概念</th>
<th>类型</th>
<th>调用时机</th>
<th>调用次数</th>
<th>调用setState</th>
<th>作用</th>
<th>最佳实践</th>
</tr>
</thead>

<tbody>
<tr>
<td><a href="https://zh-hans.reactjs.org/docs/react-component.html#static-getderivedstatefromprops">static getDerivedStateFromProps</a></td>
<td>从属性获取状态</td>
<td>常规方法</td>
<td>在调用render方法之前调用（初始挂载及后续更新时都调用）</td>
<td>多次</td>
<td>不支持（无法持有引用）</td>
<td>返回一个对象来更新 state（返回null则不更新任何内容）</td>
<td>适用于state值在任何时候都取决于props</td>
</tr>
<tr>
<td><a href="https://zh-hans.reactjs.org/docs/react-component.html#getsnapshotbeforeupdate">getSnapshotBeforeUpdate</a></td>
<td>更新前获取快照回调</td>
<td>新增方法</td>
<td>在最近一次渲染输出（提交到 DOM 节点）之前调用</td>
<td>多次</td>
<td>支持</td>
<td>使得组件能在发生更改之前从 DOM 中捕获一些信息</td>
<td>不常见，可能出现在 UI 处理中（如滚动位置）</td>
</tr>
<tr>
<td><a href="https://zh-hans.reactjs.org/docs/react-component.html#componentdidupdate">componentDidUpdate</a></td>
<td>组件已更新回调</td>
<td>新增方法</td>
<td>在更新后会被立即调用（首次渲染和shouldComponentUpdate返回false时不会调用）</td>
<td>多次</td>
<td>支持</td>
<td>当组件更新后，可以在此处对 DOM 进行操作</td>
<td>对更新前后的 props 进行了比较判断后触发逻辑（props变化时触发网络请求）</td>
</tr>
<tr>
<td>componentWillMount<br><a href="https://zh-hans.reactjs.org/docs/react-component.html#unsafe_componentwillmount">UNSAFE_componentWillMount</a></td>
<td>组件待挂载回调</td>
<td>废弃方法</td>
<td>在挂载之前被调用</td>
<td>一次</td>
<td>支持</td>
<td>用于触发挂载前逻辑</td>
<td>避免在此方法中引入任何副作用或订阅（改用componentDidMount）</td>
</tr>
<tr>
<td>componentWillReceiveProps<br><a href="https://zh-hans.reactjs.org/docs/react-component.html#unsafe_componentwillreceiveprops">UNSAFE_componentWillReceiveProps</a></td>
<td>组件待接收属性回调</td>
<td>废弃方法</td>
<td>在已挂载的组件接收新的 props 之前被调用（初始渲染和setState不调用）</td>
<td>多次</td>
<td>支持</td>
<td>用于触发接收属性前逻辑</td>
<td>1. 不建议用（使用通常会出现 bug 和不一致性）<br>2. 更新状态以响应 prop 更改</td>
</tr>
<tr>
<td>componentWillUpdate<br><a href="https://zh-hans.reactjs.org/docs/react-component.html#unsafe_componentwillupdate">UNSAFE_componentWillUpdate</a></td>
<td>组件待更新回调</td>
<td>废弃方法</td>
<td>当组件收到新的 props 或 state 时，在渲染之前调用（初始渲染和shouldComponentUpdate返回false不会调用）</td>
<td>多次</td>
<td>不支持（避免循环调用）</td>
<td>用于触发组件更新前逻辑</td>
<td>不建议用（改用componentDidUpdate）</td>
</tr>
<tr>
<td><a href="https://zh-hans.reactjs.org/docs/react-component.html#componentdidmount">componentDidMount</a></td>
<td>组件已挂载回调</td>
<td>常规方法</td>
<td>在组件挂载后（插入 DOM 树中）立即调用</td>
<td>一次</td>
<td>支持</td>
<td>用于触发挂载后逻辑</td>
<td>依赖于 DOM 节点的初始化（添加订阅、网络请求）应该放在这里</td>
</tr>
<tr>
<td><a href="https://zh-hans.reactjs.org/docs/react-component.html#shouldcomponentupdate">shouldComponentUpdate</a></td>
<td>组件是否更新</td>
<td>常规方法</td>
<td>当props或state发生变化时，会在渲染执行之前被调用（首次渲染或使用forceUpdate时不会调用）</td>
<td>多次</td>
<td>不支持（避免循环调用）</td>
<td>减少不必要的渲染（性能优化）</td>
<td>1.考虑使用内置的PureComponent组件 <br>2. 不建议深比较（性能杀手）</td>
</tr>
<tr>
<td><a href="https://zh-hans.reactjs.org/docs/react-component.html#componentwillunmount">componentWillUnmount</a></td>
<td>组件待卸载回调</td>
<td>常规方法</td>
<td>在组件卸载及销毁之前直接调用</td>
<td>一次</td>
<td>不支持（该组件将永远不会重新渲染和挂载）</td>
<td>用于触发卸载前逻辑</td>
<td>执行必要的清理操作（清除timer、取消网络请求、注销订阅等）</td>
</tr>
<tr>
<td><a href="https://zh-hans.reactjs.org/docs/react-component.html#componentdidcatch">componentDidCatch</a></td>
<td>子组件出错回调</td>
<td>常规方法</td>
<td>在子组件抛出错误后被调用</td>
<td>多次</td>
<td>支持</td>
<td>用于记录错误</td>
<td>上报错误日志</td>
</tr>
</tbody>
</table>

<p><a href="http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/"><img src="https://shengshuqiang.github.io/assets/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E8%B0%B1.png" alt=""></a></p>

<p><img src="https://shengshuqiang.github.io/assets/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%B0%83%E7%94%A8.png" alt=""></p>

<p><strong>备注：</strong></p>

<ul>
<li>新增和废弃生命周期混用时，只会知悉新的生命周期</li>
<li>生命周期中是调用setState的前提是：没有循环调用风险（shouldComponentUpdate和componentWillUpdate中调用会导致循环调用）、受限（必须包裹在条件语件里）条件下运行调用、有意义（componentWillUnmount调用无意义）、能调用（static getDerivedStateFromProps里面无法调用），详见<a href="http://www.ptbird.cn/react-state-setState.html">React setState 实现机制及循环调用风险</a></li>
</ul>

<h3 id="toc_19">内核态（深水区）</h3>

<p><img src="http://ddrvcn.oss-cn-hangzhou.aliyuncs.com/2019/7/7NJRve.jpg" alt="循序渐进"></p>

<p>终于到了压轴环节，上大海航术动图。</p>

<p>受限于屏幕大小，无法鸟瞰全貌，后续考虑直接生成一个网页。</p>

<p>React源码解析，需要牢记：React组件是数据的函数，v = f(d)。抓住输入和输出，才能有的放矢。本次解析分为二段，初始渲染时间线（用户进入页面Fiber算法干啥类）、用户点击渲染时间线（用户点击按钮切换文本为图标，Fiber算法又干啥类）。这两个场景是所有Fiber算法行为的本源，万变不离其宗。然后再用简单伪代码回顾一下。</p>

<h3 id="toc_20">初始渲染时间线</h3>

<p><strong>初始化页面布局</strong>(里面有一堆组件，远比我们写的要多)</p>

<p><img src="https://shengshuqiang.github.io/assets/%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80.png" alt=""></p>

<p><strong>初始化JS2Native通信</strong>(通信主要是通过桥UIManager调用createView创建、setChildren关联（增删改）和updateView更新)</p>

<div><pre><code class="language-none">1. invoke    UIManager.createView    [3,&quot;RCTRawText&quot;,11,{&quot;text&quot;:&quot;点击数0&quot;}]
2. invoke    UIManager.createView    [5,&quot;RCTText&quot;,11,{&quot;ellipsizeMode&quot;:&quot;tail&quot;,&quot;allowFontScaling&quot;:true,&quot;accessible&quot;:true,&quot;fontSize&quot;:30,&quot;color&quot;:-1,&quot;textAlignVertical&quot;:&quot;center&quot;,&quot;textAlign&quot;:&quot;center&quot;}]
3. invoke    UIManager.setChildren    [5,[3]]
4. invoke    UIManager.createView    [7,&quot;RCTView&quot;,11,{&quot;backgroundColor&quot;:-65536,&quot;height&quot;:150,&quot;width&quot;:300,&quot;accessible&quot;:true}]
5. invoke    UIManager.setChildren    [7,[5]]
6. invoke    UIManager.createView    [9,&quot;RCTView&quot;,11,{&quot;flex&quot;:1,&quot;pointerEvents&quot;:&quot;box-none&quot;,&quot;collapsable&quot;:true}]
7. invoke    UIManager.setChildren    [9,[7]]
8. 
9. invoke    UIManager.createView    [13,&quot;RCTView&quot;,11,{&quot;pointerEvents&quot;:&quot;box-none&quot;,&quot;flex&quot;:1}]
10. invoke    UIManager.setChildren    [13,[9]]
11. 
12. invoke    UIManager.setChildren    [11,[13]]</code></pre></div>

<p><strong>初始化Fiber树</strong></p>

<p><img src="https://shengshuqiang.github.io/assets/%E5%88%9D%E5%A7%8B%E5%8C%96Fiber%E6%A0%91.jpg" alt=""></p>

<p><strong>初始化NativeView树</strong></p>

<p><img src="https://shengshuqiang.github.io/assets/%E5%88%9D%E5%A7%8B%E5%8C%96NativeView%E6%A0%91.png" alt=""></p>

<p><strong>手机横过来看</strong></p>

<p><a href="https://shengshuqiang.github.io/assets/React%E7%AE%97%E6%B3%95%E5%88%9D%E5%A7%8B%E6%B8%B2%E6%9F%93%E6%97%B6%E9%97%B4%E7%BA%BF-%E6%A8%AA%E7%89%88.png"><img src="https://shengshuqiang.github.io/assets/React%E7%AE%97%E6%B3%95%E5%88%9D%E5%A7%8B%E6%B8%B2%E6%9F%93%E6%97%B6%E9%97%B4%E7%BA%BF-%E6%A8%AA%E7%89%88.png" alt=""></a></p>

<h3 id="toc_21">用户点击渲染时间线</h3>

<p><strong>用户点击页面组件布局</strong></p>

<p><img src="https://shengshuqiang.github.io/assets/%E7%82%B9%E5%87%BB%E9%A1%B5%E9%9D%A2%E7%BB%84%E4%BB%B6%E5%B8%83%E5%B1%80.png" alt=""></p>

<p><strong>用户点击JS2Native通信</strong>，</p>

<div><pre><code class="language-none">1. invoke    UIManager.measure    [7,27]
1. invoke    UIManager.playTouchSound    []
2. invoke    UIManager.createView    [15,&quot;RCTImageView&quot;,11,{&quot;loadingIndicatorSrc&quot;:null,&quot;defaultSrc&quot;:null,&quot;src&quot;:[{&quot;uri&quot;:&quot;http://demo.sc.chinaz.com/Files/pic/icons/5918/c12.png&quot;}],&quot;shouldNotifyLoadEvents&quot;:false,&quot;opacity&quot;:0.85,&quot;overflow&quot;:&quot;hidden&quot;,&quot;height&quot;:100,&quot;width&quot;:100}]
3. invoke    UIManager.manageChildren    [7,[],[],[],[],[0]]
4. invoke    UIManager.manageChildren    [7,[],[],[15],[0],[]]
5. invoke    UIManager.updateView    [7,&quot;RCTView&quot;,{&quot;backgroundColor&quot;:-16777216}]
1. invoke    UIManager.updateView    [15,&quot;RCTImageView&quot;,{&quot;opacity&quot;:null}]
2. invoke    UIManager.updateView    [7,&quot;RCTView&quot;,{&quot;backgroundColor&quot;:-65536}]</code></pre></div>

<p><strong>用户点击Fiber树</strong></p>

<p><img src="https://shengshuqiang.github.io/assets/%E7%94%A8%E6%88%B7%E7%82%B9%E5%87%BB%E6%B8%B2%E6%9F%93Fiber%E5%8F%8C%E6%A0%91%E5%9B%BE.jpg" alt=""></p>

<p><strong>用户点击NativeView树</strong></p>

<p><img src="https://shengshuqiang.github.io/assets/%E7%94%A8%E6%88%B7%E7%82%B9%E5%87%BBNativeView%E6%A0%91%E5%9B%BE.png" alt=""></p>

<p><strong>手机横过来看</strong></p>

<p><a href="https://shengshuqiang.github.io/assets/React%E7%AE%97%E6%B3%95%E7%94%A8%E6%88%B7%E7%82%B9%E5%87%BB%E6%B8%B2%E6%9F%93%E6%97%B6%E9%97%B4%E7%BA%BF-%E6%A8%AA%E7%89%88.png"><img src="https://shengshuqiang.github.io/assets/React%E7%AE%97%E6%B3%95%E7%94%A8%E6%88%B7%E7%82%B9%E5%87%BB%E6%B8%B2%E6%9F%93%E6%97%B6%E9%97%B4%E7%BA%BF-%E6%A8%AA%E7%89%88.png" alt=""></a></p>

<h3 id="toc_22">小结</h3>

<p>“render” 阶段生命周期和 “commit” 阶段生命周期</p>

<h4 id="toc_23">简约伪代码</h4>

<p>// TODO highlight.js使用
<a href="https://facebook.github.io/react-native/docs/performance.html#common-sources-of-performance-problems"></a>
可编辑表格</p>

<p>Talk is cheap. Show me the code.</p>

<div><pre><code class="language-none">function ReactNativeRenderer_render() {
    const ClassComponent = 1;
    const HostComponent = 5;
    const HostText = 6;
    const Snapshot = 256;
    const Placement = 2;
    const Update = 4;
    const PlacementAndUpdate = 6;
    const Deletion = 8;

    const root = {};
    const {current, workInProgress, rootContainerInstance} = root;
    let {nextUnitOfWork, nextEffect} = root;
    const {oldProps, newProps, oldState, newState, oldContext, newContext} = workInProgress;
    /** performWorkOnRoot */
    {
        /** renderRoot */
        {
            // 深度优先遍历完所有Fiber节点
            /** workLoop */
            {
                while (nextUnitOfWork !== null) {
                    /** performUnitOfWork */
                    {
                        /** beginWork */
                        {
                            // 判断数据是否变化（属性相关）
                            const hasDataChanged = {}
                            // 数据没有变化，则直接当前Fiber节点克隆出工作Fiber节点，详见bailoutOnAlreadyFinishedWork
                            const bailoutOnAlreadyFinishedWork = function (workInProgress) {
                            };
                            if (!hasDataChanged) {
                                nextUnitOfWork = bailoutOnAlreadyFinishedWork(workInProgress);
                            } else {
                                // 数据变化，重新创建Fiber节点
                                /** updateXXX */
                                switch (workInProgress.tag) {
                                    case ClassComponent: {
                                        /** updateClassComponent
                                         * 调用生命周期，新旧取决于用于在类里面增加的方法是新还是旧，
                                         * 如果都有则只调用新的，新生命周期对应construct-&gt;getDerivedStateFromProps-&gt;render，
                                         * 旧生命周期对应construct-&gt;componentWillMount-&gt;UNSAFE_componentWillMount-&gt;render。
                                         * nextChildren = instance.render()
                                         * */
                                        {
                                            let instance = workInProgress.stateNode;
                                            // 根据是否有新生命周期方法判断是否要调用旧生命周期
                                            const ctor = workInProgress.type;
                                            const getDerivedStateFromProps = ctor.getDerivedStateFromProps;
                                            const hasNewLifecycles = ctor.getDerivedStateFromProps &amp;&amp; instance.getSnapshotBeforeUpdate;
                                            if (instance === null) {
                                                // 初始创建
                                                /** constructClassInstance */
                                                {
                                                    // 调用construct实例化组件
                                                    instance = new ctor();
                                                }
                                                /** mountClassInstance */
                                                {
                                                    /** applyDerivedStateFromProps */
                                                    {
                                                        // 调用新生命周期getDerivedStateFromProps
                                                        getDerivedStateFromProps(newProps, oldState);
                                                    }

                                                    if (!hasNewLifecycles) {
                                                        // 调用旧生命周期
                                                        /** callComponentWillMount */
                                                        {
                                                            // 调用旧生命周期componentWillMount
                                                            instance.componentWillMount();
                                                            instance.UNSAFE_componentWillMount();
                                                        }
                                                    }
                                                }
                                            } else {
                                                // 已存在，则Diff更新(为了简化，忽略resumeMountClassInstance)
                                                /** updateClassInstance */
                                                {
                                                    // 更新实例
                                                    let shouldUpdate;
                                                    const hasPropsChanged = oldProps !== newProps || oldContext !== newContext;
                                                    if (!hasNewLifecycles &amp;&amp; hasPropsChanged) {
                                                        // 无新生命周期且属性变化
                                                        /** callComponentWillReceiveProps */
                                                        {
                                                            // 调用旧生命周期componentWillReceiveProps
                                                            instance.componentWillReceiveProps(newProps, newContext);
                                                            instance.UNSAFE_componentWillReceiveProps(newProps, newContext);
                                                        }
                                                    }

                                                    /** applyDerivedStateFromProps */
                                                    {
                                                        // 调用新生命周期getDerivedStateFromProps
                                                        getDerivedStateFromProps(newProps, oldState);
                                                    }

                                                    /** checkShouldComponentUpdate */
                                                    {
                                                        if (instance.shouldComponentUpdate) {
                                                            // 刷新逻辑交个用户控制，也就是大家说的高性能操作
                                                            shouldUpdate = instance.shouldComponentUpdate(newProps, newState, newContext);
                                                        } else if (ctor.prototype.isPureReactComponent) {
                                                            // 纯组件，进行浅比较判断是否刷新
                                                            const shallowEqual = function () {
                                                            };
                                                            shouldUpdate = !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);
                                                        } else {
                                                            // 普通组件，直接刷新
                                                            shouldUpdate = true;
                                                        }
                                                    }

                                                    if (shouldUpdate) {
                                                        if (!hasNewLifecycles) {
                                                            // 调用旧生命周期componentWillUpdate
                                                            instance.componentWillUpdate(newProps, newState, newContext);
                                                            instance.UNSAFE_componentWillUpdate(newProps, newState, newContext);
                                                        }
                                                    }
                                                }
                                            }
                                            /** finishClassComponent */
                                            {
                                                if (!shouldUpdate) {
                                                    nextUnitOfWork = bailoutOnAlreadyFinishedWork(workInProgress);
                                                } else {
                                                    const nextChildren = instance.render();
                                                    /** reconcileChildFibers
                                                     * 硬核Diff算法
                                                     * */
                                                    {
                                                        const isObject = typeof nextChildren === &quot;object&quot; &amp;&amp; nextChildren;
                                                        if (isObject) {
                                                            /** reconcileSingleElement */
                                                            {
                                                                if (workInProgress) {
                                                                    // 判断key是否相等
                                                                    const isKeyEquals = workInProgress.key === nextChildren.key;
                                                                    if (isKeyEquals) {
                                                                        // 判断类型是否相同
                                                                        const isTypeEquals = child.elementType === nextChildren.type;
                                                                        if (isTypeEquals) {
                                                                            // Diff算法:类型相同,复用子节点树&amp;删除子节点兄弟树
                                                                            (function deleteRemainingChildren(sibling) {
                                                                            })(workInProgress.sibling);
                                                                            workInProgress.child = (function useFiber(workInProgress) {
                                                                            })(workInProgress);
                                                                        } else {
                                                                            // Diff算法:类型不相同,删除全部子节点树
                                                                            (function deleteRemainingChildren(sibling) {
                                                                            })(workInProgress);
                                                                            // Diff算法:新建子节点
                                                                            workInProgress.child = (function createFiberFromElement(nextChildren) {
                                                                            })(nextChildren);
                                                                        }
                                                                    } else {
                                                                        // Diff算法:key不同,删除子节点树
                                                                        (function deleteChild(sibling) {
                                                                        })(workInProgress);
                                                                        // Diff算法:新建子节点
                                                                        workInProgress.child = (function createFiberFromElement(nextChildren) {
                                                                        })(nextChildren);
                                                                    }
                                                                }
                                                            }
                                                        } else {
                                                            /** 暂时忽略 */
                                                            // string、number
                                                            // array
                                                            // iterator
                                                            // undefined
                                                            // deleteRemainingChildren(returnFiber, currentFirstChild)
                                                        }
                                                    }
                                                    nextUnitOfWork = workInProgress.child;
                                                }
                                            }
                                        }
                                        break;
                                    }
                                    default:
                                        /** 忽略，不重要 */
                                        break;
                                }
                            }
                            nextUnitOfWork = beginWork(current$$1, workInProgress, nextRenderExpirationTime);
                        }
                        if (nextUnitOfWork === null) {
                            {
                                /** completeUnitOfWork
                                 *  深度优先遍历回溯，调用桥UIManager创建&amp;连接Native View。
                                 *  同时生成副作用链表。
                                 *  */
                                while (true) {
                                    // nextUnitOfWork = completeWork(
                                    /** completeWork */
                                    {
                                        switch (workInProgress.tag) {
                                            case HostComponent: {
                                                // 是否已实例化
                                                const hasInstance = current &amp;&amp; workInProgress.stateNode != null;
                                                if (hasInstance) {
                                                    /** updateHostComponent$1 */
                                                    {
                                                        if (oldProps !== newProps) {
                                                            const updatePayload = (function prepareUpdate(workInProgress) {
                                                            })(workInProgress);
                                                            workInProgress.updateQueue = updatePayload;
                                                        }
                                                    }
                                                } else {
                                                    let instance;
                                                    const tag = (function allocateTag() {
                                                    })();
                                                    const ReactNativeViewConfigRegistry = function () {
                                                    };
                                                    const viewConfig = ReactNativeViewConfigRegistry.get(workInProgress);
                                                    const updatePayload = create(props, viewConfig.validAttributes);
                                                    /** createInstance */
                                                    {
                                                        UIManager.createView(
                                                            tag, // reactTag
                                                            viewConfig.uiViewClassName, // viewName
                                                            rootContainerInstance, // rootTag
                                                            updatePayload // props
                                                        );

                                                        function ReactNativeFiberHostComponent() {
                                                        };
                                                        instance = new ReactNativeFiberHostComponent(tag, viewConfig)
                                                    }
                                                    /** appendAllChildren */
                                                    {
                                                        (function appendAllChildren(workInProgress) {
                                                        })(workInProgress);
                                                    }
                                                    /** finalizeInitialChildren */
                                                    {
                                                        const {parentInstance, nativeTags} = workInProgress;
                                                        UIManager.setChildren(
                                                            parentInstance._nativeTag, // containerTag
                                                            nativeTags // reactTags
                                                        );
                                                    }
                                                }
                                            }
                                                break;
                                            case HostText: {
                                                // 是否已实例化
                                                const hasInstance = current &amp;&amp; workInProgress.stateNode != null;
                                                const {oldText, newText} = [oldProps, newProps];
                                                if (hasInstance) {
                                                    /** updateHostText$1 */
                                                    {
                                                        if (oldText !== newText) {
                                                            /** createTextInstance */
                                                            {
                                                                const tag = (function allocateTag() {
                                                                })();

                                                                UIManager.createView(
                                                                    tag, // reactTag
                                                                    &quot;RCTRawText&quot;, // viewName
                                                                    rootContainerInstance, // rootTag
                                                                    {text: newText} // props
                                                                );
                                                                workInProgress.stateNode = tag;
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    /** createTextInstance */
                                                    {
                                                        const tag = (function allocateTag() {
                                                        })();

                                                        UIManager.createView(
                                                            tag, // reactTag
                                                            &quot;RCTRawText&quot;, // viewName
                                                            rootContainerInstance, // rootTag
                                                            {text: newText} // props
                                                        );
                                                        workInProgress.stateNode = tag;
                                                    }
                                                }
                                            }
                                                break;
                                            default:
                                                /** 忽略 */
                                                break;
                                        }
                                    }
                                    if (nextUnitOfWork !== null) {
                                        return nextUnitOfWork;
                                    }
                                    /** 自底向上归并有效副作用节点，连接成副作用链表 */
                                }
                                nextUnitOfWork = completeUnitOfWork(workInProgress);
                            }
                        }
                    }
                }
            }
        }
        const {finishedWork} = root;
        const {firstEffect} = finishedWork;
        if (finishedWork !== null) {
            /** completeRoot */
            {
                const instance = finishedWork.stateNode;
                /** commitRoot */
                {
                    nextEffect = firstEffect;
                    while(nextEffect) {
                        /** commitBeforeMutationLifeCycles */
                        {
                            switch (finishedWork.tag) {
                                case ClassComponent:
                                    {
                                        if (finishedWork.effectTag &amp; Snapshot) {
                                            // 调用新生命周期getSnapshotBeforeUpdate
                                            instance.getSnapshotBeforeUpdate(oldProps, oldState);
                                        }
                                    }
                                    break;
                                default:
                                    // 忽略
                                    break;
                            }
                        }
                        nextEffect = nextEffect.nextEffect;
                    }

                    nextEffect = firstEffect;
                    while(nextEffect) {
                        /** commitAllHostEffects */
                        {
                            var {effectTag} = nextEffect;
                            var primaryEffectTag = effectTag &amp; (Placement | Update | Deletion);
                            switch (primaryEffectTag) {
                                case Placement:
                                    {
                                        /** commitPlacement */
                                        {
                                            const {containerID, moveFromIndices, moveToIndices, addChildReactTags, addAtIndices, removeAtIndices} = finishedWork;
                                            UIManager.manageChildren(containerID, moveFromIndices, moveToIndices,addChildReactTags,addAtIndices,removeAtIndices);
                                        }
                                    }
                                    break;
                                case PlacementAndUpdate:
                                    {
                                        /** commitPlacement */
                                        {
                                            const {containerID, moveFromIndices, moveToIndices, addChildReactTags, addAtIndices, removeAtIndices} = finishedWork;
                                            UIManager.manageChildren(containerID, moveFromIndices, moveToIndices,addChildReactTags,addAtIndices,removeAtIndices);
                                        }
                                        /** commitWork */
                                        {
                                            switch (finishedWork.tag) {
                                                case HostComponent:
                                                    {
                                                        /** commitUpdate */
                                                        const {reactTag, viewName, props} = finishedWork;
                                                        UIManager.updateView(reactTag, viewName, props);
                                                    }
                                                    break;
                                                case HostText:
                                                    {
                                                        /** commitTextUpdate */
                                                        const {reactTag, props} = finishedWork;
                                                        UIManager.updateView(reactTag, &quot;RCTRawText&quot;, props);
                                                    }
                                                    break;
                                                default:
                                                    // 忽略
                                                    break;
                                            }
                                        }
                                    }
                                    break;
                                case Update:
                                    {
                                        /** commitWork */
                                        {
                                            switch (finishedWork.tag) {
                                                case HostComponent:
                                                    {
                                                        /** commitUpdate */
                                                        const {reactTag, viewName, props} = finishedWork;
                                                        UIManager.updateView(reactTag, viewName, props);
                                                    }
                                                    break;
                                                case HostText:
                                                    {
                                                        /** commitTextUpdate */
                                                        const {reactTag, props} = finishedWork;
                                                        UIManager.updateView(reactTag, &quot;RCTRawText&quot;, props);
                                                    }
                                                    break;
                                                default:
                                                    // 忽略
                                                    break;
                                            }
                                        }
                                    }
                                    break;
                                case Deletion:
                                    {
                                        /** commitDeletion */
                                        {
                                            /** commitUnmount */
                                            {
                                                let {node} = root;
                                                while(true) {
                                                    switch (node.tag) {
                                                        case ClassComponent:
                                                            {
                                                                instance.componentWillUnmount();
                                                            }
                                                            break;
                                                        default:
                                                            // 忽略
                                                            break;
                                                    }
                                                    node = node.sibling;
                                                    if (!node.return) {
                                                        break;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    break;
                                default:
                                    // 忽略
                                    break;
                            }
                        }
                        nextEffect = nextEffect.nextEffect;
                    }

                    root.current = finishedWork;

                    nextEffect = firstEffect;
                    while(nextEffect) {
                        /** commitAllLifeCycles */
                        {
                            const current$$1 = nextEffect.alternate;
                            switch (finishedWork.tag) {
                                case ClassComponent:
                                    {
                                        if (current$$1 === null) {
                                            // 调用生命周期componentDidMount
                                            instance.componentDidMount();
                                        } else {
                                            // 调用新生命周期componentDidUpdate
                                            instance.componentDidUpdate(oldProps, oldState);
                                        }
                                    }
                                    break;
                                default:
                                    // 忽略
                                    break;
                            }
                        }
                        nextEffect = nextEffect.nextEffect;
                    }
                }
            }
        }
    }
}</code></pre></div>

<h4 id="toc_24">方法调用图</h4>

<p><a href="./React%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.png"><img src="https://shengshuqiang.github.io/assets/React%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.png" alt=""></a></p>

<h1 id="toc_25">拿结果</h1>

<h2 id="toc_26">QA</h2>

<p><strong>问：</strong>明明只写了几个组件，通过react-devtools看到的是一堆布局，而且还有Context.Consumer，这些都是干啥的？</p>

<p><strong>答：</strong>查看View.js源码，发现里面会再次render出Context.Consumer。<br><img src="https://shengshuqiang.github.io/assets/view_render.png" alt=""><br><img src="https://shengshuqiang.github.io/assets/text_render.png" alt=""><br>我们写的组件其实外面会被包裹一层，比方显示yellowbox提示啥的。<br><img src="https://shengshuqiang.github.io/assets/renderApplication.png" alt=""></p>

<p><strong>问：</strong>React的组件和Native看起来好像不是一一对应的，这个映射策略是什么？</p>

<p><strong>答：</strong>只有HostComponent和HostText会映射到Native View，其他类型不会，只是用于运算和记录状态。Fiber中的tag表示类型，创建NativeView时（createInstance和createTextInstance）的tag是组件唯一标识，从数字3开始累积2生成。<br><img src="https://shengshuqiang.github.io/assets/fiber_tag.png" alt=""><br><img src="https://shengshuqiang.github.io/assets/get_fiber_tag.png" alt=""><br><img src="https://shengshuqiang.github.io/assets/text_fiber_tag.png" alt=""><br><img src="https://shengshuqiang.github.io/assets/allocateTag.png" alt=""></p>

<p><strong>问：</strong>Element、Instance、DOM之间关系？</p>

<p><strong>答：</strong><img src="https://shengshuqiang.github.io/assets/element_instance_dom_relation.png" alt=""><br><img src="https://shengshuqiang.github.io/assets/element_instance_dom.png" alt=""><br><img src="https://shengshuqiang.github.io/assets/element_instance_dom2.png" alt=""></p>

<p><strong>问：</strong>都说React有个Diff算法，这个在代码哪里，怎么比较的，文案变了会设计Diff算法吗？</p>

<p><strong>答：</strong>Diff算法在<a href="https://zh-hans.reactjs.org/docs/reconciliation.html">reconciliation模块</a>里面，对应函数为ChildReconciler。<br><img src="https://shengshuqiang.github.io/assets/reconcileSingleElement.png" alt=""><br>文本节点和数组见reconcileSingleTextNode和reconcileChildrenArray。更多可以参考<a href="https://zhuanlan.zhihu.com/p/20346379">React 源码剖析系列 － 不可思议的 react diff</a>。</p>

<p><strong>问：</strong>浅比较shouldComponentUpdate的正确姿势是啥？</p>

<p><strong>答：</strong>判断组件是否更新时调用，优先调用shouldComponentUpdate方法，无该该方法是判断是否是纯组件，是则浅比较（判断对象props和state前后是否改变，只对比一级属性是否严格相等===）<br><img src="https://shengshuqiang.github.io/assets/shouldComponentUpdate.png" alt=""><br><img src="https://shengshuqiang.github.io/assets/shallowEqual.png" alt=""></p>

<p><strong>问：</strong>React有棵DOM树，树在哪，怎么看，怎么操作对应Native View树？</p>

<p><strong>答：</strong>在我扩展的插件上看。</p>

<p><strong>问：</strong>setState到底干啥了？</p>

<p><strong>答：</strong>触发Fiber双树重新Diff渲染，具体调用可以使用方法调用树追踪。</p>

<p><strong>问：</strong>React高效在哪？</p>

<p><strong>答：</strong>基于优先级的可中断的树遍历算法，且Diff算法复杂度O（n）。</p>

<p><strong>问：</strong>React工作流程？</p>

<p><strong>答：</strong>文章中有。</p>

<p><strong>问：</strong>如何关联Native自定义组件？</p>

<p><strong>答：</strong>这是个好问题，留给读者自行解答。</p>

<p><strong>问：</strong>Fiber节点数据结构中各属性含义？</p>

<p><strong>答：</strong></p>

<ol>
<li>return, child, sibling：<br><img src="https://pic2.zhTODOimg.com/80/v2-453e1f48a4f53356bee021c90ee00bed_hd.jpg" alt=""></li>
<li>key: 复用标识。</li>
<li>tag：它在协调算法中用于确定需要完成的工作。如前所述，工作取决于React元素的类型。</li>
<li>stateNode：保存组件的类实例、DOM 节点或与 Fiber 节点关联的其他 React 元素类型的引用。总的来说，我们可以认为该属性用于保持与一个 Fiber 节点相关联的局部状态。

<ol>
<li>HostRoot对应{containerInfo}。</li>
<li>ClassComponent对应为new的函数对象实例。</li>
<li>HostComponent对应为ReactNativeFiberHostComponent，包含<em>children和</em>nativeTag。</li>
<li>HostText对应为nativeTag。</li>
</ol></li>
<li>elementType/type: 描述了它对应的组件。对于复合组件，类型是函数或类组件本身。对于宿主组件（div，span等），类型是字符串。定义此 Fiber 节点的函数或类。对于类组件，它指向构造函数，对于 DOM 元素，它指定 HTML 标记。我经常使用这个字段来理解 Fiber 节点与哪个元素相关。

<ol>
<li>ClassComponent对应为函数，如APPContainer()。</li>
<li>ForwardRef、ContextConsumer、ContextProvider对应为对象，如{$$typeof: Symbol(react.forward_ref), render: ƒ, displayName: &quot;View&quot;}。</li>
<li>HostComponent对应为字符串，如“RCTView”。</li>
<li>HostText对应为null。</li>
</ol></li>
<li>memoizedProps：在前一个渲染中用于创建输出的 Fiber 的 props。</li>
<li>memoizedState：用于创建输出的 Fiber 状态。处理更新时，它会反映当前在屏幕上呈现的状态。</li>
<li>pendingProps：props是函数的参数。一个 fiber 的pendingProps在执行开始时设置，并在结束时设置memoizedProps。已从 React 元素中的新数据更新并且需要应用于子组件或 DOM 元素的 props。</li>
<li>updateQueue: state更新队列。状态更新、回调和 DOM 更新的队列。</li>
<li>firstEffect 、lastEffect 等玩意是用来保存中断前后 effect 的状态，用户中断后恢复之前的操作。这个意思还是很迷糊的，因为 Fiber 使用了可中断的架构。</li>
<li>effectTag：副作用，增删改操作。</li>
<li>alternate：在调用render或setState后，会克隆出一个镜像fiber，Diff产生出的变化会标记在镜像fiber上。而alternate就是链接当前fiber tree和镜像fiber tree, 用于断点恢复。workInProgress tree上每个节点都有一个effect list，用来存放需要更新的内容。此节点更新完毕会向子节点或邻近节点合并 effect list。</li>
</ol>

<h2 id="toc_27">生命周期调用</h2>

<p><img src="https://shengshuqiang.github.io/assets/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%B0%83%E7%94%A8.png" alt=""></p>

<h2 id="toc_28">高性能实践</h2>

<p>让浏览器休息好，浏览器就能跑得更快</p>

<p>留到下期。</p>

<h2 id="toc_29">问题定位利器</h2>

<p>基于上面插件，同理研发。</p>

<h2 id="toc_30">方法钩子</h2>

<p>我的数据映射关系怎么来的，这个插件是怎么写的，这又可以再写一篇。</p>

<h1 id="toc_31">长歌</h1>

<ol>
<li>永远不要只满足于世界的表象，要敢于探寻未知的可能。--《守望先锋》</li>
<li>天不生我李淳罡，剑道万古长如夜。剑来！--《雪中悍刀行》</li>
<li>在本帅眼里没有圣女，也无所谓蛊王。--《画江湖之不良人》</li>
<li>世间万事，风云变幻，苍黄翻覆，纵使波谲云诡，但制心一处，便无事不办，天定胜人，人定兮胜天！李淳风，霸道如何，天道又如何？我，不在乎。--《画江湖之不良人》</li>
<li>三界唯心，万法唯识。唯心所变，唯识所现。--《佛法》</li>
<li>谋逆？！哈哈哈哈哈！我陆危楼何惧谋逆叛教之说，不过从头再来罢了！--《圣焰暝影》</li>
<li>当其他人盲目追随真理的时候，记住，万物皆虚；当其他人被道德和法律束缚的时候，记住，万事皆允。我们躬耕于黑暗，服侍着光明。--《刺客信条》</li>
<li>天生万物以养人，世人犹怨天不仁。--《七杀碑》</li>
<li>好男儿，别父母，只为苍生不为主。-- 《红巾军军歌》</li>
</ol>

<h1 id="toc_32">结语</h1>

<p>感谢岳母大人和媳妇大人的默默付出，感谢士兴大佬、朝旭大神、车昊大哥、张杰大哥、思文大拿、陈卓大牛的技术支持和迷津指点。</p>

<p>曾经在知乎看到一个问题，“<a href="https://www.zhihu.com/question/269731127">能魔改react-native源码的是什么水平的前端？</a>”我挑战了这个水平。</p>

<p>Airbnb摇了摇头，说“ RN太难了”，然后倒下了。但是我们，必须，站到台前，领导大家～</p>

<p>谨以此文，献给(那些)曾经热爱互联网技术，并和并肩作战的伙伴们一同度过时光的人们，呈现这重逢的此刻。</p>

<h1 id="toc_33">参考</h1>

<ol>
<li><a href="https://github.com/HuJiaoHJ/blog/issues/7#">React16源码之React Fiber架构</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/37095662">React Fiber架构</a></li>
<li><a href="https://juejin.im/post/5c052f95e51d4523d51c8300">「译」React Fiber 那些事: 深入解析新的协调算法</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/58863799">浅析React Diff 与 Fiber</a></li>
<li><a href="https://juejin.im/post/5c0c7304f265da613e22106c">200行代码实现简版react</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/20346379">React 源码剖析系列 － 不可思议的 react diff</a></li>
<li><a href="https://juejin.im/post/5abe05ea5188255c61631d6c">React源码分析</a></li>
<li><a href="https://www.cnblogs.com/qingmingsang/articles/9131512.html">[react] React Fiber 初探</a></li>
<li><a href="https://www.jianshu.com/p/b189b2949b33">Virtual DOM 的实现和 React Fiber 简介</a></li>
<li><a href="https://www.zcfy.cc/article/the-one-thing-that-no-one-properly-explains-about-react-why-virtual-dom-hashnode-1211.html">React中一个没人能解释清楚的问题——为什么要使用Virtual DOM</a></li>
<li><a href="https://github.com/livoras/blog/issues/13">深度剖析：如何实现一个 Virtual DOM 算法 #13</a></li>
<li><a href="https://blog.yongyuan.us/articles/2017-04-10-react-fiber/">React Fiber 架构【译】</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/26027085">React Fiber是什么</a></li>
<li><a href="https://blog.csdn.net/P6P7qsW6ua47A2Sb/article/details/82322033">浅谈React16框架 - Fiber</a></li>
<li><a href="https://www.zhihu.com/question/49496872">如何理解 React Fiber 架构？</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/36926155">React 16 架构研究记录（文末有彩蛋）</a></li>
<li><a href="https://blog.csdn.net/WonderGlans/article/details/83479577">对React生命周期的理解</a></li>
<li><a href="https://github.com/facebook/react/tree/master/packages/react-devtools">react-devtools</a></li>
</ol>




</body>

</html>
