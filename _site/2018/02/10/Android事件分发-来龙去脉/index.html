<!-- 添加目录 http://blog.csdn.net/hengwei_vc/article/details/47122103 -->

<script src="/javascripts/jquery-2.1.4.min.js" type="text/javascript"></script>

<script src="/javascripts/toc.js" type="text/javascript"></script>

<script type="text/javascript">
$(document).ready(function() {
    $('#toc').toc();
}); </script>

<div id="toc"></div>

<h1 id="situation">情境(Situation)</h1>

<ol>
<li>专注于移动互联网数年，作为高P的我【鼓掌】竟然对事件分发机制见招拆招，似懂非懂。不专业，没法忍。</li>
<li>View树的递归嵌套逻辑让广大一线同行云里雾里，手足无措。</li>
</ol>

<h1 id="complication">冲突(Complication)</h1>

<ol>
<li>网上好多相关主题的博客，描述信息点非常多（但是ACTION_CANCEL描述很少），看完后不明觉厉。</li>
<li>事件分发主要用于解决滑动冲突问题（程序傻傻分不清是横滑还是竖滑），发现同行各种写法都有，雷无处不在【人在家中坐，锅从天上来】。</li>
</ol>

<p><strong>我的机会来了</strong>【大笑】</p>

<h1 id="question">疑问(Question)</h1>

<ol>
<li>有没有体系化剖析套路？</li>
<li>指出常见错误，给出最佳实践？</li>
<li>清晰明了的给出一张图，便于查阅？</li>
<li>“鱼”和“渔”可以兼得？</li>
</ol>

<h1 id="answer">答案(Answer)</h1>

<h2 id="part-6542811a1fd">剖析</h2>

<h3 id="part-65431c264f7">论点</h3>

<h4 id="part-2e093f17d1156991">约法三章</h4>

<ol>
<li>限于个人水平，本文只包含单点触控事件（ACTION_DOWN，ACTION_MOVE，ACTION_UP，ACTION_CANCEL）。</li>
<li>Window类相关的我不会，肤浅的认为和事件分发关系不大（求大牛点拨），直接跳过。</li>
<li>一家之言，姑妄言之，姑妄听之。</li>
</ol>

<h4 id="part-b8a9b07">点</h4>

<ol>
<li><a href="https://developer.android.com/reference/android/view/MotionEvent.html">事件流一致性保证(Consistency Guarantees)</a>：按下开始，中间可能伴随着移动，松开或者取消结束。ACTION_DOWN -&gt; ACTION_MOVE(*) -&gt; ACTION_UP/ACTION_CANCEL。（Motion events are always delivered to views as a consistent stream of events.What constitutes a consistent stream varies depending on the type of device. For touch events, consistency implies that pointers go down one at a time,move around as a group and then go up one at a time or are canceled.）</li>
<li>View类的dispatchTouchEvent方法完成事件的消费处理，ViewGroup的dispatchTouchEvent方法完成事件的分发处理。正常情况下不建议重写该方法改变系统事件分发机制。</li>
<li>ViewGroup类的onInterceptTouchEvent方法完成事件的拦截处理。事件分发路径上的ViewGroup，在ACTION_DOWN或者不是自己直接消费事件时一定会调用onInterceptTouchEvent方法。</li>
<li>View类的onTouchEvent方法完成具体处理事件消费，即触发点击监听（OnClickListener）和长时间点击监听(OnLongClickListener)以及按键状态、焦点相关处理。

<ol>
<li>如果设置了OnTouchListener，会先调用OnTouchListener，如果该监听onTouch返回true，则不会调用onTouchEvent，直接返回已消费；</li>
<li>如果设置了TouchDelegate ，onTouchEvent中会先调用TouchDelegate，如果该类onTouchEvent返回true，则直接返回已消费；</li>
<li>如果View 可点击，执行onTouchEvent中事件处理，并返回true；

<ol>
<li>ACTION_DOWN：置按键标志位为按下状态，并触发延时（500ms）执行长按点击事件。</li>
<li>ACTION_MOVE：如果按键坐标超出该控件区域，则置按键标志位为非按下状态，并且移除ACTION_DOWN触发的延时执行长按点击事件。</li>
<li>ACTION_UP：如果按键标志位为按下状态，并且ACTION_DOWN触发的长按点击事件还未执行，则移除长按点击事件，执行点击事件。</li>
<li>ACTION_CANCEL：置按键标志位为非按下状态，移除ACTION_DOWN触发的延时执行长按点击事件。</li>
</ol></li>
<li>否则不可点击，返回false；</li>
</ol></li>
</ol>

<h3 id="part-65431c26216">论据</h3>

<p>基于<strong>Android 8.0 （API Level 28）</strong>源码解析</p>

<h4 id="part-2bf1db217582440b">人机交互</h4>

<p><img src="http://localhost:4000/assets/%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="人机交互流程图"></p>

<p><img src="http://localhost:4000/assets/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91Java%E6%A0%88.png" alt="事件分发Java栈"></p>

<p><strong>赏析</strong></p>

<ol>
<li>用户的按键行为-&gt;手机传感器-&gt;ViewRootImpl-&gt;DecorView-&gt;WindowCallbackWrapper-&gt;Activity-&gt;PhoneWindow-&gt;DecorView-&gt;ViewGroup*-&gt;View-&gt;程序员的代码逻辑-&gt;硬件（显示器、扬声器等）响应输出-&gt;用户感知</li>
</ol>

<h4 id="view">View树</h4>

<p><img src="http://localhost:4000/assets/AndroidView%E6%A0%91%E5%B8%83%E5%B1%80%E7%BB%93%E6%9E%84.png" alt="AndroidView树布局结构"></p>

<p><strong>赏析</strong></p>

<ol>
<li>View是由树形结构组织，节点为ViewGroup或者View。ViewGroup可以包含多个子节点，View没有子节点。</li>
<li>Android中View树的根节点为DecorView（父View为FrameLayout，属于ViewGroup）。</li>
<li>Android中用户可自定义的View子树根节点id为“android:id/content”。</li>
</ol>

<h4 id="part-6542fa40cf6">类图</h4>

<p><img src="http://localhost:4000/assets/View%E5%92%8CViewGroup%E7%B1%BB%E5%9B%BE.png" alt="View和ViewGroup类图"></p>

<p><strong>赏析</strong></p>

<ol>
<li>ViewRootImpl是Android层逻辑起始点，用于接收来自系统底层的事件消息。相当于View管理类，本身不是View。（BTW：View绘制流程的三部曲（measure、layout、draw）也由该类触发的。）</li>
<li>DecorView是Android View树的根节点，持有window对象。本身能够直接进行真正事件分发能力（继承了父类ViewGroup和View的事件分发处理功能），但是事件分发会直接调用window，间接传递到Activity的事件分发，后续会由Activity回调DecorView的真正事件分发能力。对应图中的环形依赖。</li>
<li>Activity是Android中的页面，真正的事件分发由该类的dispatchTouchEvent触发。（Easter Eggs：如果你想让用户操作不了你的界面，蒙一层透明的View是不是有点low，直接重写该方法就可以控制。）</li>
<li>ViewGroup负责事件分发和拦截处理。按下事件和后续事件（移动、释放或者取消）处理不相同。

<ol>
<li>按下事件，先判断是否拦截。

<ol>
<li>如果不拦截的话，分发事件寻找目标消费子View（逆序遍历子View，递归调用子View的事件分发，判断是否有子View消费。mFirstTouchTarget存储目标消费子View对象）。

<ol>
<li>如果有子View消费，则目标子View消费事件。</li>
<li>否则自己尝试消费事件。</li>
</ol></li>
<li>否则直接自己尝试消费事件。</li>
</ol></li>
<li>后续事件

<ol>
<li>如果按下事件找到了目标消费子View，则判断是否拦截，否则不拦截。</li>
<li>如果有目标消费子View，则根据是否拦截。

<ol>
<li>如果没有拦截，正常传送后续事件；</li>
<li>如果有拦截，则当前事件转换为取消事件发送给目标消费子View，并且重置目标消费子View为空，接下来的后续事件直接自己尝试消费事件（不管是否消费，后续事件都会接收到&amp;尝试处理事件分发）；</li>
</ol></li>
<li>否则自己尝试消费事件。（不会调用是否拦截，其实拦截或者不拦截，都是自己消费事件。）</li>
</ol></li>
</ol></li>
<li>View负责事件消费事件处理。

<ol>
<li>调用mOnTouchListener的onTouch。

<ol>
<li>如果消费，直接返回true；</li>
<li>否则，继续调用onTouchEvent方法；

<ol>
<li>如果为启用的（enable），返回可点击（clickable）。</li>
<li>否则，调用mTouchDelegate的onTouchEvent。

<ol>
<li>如果消费，直接返回true；</li>
<li>否则，

<ol>
<li></li>
<li></li>
</ol></li>
</ol></li>
</ol></li>
</ol></li>
</ol></li>
</ol>

<h4 id="part-6542d68b860">注释</h4>

<h5 id="decorview">DecorView</h5>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="kp">public</span> <span class="k">class</span> <span class="nc">DecorView</span> <span class="n">extends</span> <span class="no">FrameLayout</span>  <span class="p">{</span>
    <span class="kp">private</span> <span class="no">PhoneWindow</span> <span class="n">mWindow</span><span class="p">;</span>

    <span class="vi">@Override</span>
    <span class="kp">public</span> <span class="n">boolean</span> <span class="n">dispatchTouchEvent</span><span class="p">(</span><span class="no">MotionEvent</span> <span class="n">ev</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">final</span> <span class="no">Window</span><span class="o">.</span><span class="no">Callback</span> <span class="n">cb</span> <span class="o">=</span> <span class="n">mWindow</span><span class="p">.</span><span class="nf">getCallback</span><span class="p">();</span>
        <span class="k">return</span> <span class="n">cb</span> <span class="o">!=</span> <span class="n">null</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">mWindow</span><span class="p">.</span><span class="nf">isDestroyed</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">mFeatureId</span> <span class="o">&lt;</span> <span class="mi">0</span>
                <span class="p">?</span> <span class="n">cb</span><span class="p">.</span><span class="nf">dispatchTouchEvent</span><span class="p">(</span><span class="n">ev</span><span class="p">)</span> <span class="p">:</span> <span class="k">super</span><span class="p">.</span><span class="nf">dispatchTouchEvent</span><span class="p">(</span><span class="n">ev</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kp">public</span> <span class="n">boolean</span> <span class="n">superDispatchTouchEvent</span><span class="p">(</span><span class="no">MotionEvent</span> <span class="n">event</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">super</span><span class="p">.</span><span class="nf">dispatchTouchEvent</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre></div>
<h5 id="windowcallbackwrapper">WindowCallbackWrapper</h5>
<div class="highlight"><pre><code class="language-" data-lang="">public class WindowCallbackWrapper implements Window.Callback   {
    @Override
    public boolean dispatchTouchEvent(MotionEvent event) {
        return mWrapped.dispatchTouchEvent(event);
    }
}

</code></pre></div>
<h5 id="activity">Activity</h5>
<div class="highlight"><pre><code class="language-" data-lang="">public class Activity implements Window.Callback  {
    public boolean dispatchTouchEvent(MotionEvent ev) {
        if (ev.getAction() == MotionEvent.ACTION_DOWN) {
            onUserInteraction();
        }
        if (getWindow().superDispatchTouchEvent(ev)) {
            return true;
        }
        return onTouchEvent(ev);
    }

    public boolean onTouchEvent(MotionEvent event) {
        if (mWindow.shouldCloseOnTouch(this, event)) {
            finish();
            return true;
        }

        return false;
    }
}

</code></pre></div>
<h5 id="phonewindow">PhoneWindow</h5>
<div class="highlight"><pre><code class="language-" data-lang="">public class PhoneWindow extends Window  {
    @Override
    public boolean superDispatchTouchEvent(MotionEvent event) {
        return mDecor.superDispatchTouchEvent(event);
    }
}

</code></pre></div>
<h5 id="viewgroup">ViewGroup</h5>
<div class="highlight"><pre><code class="language-" data-lang="">public abstract class ViewGroup extends View implements ViewParent  {

    @Override
    public boolean dispatchTouchEvent(MotionEvent ev) {
        if (mInputEventConsistencyVerifier != null) {
            mInputEventConsistencyVerifier.onTouchEvent(ev, 1);
        }

        // If the event targets the accessibility focused view and this is it, start
        // normal event dispatch. Maybe a descendant is what will handle the click.
        if (ev.isTargetAccessibilityFocus() &amp;&amp; isAccessibilityFocusedViewOrHost()) {
            ev.setTargetAccessibilityFocus(false);
        }

        boolean handled = false;
        if (onFilterTouchEventForSecurity(ev)) {
            final int action = ev.getAction();
            final int actionMasked = action &amp; MotionEvent.ACTION_MASK;

            // Handle an initial down.
            if (actionMasked == MotionEvent.ACTION_DOWN) {
                // Throw away all previous state when starting a new touch gesture.
                // The framework may have dropped the up or cancel event for the previous gesture
                // due to an app switch, ANR, or some other state change.
                cancelAndClearTouchTargets(ev);
                resetTouchState();
            }

            // Check for interception.
            final boolean intercepted;
            if (actionMasked == MotionEvent.ACTION_DOWN
                    || mFirstTouchTarget != null) {
                final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;
                if (!disallowIntercept) {
                    intercepted = onInterceptTouchEvent(ev);
                    ev.setAction(action); // restore action in case it was changed
                } else {
                    intercepted = false;
                }
            } else {
                // There are no touch targets and this action is not an initial down
                // so this view group continues to intercept touches.
                intercepted = true;
            }

            // If intercepted, start normal event dispatch. Also if there is already
            // a view that is handling the gesture, do normal event dispatch.
            if (intercepted || mFirstTouchTarget != null) {
                ev.setTargetAccessibilityFocus(false);
            }

            // Check for cancelation.
            final boolean canceled = resetCancelNextUpFlag(this)
                    || actionMasked == MotionEvent.ACTION_CANCEL;

            // Update list of touch targets for pointer down, if needed.
            final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0;
            TouchTarget newTouchTarget = null;
            boolean alreadyDispatchedToNewTouchTarget = false;
            if (!canceled &amp;&amp; !intercepted) {

                // If the event is targeting accessiiblity focus we give it to the
                // view that has accessibility focus and if it does not handle it
                // we clear the flag and dispatch the event to all children as usual.
                // We are looking up the accessibility focused host to avoid keeping
                // state since these events are very rare.
                View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus()
                        ? findChildWithAccessibilityFocus() : null;

                if (actionMasked == MotionEvent.ACTION_DOWN
                        || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)
                        || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
                    final int actionIndex = ev.getActionIndex(); // always 0 for down
                    final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex)
                            : TouchTarget.ALL_POINTER_IDS;

                    // Clean up earlier touch targets for this pointer id in case they
                    // have become out of sync.
                    removePointersFromTouchTargets(idBitsToAssign);

                    final int childrenCount = mChildrenCount;
                    if (newTouchTarget == null &amp;&amp; childrenCount != 0) {
                        final float x = ev.getX(actionIndex);
                        final float y = ev.getY(actionIndex);
                        // Find a child that can receive the event.
                        // Scan children from front to back.
                        final ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList();
                        final boolean customOrder = preorderedList == null
                                &amp;&amp; isChildrenDrawingOrderEnabled();
                        final View[] children = mChildren;
                        for (int i = childrenCount - 1; i &gt;= 0; i--) {
                            final int childIndex = getAndVerifyPreorderedIndex(
                                    childrenCount, i, customOrder);
                            final View child = getAndVerifyPreorderedView(
                                    preorderedList, children, childIndex);

                            // If there is a view that has accessibility focus we want it
                            // to get the event first and if not handled we will perform a
                            // normal dispatch. We may do a double iteration but this is
                            // safer given the timeframe.
                            if (childWithAccessibilityFocus != null) {
                                if (childWithAccessibilityFocus != child) {
                                    continue;
                                }
                                childWithAccessibilityFocus = null;
                                i = childrenCount - 1;
                            }

                            if (!canViewReceivePointerEvents(child)
                                    || !isTransformedTouchPointInView(x, y, child, null)) {
                                ev.setTargetAccessibilityFocus(false);
                                continue;
                            }

                            newTouchTarget = getTouchTarget(child);
                            if (newTouchTarget != null) {
                                // Child is already receiving touch within its bounds.
                                // Give it the new pointer in addition to the ones it is handling.
                                newTouchTarget.pointerIdBits |= idBitsToAssign;
                                break;
                            }

                            resetCancelNextUpFlag(child);
                            if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
                                // Child wants to receive touch within its bounds.
                                mLastTouchDownTime = ev.getDownTime();
                                if (preorderedList != null) {
                                    // childIndex points into presorted list, find original index
                                    for (int j = 0; j &lt; childrenCount; j++) {
                                        if (children[childIndex] == mChildren[j]) {
                                            mLastTouchDownIndex = j;
                                            break;
                                        }
                                    }
                                } else {
                                    mLastTouchDownIndex = childIndex;
                                }
                                mLastTouchDownX = ev.getX();
                                mLastTouchDownY = ev.getY();
                                newTouchTarget = addTouchTarget(child, idBitsToAssign);
                                alreadyDispatchedToNewTouchTarget = true;
                                break;
                            }

                            // The accessibility focus didn't handle the event, so clear
                            // the flag and do a normal dispatch to all children.
                            ev.setTargetAccessibilityFocus(false);
                        }
                        if (preorderedList != null) preorderedList.clear();
                    }

                    if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) {
                        // Did not find a child to receive the event.
                        // Assign the pointer to the least recently added target.
                        newTouchTarget = mFirstTouchTarget;
                        while (newTouchTarget.next != null) {
                            newTouchTarget = newTouchTarget.next;
                        }
                        newTouchTarget.pointerIdBits |= idBitsToAssign;
                    }
                }
            }

            // Dispatch to touch targets.
            if (mFirstTouchTarget == null) {
                // No touch targets so treat this as an ordinary view.
                handled = dispatchTransformedTouchEvent(ev, canceled, null,
                        TouchTarget.ALL_POINTER_IDS);
            } else {
                // Dispatch to touch targets, excluding the new touch target if we already
                // dispatched to it.  Cancel touch targets if necessary.
                TouchTarget predecessor = null;
                TouchTarget target = mFirstTouchTarget;
                while (target != null) {
                    final TouchTarget next = target.next;
                    if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) {
                        handled = true;
                    } else {
                        final boolean cancelChild = resetCancelNextUpFlag(target.child)
                                || intercepted;
                        if (dispatchTransformedTouchEvent(ev, cancelChild,
                                target.child, target.pointerIdBits)) {
                            handled = true;
                        }
                        if (cancelChild) {
                            if (predecessor == null) {
                                mFirstTouchTarget = next;
                            } else {
                                predecessor.next = next;
                            }
                            target.recycle();
                            target = next;
                            continue;
                        }
                    }
                    predecessor = target;
                    target = next;
                }
            }

            // Update list of touch targets for pointer up or cancel, if needed.
            if (canceled
                    || actionMasked == MotionEvent.ACTION_UP
                    || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
                resetTouchState();
            } else if (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) {
                final int actionIndex = ev.getActionIndex();
                final int idBitsToRemove = 1 &lt;&lt; ev.getPointerId(actionIndex);
                removePointersFromTouchTargets(idBitsToRemove);
            }
        }

        if (!handled &amp;&amp; mInputEventConsistencyVerifier != null) {
            mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1);
        }
        return handled;
    }

    public boolean onInterceptTouchEvent(MotionEvent ev) {
        if (ev.isFromSource(InputDevice.SOURCE_MOUSE)
                &amp;&amp; ev.getAction() == MotionEvent.ACTION_DOWN
                &amp;&amp; ev.isButtonPressed(MotionEvent.BUTTON_PRIMARY)
                &amp;&amp; isOnScrollbarThumb(ev.getX(), ev.getY())) {
            return true;
        }
        return false;
    }

        private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel,
            View child, int desiredPointerIdBits) {
        final boolean handled;

        // Canceling motions is a special case.  We don't need to perform any transformations
        // or filtering.  The important part is the action, not the contents.
        final int oldAction = event.getAction();
        if (cancel || oldAction == MotionEvent.ACTION_CANCEL) {
            event.setAction(MotionEvent.ACTION_CANCEL);
            if (child == null) {
                handled = super.dispatchTouchEvent(event);
            } else {
                handled = child.dispatchTouchEvent(event);
            }
            event.setAction(oldAction);
            return handled;
        }

        // Calculate the number of pointers to deliver.
        final int oldPointerIdBits = event.getPointerIdBits();
        final int newPointerIdBits = oldPointerIdBits &amp; desiredPointerIdBits;

        // If for some reason we ended up in an inconsistent state where it looks like we
        // might produce a motion event with no pointers in it, then drop the event.
        if (newPointerIdBits == 0) {
            return false;
        }

        // If the number of pointers is the same and we don't need to perform any fancy
        // irreversible transformations, then we can reuse the motion event for this
        // dispatch as long as we are careful to revert any changes we make.
        // Otherwise we need to make a copy.
        final MotionEvent transformedEvent;
        if (newPointerIdBits == oldPointerIdBits) {
            if (child == null || child.hasIdentityMatrix()) {
                if (child == null) {
                    handled = super.dispatchTouchEvent(event);
                } else {
                    final float offsetX = mScrollX - child.mLeft;
                    final float offsetY = mScrollY - child.mTop;
                    event.offsetLocation(offsetX, offsetY);

                    handled = child.dispatchTouchEvent(event);

                    event.offsetLocation(-offsetX, -offsetY);
                }
                return handled;
            }
            transformedEvent = MotionEvent.obtain(event);
        } else {
            transformedEvent = event.split(newPointerIdBits);
        }

        // Perform any necessary transformations and dispatch.
        if (child == null) {
            handled = super.dispatchTouchEvent(transformedEvent);
        } else {
            final float offsetX = mScrollX - child.mLeft;
            final float offsetY = mScrollY - child.mTop;
            transformedEvent.offsetLocation(offsetX, offsetY);
            if (! child.hasIdentityMatrix()) {
                transformedEvent.transform(child.getInverseMatrix());
            }

            handled = child.dispatchTouchEvent(transformedEvent);
        }

        // Done.
        transformedEvent.recycle();
        return handled;
    }
}

</code></pre></div>
<p><img src="http://localhost:4000/assets/%E4%BA%8B%E4%BB%B6DispatchTouchEvent%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="事件DispatchTouchEvent流程图"></p>

<h5 id="view">View</h5>
<div class="highlight"><pre><code class="language-" data-lang="">public class View  {
    public final boolean dispatchPointerEvent(MotionEvent event) {
        if (event.isTouchEvent()) {
            return dispatchTouchEvent(event);
        } else {
            return dispatchGenericMotionEvent(event);
        }
    }

    public boolean dispatchTouchEvent(MotionEvent event) {
        // If the event should be handled by accessibility focus first.
        if (event.isTargetAccessibilityFocus()) {
            // We don't have focus or no virtual descendant has it, do not handle the event.
            if (!isAccessibilityFocusedViewOrHost()) {
                return false;
            }
            // We have focus and got the event, then use normal event dispatch.
            event.setTargetAccessibilityFocus(false);
        }

        boolean result = false;

        if (mInputEventConsistencyVerifier != null) {
            mInputEventConsistencyVerifier.onTouchEvent(event, 0);
        }

        final int actionMasked = event.getActionMasked();
        if (actionMasked == MotionEvent.ACTION_DOWN) {
            // Defensive cleanup for new gesture
            stopNestedScroll();
        }

        if (onFilterTouchEventForSecurity(event)) {
            if ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) {
                result = true;
            }
            //noinspection SimplifiableIfStatement
            ListenerInfo li = mListenerInfo;
            if (li != null &amp;&amp; li.mOnTouchListener != null
                    &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED
                    &amp;&amp; li.mOnTouchListener.onTouch(this, event)) {
                result = true;
            }

            if (!result &amp;&amp; onTouchEvent(event)) {
                result = true;
            }
        }

        if (!result &amp;&amp; mInputEventConsistencyVerifier != null) {
            mInputEventConsistencyVerifier.onUnhandledEvent(event, 0);
        }

        // Clean up after nested scrolls if this is the end of a gesture;
        // also cancel it if we tried an ACTION_DOWN but we didn't want the rest
        // of the gesture.
        if (actionMasked == MotionEvent.ACTION_UP ||
                actionMasked == MotionEvent.ACTION_CANCEL ||
                (actionMasked == MotionEvent.ACTION_DOWN &amp;&amp; !result)) {
            stopNestedScroll();
        }

        return result;
    }

    public boolean onTouchEvent(MotionEvent event) {
        final float x = event.getX();
        final float y = event.getY();
        final int viewFlags = mViewFlags;
        final int action = event.getAction();

        final boolean clickable = ((viewFlags &amp; CLICKABLE) == CLICKABLE
                || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)
                || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE;

        if ((viewFlags &amp; ENABLED_MASK) == DISABLED) {
            if (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0) {
                setPressed(false);
            }
            mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;
            // A disabled view that is clickable still consumes the touch
            // events, it just doesn't respond to them.
            return clickable;
        }
        if (mTouchDelegate != null) {
            if (mTouchDelegate.onTouchEvent(event)) {
                return true;
            }
        }

        if (clickable || (viewFlags &amp; TOOLTIP) == TOOLTIP) {
            switch (action) {
                case MotionEvent.ACTION_UP:
                    mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;
                    if ((viewFlags &amp; TOOLTIP) == TOOLTIP) {
                        handleTooltipUp();
                    }
                    if (!clickable) {
                        removeTapCallback();
                        removeLongPressCallback();
                        mInContextButtonPress = false;
                        mHasPerformedLongPress = false;
                        mIgnoreNextUpEvent = false;
                        break;
                    }
                    boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0;
                    if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0 || prepressed) {
                        // take focus if we don't have it already and we should in
                        // touch mode.
                        boolean focusTaken = false;
                        if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) {
                            focusTaken = requestFocus();
                        }

                        if (prepressed) {
                            // The button is being released before we actually
                            // showed it as pressed.  Make it show the pressed
                            // state now (before scheduling the click) to ensure
                            // the user sees it.
                            setPressed(true, x, y);
                        }

                        if (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) {
                            // This is a tap, so remove the longpress check
                            removeLongPressCallback();

                            // Only perform take click actions if we were in the pressed state
                            if (!focusTaken) {
                                // Use a Runnable and post this rather than calling
                                // performClick directly. This lets other visual state
                                // of the view update before click actions start.
                                if (mPerformClick == null) {
                                    mPerformClick = new PerformClick();
                                }
                                if (!post(mPerformClick)) {
                                    performClick();
                                }
                            }
                        }

                        if (mUnsetPressedState == null) {
                            mUnsetPressedState = new UnsetPressedState();
                        }

                        if (prepressed) {
                            postDelayed(mUnsetPressedState,
                                    ViewConfiguration.getPressedStateDuration());
                        } else if (!post(mUnsetPressedState)) {
                            // If the post failed, unpress right now
                            mUnsetPressedState.run();
                        }

                        removeTapCallback();
                    }
                    mIgnoreNextUpEvent = false;
                    break;

                case MotionEvent.ACTION_DOWN:
                    if (event.getSource() == InputDevice.SOURCE_TOUCHSCREEN) {
                        mPrivateFlags3 |= PFLAG3_FINGER_DOWN;
                    }
                    mHasPerformedLongPress = false;

                    if (!clickable) {
                        checkForLongClick(0, x, y);
                        break;
                    }

                    if (performButtonActionOnTouchDown(event)) {
                        break;
                    }

                    // Walk up the hierarchy to determine if we're inside a scrolling container.
                    boolean isInScrollingContainer = isInScrollingContainer();

                    // For views inside a scrolling container, delay the pressed feedback for
                    // a short period in case this is a scroll.
                    if (isInScrollingContainer) {
                        mPrivateFlags |= PFLAG_PREPRESSED;
                        if (mPendingCheckForTap == null) {
                            mPendingCheckForTap = new CheckForTap();
                        }
                        mPendingCheckForTap.x = event.getX();
                        mPendingCheckForTap.y = event.getY();
                        postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());
                    } else {
                        // Not inside a scrolling container, so show the feedback right away
                        setPressed(true, x, y);
                        checkForLongClick(0, x, y);
                    }
                    break;

                case MotionEvent.ACTION_CANCEL:
                    if (clickable) {
                        setPressed(false);
                    }
                    removeTapCallback();
                    removeLongPressCallback();
                    mInContextButtonPress = false;
                    mHasPerformedLongPress = false;
                    mIgnoreNextUpEvent = false;
                    mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;
                    break;

                case MotionEvent.ACTION_MOVE:
                    if (clickable) {
                        drawableHotspotChanged(x, y);
                    }

                    // Be lenient about moving outside of buttons
                    if (!pointInView(x, y, mTouchSlop)) {
                        // Outside button
                        // Remove any future long press/tap checks
                        removeTapCallback();
                        removeLongPressCallback();
                        if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0) {
                            setPressed(false);
                        }
                        mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;
                    }
                    break;
            }

            return true;
        }

        return false;
    }
}

</code></pre></div>
<p><img src="http://localhost:4000/assets/%E4%BA%8B%E4%BB%B6OnTouchEvent%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="事件OnTouchEvent流程图"></p>

<h4 id="part-3786c68461ca49f">事件流</h4>

<p>使用<a href="https://www.jianshu.com/p/d968645067d7"><strong>MECE</strong></a>（Mutually Exclusive Collectively Exhaustive，相互独立，完全穷尽）法则</p>

<p><img src="http://localhost:4000/assets/%E4%BA%8B%E4%BB%B6%E6%B5%81MEMC%E5%9B%BE.png" alt="事件流MEMC图"></p>

<p><strong>Demo</strong>（<a href="https://github.com/shengshuqiang/viewdispatchtouchevent">git仓库</a>）ParentInterceptTouchEventActivity页面
<img src="http://localhost:4000/assets/ParentInterceptTouchEventActivity.png" alt="ParentInterceptTouchEventActivity"></p>

<p>1.父控件ACTION_DOWN拦截<br>
2.父控件消费事件<br><img src="http://localhost:4000/assets/%E8%A7%92%E8%89%B2%E4%BA%8B%E4%BB%B6%E6%B6%88%E8%B4%B9%E7%8A%B6%E6%80%81-1.png" alt="角色事件消费状态-1">
<blockquote>
1. 接收按下事件 -DOWN-&gt; Parent.dispatchTouchEvent -DOWN-&gt; Parent.onInterceptTouchEvent -true-&gt; Parent.dispatchTouchEvent -DOWN-&gt; Parent.(super)dispatchTouchEvent{Parent处理消费} -DOWN-&gt;  Parent.onTouchEvent -true-&gt; Parent.dispatchTouchEvent-true-&gt; 返回消费状态true<br><img src="http://localhost:4000/assets/%E4%BA%8B%E4%BB%B6%E6%B5%81-1.png" alt="事件流-1"><br>
2. 接收移动事件 -MOVE-&gt; Parent.dispatchTouchEvent -MOVE-&gt; Parent.(super)dispatchTouchEvent{Parent处理消费} -MOVE-&gt; Parent.onTouchEvent -消费状态-&gt; Parent.dispatchTouchEvent -true-&gt; 返回消费状态true<br><img src="http://localhost:4000/assets/%E4%BA%8B%E4%BB%B6%E6%B5%81-2.png" alt="事件流-2"><br>
3. 接收释放事件 -UP-&gt; Parent.dispatchTouchEvent -UP-&gt; Parent.(super)dispatchTouchEvent{Parent处理消费} -UP-&gt; Parent.onTouchEvent -true-&gt; Parent.dispatchTouchEvent -true-&gt; 返回消费状态true<img src="http://localhost:4000/assets/%E4%BA%8B%E4%BB%B6%E6%B5%81-3.png" alt="事件流-3"><br>
</blockquote>
1.父控件ACTION_DOWN拦截<br>
2.父控件不消费事件<br><img src="http://localhost:4000/assets/%E8%A7%92%E8%89%B2%E4%BA%8B%E4%BB%B6%E6%B6%88%E8%B4%B9%E7%8A%B6%E6%80%81-2.png" alt="角色事件消费状态-2">
<blockquote>
4. 接收按下事件 -DOWN-&gt; Parent.dispatchTouchEvent -DOWN-&gt; Parent.onInterceptTouchEvent -true-&gt; Parent.dispatchTouchEvent -DOWN-&gt; Parent.(super)dispatchTouchEvent{Parent处理消费} -DOWN-&gt;  Parent.onTouchEvent -false-&gt; Parent.dispatchTouchEvent-false-&gt; 返回消费状态false<br><img src="http://localhost:4000/assets/%E4%BA%8B%E4%BB%B6%E6%B5%81-4.png" alt="事件流-4"><br>
5. 接收不到移动事件<br>
6. 同5
</blockquote>
1.父控件ACTION_MOVE拦截<br>
2.子控件消费事件<br><img src="http://localhost:4000/assets/%E8%A7%92%E8%89%B2%E4%BA%8B%E4%BB%B6%E6%B6%88%E8%B4%B9%E7%8A%B6%E6%80%81-3.png" alt="角色事件消费状态-3">
<blockquote>
7. 接收按下事件 -DOWN-&gt; Parent.dispatchTouchEvent -DOWN-&gt; Parent.onInterceptTouchEvent  -false-&gt; Parent.dispatchTouchEvent -DOWN-&gt; Child.dispatchTouchEvent{Parent分发，遍历调用Child分发消息，Child内部递归分发消息} -DOWN-&gt; TargetChild（目标子控件，区别Child，子控件消费事件，要么是自己消费了，要么是自己的后代或者后代的后代消费了）.onTouchEvent{存在调用多个Child该方法，前提是前面的Child均返回false} -true-&gt; Child.dispatchTouchEvent -true-&gt; Parent.dispatchTouchEvent{记录目标消费Child为该View}-true-&gt; 返回消费状态true<br><img src="http://localhost:4000/assets/%E4%BA%8B%E4%BB%B6%E6%B5%81-7.png" alt="事件流-7"><br>
8. 接收移动事件 -MOVE-&gt; Parent.dispatchTouchEvent -MOVE-&gt; Parent.onInterceptTouchEvent  -true-&gt; Parent.dispatchTouchEvent -CANCEL-&gt; Child（目标消费Child）.dispatchTouchEvent{Child处理消费} -CANCEL-&gt;Child.onTouchEvent -消费状态-&gt; Child.dispatchTouchEvent-消费状态-&gt; 返回消费状态<br><img src="http://localhost:4000/assets/%E4%BA%8B%E4%BB%B6%E6%B5%81-8.png" alt="事件流-8"><br>
9. 接收释放事件 -UP-&gt; Parent.dispatchTouchEvent -UP-&gt; Parent.(super)dispatchTouchEvent{Parent处理消费} -UP-&gt; Parent.onTouchEvent -消费状态-&gt; Parent.dispatchTouchEvent -消费状态-&gt; 返回消费状态<br><img src="http://localhost:4000/assets/%E4%BA%8B%E4%BB%B6%E6%B5%81-9.png" alt="事件流-9">
</blockquote>
1.父控件ACTION_MOVE拦截<br>
2.子控件不消费事件<br>
3.父控件消费事件<br><img src="http://localhost:4000/assets/%E8%A7%92%E8%89%B2%E4%BA%8B%E4%BB%B6%E6%B6%88%E8%B4%B9%E7%8A%B6%E6%80%81-4.png" alt="角色事件消费状态-4">
<blockquote>
10. 接收按下事件 -DOWN-&gt; Parent.dispatchTouchEvent -DOWN-&gt; Parent.onInterceptTouchEvent  -false-&gt; Parent.dispatchTouchEvent -DOWN-&gt; Child.dispatchTouchEvent{Parent分发，遍历调用Child分发消息，Child内部递归分发消息} -DOWN-&gt; TargetChild（目标子控件，区别Child，子控件处理消费事件）.onTouchEvent{满足事件坐标在控件内的子View或者子View的后代均会调用到} -false-&gt; Child.dispatchTouchEvent -false-&gt; Parent.dispatchTouchEvent{没有目标消费Child} -DOWN-&gt; Parent.(super)dispatchTouchEvent{Parent处理消费} -DOWN-&gt;  Parent.onTouchEvent -true-&gt; 返回消费状态true<br><img src="http://localhost:4000/assets/%E4%BA%8B%E4%BB%B6%E6%B5%81-10.png" alt="事件流-10"><br>
11. 同2<br>
12. 同3<br>
</blockquote>
1.父控件ACTION_MOVE拦截<br>
2.子控件不消费事件<br>
3.父控件不消费事件<br><img src="http://localhost:4000/assets/%E8%A7%92%E8%89%B2%E4%BA%8B%E4%BB%B6%E6%B6%88%E8%B4%B9%E7%8A%B6%E6%80%81-5.png" alt="角色事件消费状态-5">
<blockquote>
13. 接收按下事件 -DOWN-&gt; Parent.dispatchTouchEvent -DOWN-&gt; Parent.onInterceptTouchEvent  -false-&gt; Parent.dispatchTouchEvent -DOWN-&gt; Child.dispatchTouchEvent{Parent分发，遍历调用Child分发消息，Child内部递归分发消息} -DOWN-&gt; TargetChild（目标子控件，区别Child，子控件处理消费事件）.onTouchEvent{满足事件坐标在控件内的子View或者子View的后代均会调用到} -false-&gt; Child.dispatchTouchEvent -false-&gt; Parent.dispatchTouchEvent{没有目标消费Child} -DOWN-&gt; Parent.(super)dispatchTouchEvent{Parent处理消费} -DOWN-&gt;  Parent.onTouchEvent -false-&gt; 返回消费状态false<br><img src="http://localhost:4000/assets/%E4%BA%8B%E4%BB%B6%E6%B5%81-13.png" alt="事件流-13"><br>
14. 同5<br>
15. 同5<br>
</blockquote>
1.父控件ACTION_UP拦截<br>
2.子控件消费事件<br><img src="http://localhost:4000/assets/%E8%A7%92%E8%89%B2%E4%BA%8B%E4%BB%B6%E6%B6%88%E8%B4%B9%E7%8A%B6%E6%80%81-6.png" alt="角色事件消费状态-6">
<blockquote>
16. 同7<br>
17. 接收移动事件 -MOVE-&gt; Parent.dispatchTouchEvent -MOVE-&gt; Parent.onInterceptTouchEvent  -false-&gt; Parent.dispatchTouchEvent -MOVE-&gt; Child(目标消费Child).dispatchTouchEvent -MOVE-&gt; Child.onTouchEvent -true-&gt; Child.dispatchTouchEvent -true-&gt; Parent.dispatchTouchEvent -true-&gt; 返回消费状态true<br><img src="http://localhost:4000/assets/%E4%BA%8B%E4%BB%B6%E6%B5%81-17.png" alt="事件流-17"><br>
18. 接收释放事件 -UP-&gt; Parent.dispatchTouchEvent -UP-&gt; Parent.onInterceptTouchEvent -true-&gt; Parent.dispatchTouchEvent -CANCEL-&gt; Child(目标消费Child).dispatchTouchEvent{Child处理消费} -CANCEL-&gt; Child.onTouchEvent -消费状态-&gt; Child.dispatchTouchEvent -true-&gt; Parent.dispatchTouchEvent -true-&gt; 返回消费状态true<br><img src="http://localhost:4000/assets/%E4%BA%8B%E4%BB%B6%E6%B5%81-18.png" alt="事件流-18">
</blockquote>
1.父控件ACTION_UP拦截<br>
2.子控件不消费事件<br>
3.父控件消费事件<br><img src="http://localhost:4000/assets/%E8%A7%92%E8%89%B2%E4%BA%8B%E4%BB%B6%E6%B6%88%E8%B4%B9%E7%8A%B6%E6%80%81-7.png" alt="角色事件消费状态-7">
<blockquote>
19. 同10<br>
20. 同2<br>
21. 同3<br>
</blockquote>
1.父控件ACTION_UP拦截<br>
2.子控件不消费事件<br>
3.父控件不消费事件<br><img src="http://localhost:4000/assets/%E8%A7%92%E8%89%B2%E4%BA%8B%E4%BB%B6%E6%B6%88%E8%B4%B9%E7%8A%B6%E6%80%81-8.png" alt="角色事件消费状态-8">
<blockquote>
22. 同13<br>
23. 同5<br>
24. 同5
</blockquote>
1. 父控件不拦截<br>
2. 子控件消费事件<br><img src="http://localhost:4000/assets/%E8%A7%92%E8%89%B2%E4%BA%8B%E4%BB%B6%E6%B6%88%E8%B4%B9%E7%8A%B6%E6%80%81-9.png" alt="角色事件消费状态-9">
<blockquote>
25. 同7<br>
26. 同17<br>
27. 接收释放事件 -UP-&gt; Parent.dispatchTouchEvent -UP-&gt; Parent.onInterceptTouchEvent  -false-&gt; Parent.dispatchTouchEvent -UP-&gt; Child(目标消费Child).dispatchTouchEvent -UP-&gt; Child.onTouchEvent -true-&gt; Child.dispatchTouchEvent -true-&gt; Parent.dispatchTouchEvent -true-&gt; 返回消费状态true<br><img src="http://localhost:4000/assets/%E4%BA%8B%E4%BB%B6%E6%B5%81-27.png" alt="事件流-27">
</blockquote>
1. 父控件不拦截<br>
2. 子控件不消费事件<br>
3. 父控件消费事件<br><img src="http://localhost:4000/assets/%E8%A7%92%E8%89%B2%E4%BA%8B%E4%BB%B6%E6%B6%88%E8%B4%B9%E7%8A%B6%E6%80%81-10.png" alt="角色事件消费状态-10">
<blockquote>
28. 同10<br>
29. 同2<br>
30. 同3<br>
</blockquote>
1. 父控件不拦截<br>
2. 子控件不消费事件<br>
3. 父控件不消费事件<br><img src="http://localhost:4000/assets/%E8%A7%92%E8%89%B2%E4%BA%8B%E4%BB%B6%E6%B6%88%E8%B4%B9%E7%8A%B6%E6%80%81-11.png" alt="角色事件消费状态-11">
<blockquote>
31. 同13<br>
32. 同5<br>
33. 同5<br>
</blockquote>
</blockquote></p>

<p><strong>启示</strong></p>

<ol>
<li>ACTION_DOWN执行事件分发查找（遍历子View，递归分发查找，如果子View未消费，则回退到自己消费，依次向上回溯，找到目标消费View为止）找到目标消费子View。后续事件不再需要查找，直接发送给目标消费子View，如果没有，则自己消费。<br><img src="http://localhost:4000/assets/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E8%B7%AF%E5%BE%84.png" alt="事件分发路径"></li>
<li>事件已消费路径上（终点为目标消费View），如果有父控件拦截事件，则第一次拦截后，会将当前事件转为ACTION_CANCEL传递给目标消费子View，后续事件则直接自己处理消费，不论是否消费，均能收到后续事件流<br> <img src="http://localhost:4000/assets/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%8B%A6%E6%88%AA%E8%B7%AF%E5%BE%84.png" alt="事件分发拦截路径"></li>
</ol>

<h3 id="part-65431c26ecd">论证</h3>

<ol>
<li>从事件流可证明事件一致性保证(Consistency Guarantees)：

<ol>
<li>ViewGroup在ACTION_DOWN的事件分发返回false（不消费事件），则不再会收到后续事件（ACTION_MOVE、ACTION_UP/ACTION_CANCEL）。</li>
<li>ViewGroup在ACTION_DOWN的事件分发返回true（消费事件），则会收到后续事件（ACTION_MOVE、ACTION_UP/ACTION_CANCEL），如果ViewGroup拦截后续事件，则第一次拦截会将事件转为ACTION_CANCEL传递给目标消费子View（终止子View接收后续事件），接下来的后续事件自己消费。</li>
<li> ViewGroup在非ACTION_DOWN的事件分发返回消费状态对整体事件流没有影响。</li>
</ol></li>
<li>从注释可证明View.dispatchTouchEvent方法完成事件的消费处理；ViewGroup.dispatchTouchEvent方法完成事件的分发处理；ViewGroup.onInterceptTouchEvent方法完成事件的拦截处理；事件分发路径上的ViewGroup，在ACTION_DOWN或者不是自己直接消费事件时一定会调用onInterceptTouchEvent方法。以及View类的onTouchEvent方法完成具体处理事件消费。</li>
</ol>

<h2 id="part-3786c5121338800">一张图</h2>

<p><img src="http://localhost:4000/assets/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E4%B8%80%E5%BC%A0%E5%9B%BE.png" alt="事件分发一张图"></p>

<p><strong>赏析</strong></p>

<ol>
<li>ACTION_DOWN会触发查找目标消费View，优先子View尝试消费，如果子View仍然没有消费，则依次回溯到父控件尝试消费（直至DecorView，然后Activity尝试消费），如果找到了，则回溯返回true。</li>
<li>ACTION_DOWN后续事件执行的前提是事件分发路径的终点就是目标消费View，目标消费View的父控件均会调用到事件拦截（让父控件有机会拦截下来，改变事件流），如果目标消费View的父控件拦截，拦截时的事件会转换为ACTION_CANCEL继续按原路径分发，后续的事件则不再分发给目标消费View，而是拦截的父控件自己消费。</li>
<li>非ACTION_DOWN返回的消费状态对事件流没有影响。</li>
</ol>

<h2 id="part-6542bfebd44">标准</h2>

<h3 id="part-2c9a377a88b0c4e6">常见错误</h3>

<ol>
<li>不知道onInterceptTouchEvent和onTouchEvent什么时候会调用，但是知道dispatchTouchEvent每次都会调用，就把逻辑直接写在dispatchTouchEvent的重写方法里面。<br>问题：不满足事件流一致性，存在目标消费View没有接收到ACTION_UP/ACTION_CANCEL就结束了，导致焦点、按键状态或者按键事件不符合预期。</li>
<li>发现onInterceptTouchEvent经常调用到，逻辑写在onInterceptTouchEvent里面。<br>问题：onInterceptTouchEvent在View自己消费情况下或者拦截之后的事件流不再会调用到，会把坑隐藏得更深【不好复现的Bug才是最难解决的Bug】。</li>
<li>鸟枪法，dispatchTouchEvent、onInterceptTouchEvent、onTouchEvent均会调用到逻辑。<br>问题：路子太野。。。</li>
<li>觉得自己很牛X，逻辑分散在dispatchTouchEvent、onInterceptTouchEvent、onTouchEvent里面。<br>问题：可读性差，逻辑混乱。</li>
<li>事件消息只处理了ACTION_DOWN、ACTION_MOVE、ACTION_UP，没有对ACTION_CANCEL或者其他多点触控事件容错处理。<br>问题：总会出现不常见的问题。</li>
</ol>

<h3 id="part-2cac2c45be4b8e80">最佳实践</h3>

<ol>
<li>明确事件流调用顺序以及拦截后的事件流。</li>
<li>dispatchTouchEvent：正常情况下不建议重写dispatchTouchEvent方法改变系统事件分发机制，可以看到，Google就没有几个类重新该方法。最多记下坐标点，但千万调用super. dispatchTouchEvent保证系统事件分发正常调用。</li>
<li>onInterceptTouchEvent：只处理拦截逻辑，在合适事件将事件流导到onTouchEvent。</li>
<li>onTouchEvent：真正处理逻辑。</li>
<li>除常见事件处理外，一定要上剩余事件容错处理。</li>
</ol>

<h2 id="part-b8a9d97">渔</h2>

<h3 id="part-3786d9fced1fe38">方法论</h3>

<ol>
<li> <a href="https://www.jianshu.com/p/d968645067d7">MECE法则和金字塔原理</a></li>
<li> <a href="https://www.zhihu.com/question/27880205">SCQA 架构如何理解？</a></li>
</ol>

<h3 id="part-6542809efe1">利器</h3>

<ol>
<li>AS源码英文翻译，参考<a href="http://blog.csdn.net/luofen521/article/details/74295716">AS翻译插件Translation</a></li>
<li>Android源码调试

<ol>
<li><a href="http://www.genymotion.net/">Android模拟器GenyMotion</a> </li>
<li>GenyMotion创建和App的build.gradle中targetSdkVersion相同API Level模拟器即可Debug对应上源码。进阶参考<a href="http://weishu.me/2016/05/30/how-to-debug-android-framework/">如何调试Android Framework？</a></li>
<li><a href="http://weishu.me/2015/12/21/android-studio-debug-tips-you-may-not-know/">Android Studio你不知道的调试技巧</a></li>
</ol></li>
<li>关键日志输出，使用静态代理，进阶参考<a href="http://weishu.me/2016/01/28/understand-plugin-framework-proxy-hook/">Android插件化原理解析——Hook机制之动态代理</a></li>
<li>绘图工具

<ol>
<li><a href="https://www.processon.com/i/5a633502e4b0332f153dd897">ProcessOn</a></li>
<li><a href="https://www.edrawsoft.com/download-edrawmax-mac.php">edraw</a></li>
</ol></li>
<li>个人主页

<ol>
<li><a href="https://www.jekyll.com.cn/">将纯文本转化为静态网站和博客</a>
12.</li>
</ol></li>
</ol>

<h1 id="part-b8a933b">利</h1>

<ol>
<li>随心所欲控制事件流【大权在手，天下我有】</li>
<li>事件分发不再是个事，怕个球</li>
<li>各种酷炫动画和自定义控件燥起来</li>
<li>再也不用担心面试中尬聊事件分发</li>
<li>借鉴上述不成熟的“渔”去爱干嘛干嘛</li>
</ol>

<h1 id="part-65432e5111e">进阶</h1>

<ol>
<li>滚动控件和按键冲突处理，界面布局滚动</li>
<li>滑动冲突 

<ol>
<li><a href="https://segmentfault.com/a/1190000002873657">NestedScrolling机制</a></li>
<li><a href="http://blog.csdn.net/lmj623565791/article/details/52204039">Android NestedScrolling机制完全解析 带你玩转嵌套滑动</a></li>
<li><a href="https://www.jianshu.com/p/982a83271327">外部拦截法&amp;内部拦截法</a></li>
</ol></li>
<li>手势（GestureDecetor）</li>
</ol>

<h1 id="part-65428734206">参考</h1>

<ol>
<li><a href="https://www.jianshu.com/p/e99b5e8bd67b">图解 Android 事件分发机制</a></li>
<li><a href="http://blog.ingphone.com/android/2013/11/13/Android-%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6.html">Android 响应用户屏幕手势操作</a></li>
<li><a href="https://www.jianshu.com/p/0c863bbde8eb">Android MotionEvent详解</a></li>
<li><a href="https://my.oschina.net/banxi/blog/56421">android触控,先了解MotionEvent(一)</a></li>
<li><a href="http://blog.csdn.net/woshimalingyi/article/details/50383578">Android多点触控之——MotionEvent(触控事件)</a></li>
<li><a href="http://ztelur.github.io/2016/02/04/%E5%9B%BE%E8%A7%A3Android%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E4%B9%8BView%E7%AF%87/">图解Android事件传递之View篇</a></li>
<li><a href="http://ztelur.github.io/2016/02/11/%E5%9B%BE%E8%A7%A3Android%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E4%B9%8BViewGroup%E7%AF%87/">图解Android事件传递之ViewGroup篇</a></li>
</ol>

<h1 id="part-b8a9c24">歌</h1>

<h2 id="part-c7060f19ae93e39c">念奴娇·天丁震怒</h2>

<p>完颜亮(金代)</p>

<ol>
<li>天丁震怒，掀翻银海，散乱珠箔（bó）。</li>
<li>六出奇花飞滚滚，平填了山中丘壑。(六出：雪花六角，因用为雪花的别名。)</li>
<li>皓虎颠狂，素麟猖獗(chāng jué)，掣(chè, 拉)断珍珠索。(皓虎：白色的老虎。素麟：白色的麒麟。)</li>
<li>玉龙酣战，鳞甲满天飘落。</li>
<li><br></li>
<li>谁念万里关山，征夫僵立，缟（gǎo）带沾旗脚。(僵立：因寒冷而冻得僵硬直立。缟带：白色的衣带。)</li>
<li>色映戈矛，光摇剑戟(jǐ )，杀气横戎幕。(戎幕：行军作战时的营帐。)</li>
<li>貔（pí）虎豪雄，偏裨（pí）英勇，共与谈兵略。（裨：pí ，副，偏，小；bì ，增添，补助，如大有～益。）</li>
<li>须拼一醉，看取碧空寥廓(liáo kuò)。</li>
</ol>

<h1 id="copy-right">Copy Right</h1>

<ul>
<li>作者： 盛书强，美团点评酒旅前端高级工程师，“九域之广,岂一人之强化,必伫才能,共成羽翼”，我们期待你的加入，简历发送至shengshuqiang@gmail.com。 </li>
<li>声明： 本文为原创文章，未经许可，请勿转载，如需转载，请留言。</li>
</ul>
