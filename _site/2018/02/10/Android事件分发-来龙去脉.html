<!DOCTYPE html><html lang="zh">
  <head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no"><title>Android事件分发-来龙去脉 - 盛书强</title>
<meta name="description" content="情境(Situation)1. 专注于移动互联网数年，作为高P的我【鼓掌】竟然对事件分发机制见招拆招，似懂非懂。不专业，没法忍。2. View树的递归嵌套逻辑让广大一线同行云里雾里，手足无措。冲突(Complication)1. 网上好多相关主题的博客，描述信息点非常多（但是ACTION_CANCEL描述很少），...">
<link rel="canonical" href="http://localhost:4000/2018/02/10/Android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91-%E6%9D%A5%E9%BE%99%E5%8E%BB%E8%84%89.html"><link rel="alternate" type="application/rss+xml" title="盛书强" href="http://localhost:4000/feed.xml">
<!-- for Safari on iOS https://developer.apple.com/ios/human-interface-guidelines/icons-and-images/app-icon/ --><link rel="apple-touch-icon" sizes="180x180" href="/assets/images/logo/icon-180x180.png"><link rel="apple-touch-icon" sizes="167x167" href="/assets/images/logo/icon-167x167.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/images/logo/icon-152x152.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/images/logo/icon-120x120.png"><link rel="shortcut icon" href="/assets/images/logo/icon-120x120.png">
<!-- for Chrome on Android https://developer.chrome.com/multidevice/android/installtohomescreen -->
<meta name="mobile-web-app-capable" content="yes"><link rel="icon" sizes="192x192" href="/assets/images/logo/icon-192x192.png">
<!-- for Edge on Windows 10 https://msdn.microsoft.com/en-us/library/dn255024(v=vs.85).aspx --><meta name="msapplication-TileImage" content="/assets/images/logo/icon-144x144.png"><meta name="msapplication-square310x310logo" content="/assets/images/logo/icon-310x310.png"><meta name="msapplication-wide310x150logo" content="/assets/images/logo/icon-310x150.png"><meta name="msapplication-square150x150logo" content="/assets/images/logo/icon-150x150.png"><meta name="msapplication-square70x70logo" content="/assets/images/logo/icon-70x70.png">
<meta name="msapplication-TileColor" content="#eeeeee"><link rel="stylesheet" href="/assets/css/blog.css"><script>
  window.isArray = function(val) {
    return Object.prototype.toString.call(val) === '[object Array]';
  };
  window.isString = function(val) {
    return typeof val === 'string';
  };
  window.Lazyload = (function(doc) {
    var queue = {js: [], css: []}, sources = {js: {}, css: {}}, context = this;
    var Set = (function() {
      var add = function(item) {
        var i, data = this._data;
        for (i = 0; i < data.length; i++) {
          if (data[i] === item) {
            return;
          }
        }
        this.size ++;
        data.push(item);
        return data;
      }

      var Set = function(data) {
        this.size = 0;
        this._data = [];
        if (data.length > 0) {
          for (i = 0; i < data.length; i++) {
            add.call(this, data[i]);
          }
        }
      }
      Set.prototype.add = add;
      Set.prototype.get = function(index) { return this._data[index]; };
      Set.prototype.has = function(item) {
        var i, data = this._data;
        for (i = 0; i < data.length; i++) {
          if (this.get(i) === item) {
            return true;
          }
        }
        return false;
      };
      Set.prototype.is = function(map) {
        if (map._data.length !== this._data.length) { return false; }
        var i, j, flag, tData = this._data, mData = map._data;
        for (i = 0; i < tData.length; i++) {
          for (flag = false, j = 0; j < mData.length; j++) {
            if (tData[i] === mData[j]) {
              flag = true;
              break;
            }
          }
          if (!flag) { return false; }
        }
        return true;
      };
      Set.prototype.values = function() {
        return this._data;
      };
      return Set;
    })();

    var createNode = function(name, attrs) {
      var node = doc.createElement(name), attr;
      for (attr in attrs) {
        if (attrs.hasOwnProperty(attr)) {
          node.setAttribute(attr, attrs[attr]);
        }
      }
      return node;
    }
    var end = function(type, url, urls) {
      var s, q, qi, cbs, i, j, cur,
        val, flag;
      if (type === 'js' || type ==='css') {
        s = sources[type], q = queue[type];
        s[url] = true;
        for (i = 0; i < q.length; i++) {
          cur = q[i];
          if (cur.urls.has(url)) {
            qi = cur, val = qi.urls.values();
            qi && (cbs = qi.callbacks);
            for (flag = true, j = 0; j < val.length; j++) {
              cur = val[j]
              if (!s[cur]) {
                flag = false;
              }
            }
            if (flag && cbs && cbs.length > 0) {
              for (j = 0; j < cbs.length; j++) {
                cbs[j].call(context);
              }
              qi.load = true;
            }
          }
        }
      }
    };
    var load = function(type, urls, callback) {
      var s, si, q, qi, node, i, cur, flag,
        _urls = typeof urls === 'string' ? new Set([urls]) : new Set(urls), val, url;
      if (type === 'js' || type ==='css') {
        s = sources[type], q = queue[type];
        for (i = 0; i < q.length; i++) {
          cur = q[i];
          if (_urls.is(cur.urls)) {
            qi = cur;
            break;
          }
        }
        val = _urls.values();
        if (qi) {
          callback && (qi.load || qi.callbacks.push(callback));
          callback && (qi.load && callback());
        } else {
          q.push({
            urls: _urls,
            callbacks: callback ? [callback] : [],
            load: false
          });
          for (i = 0; i < val.length; i++) {
            node = null, url = val[i];
            if (s[url] === undefined) {
              (type === 'js' ) && (node = createNode('script', { src: url }));
              (type === 'css') && (node = createNode('link', { rel: 'stylesheet', href: url }));
              if (node) {
                node.onload = (function(type, url) {
                  return function() {
                    end(type, url);
                  }
                })(type, url);
                (doc.head || doc.body).appendChild(node);
                s[url] = false;
              }
            }
          }
        }
      }
    };
    return {
      js: function(url, callback) {
        load('js', url, callback);
      },
      css: function(url, callback) {
        load('css', url, callback);
      }
    };
  })(this.document);

  window.throttle = function(func, wait) {
    var args, result, thisArg, timeoutId, lastCalled = 0;

    function trailingCall() {
      lastCalled = new Date;
      timeoutId = null;
      result = func.apply(thisArg, args);
    }
    return function() {
      var now = new Date,
        remaining = wait - (now - lastCalled);

      args = arguments;
      thisArg = this;

      if (remaining <= 0) {
        clearTimeout(timeoutId);
        timeoutId = null;
        lastCalled = now;
        result = func.apply(thisArg, args);
      } else if (!timeoutId) {
        timeoutId = setTimeout(trailingCall, remaining);
      }
      return result;
    };
  };

  window.hasEvent = function(event) {
    return 'on'.concat(event) in window.document;
  }
</script></head>
  <body>
    <div class="m-page-stage js-page-stage">
      <div class="m-page-content"><header class="m-page-header">
  <div class="main clearfix">
    <div class='site-logo'><?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="128px" height="128px" viewBox="0 0 128 128" enable-background="new 0 0 128 128" xml:space="preserve">  <image id="image0" width="128" height="128" x="0" y="0"
    xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAMAAAD04JH5AAAABGdBTUEAALGPC/xhBQAAACBjSFJN
AAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAC+lBMVEUAAAD7+/vR0dH////7
+/v+/v76+vr8/f3////////+/v7////////////////9/f38/Pz7+/v////////8/Pz8/Pz29vbt
7e3t7e3n6Ofk5OTPz8/f3+DY2Nja2trR0dHIyMi9vb22traurq7Dw8O/v7+5ubm2trazs7Ovr6+m
pqapqamjo6OcnJyPj4+Li4uOjo6CgoJpamuPj49sbGyGhoaCgoJsbGx3d3dzc3NkZGRjY2Nqampf
X19oaGhfX19eXl5dXV3////8/Pz6+vr39/fz8/PT09OsrKy1tbXNzc3l5eXv7+/i4uLZ2Njt7e1b
W1sAAABMTUyDg4O3t7fg39/d3d1/f39FRURtbm7Q0NAaGhoeHh4+OTaZmZnV1dWTk5MSEhKoqKgk
IyIHCwyRkZGOjo4HBQWwsLB7enqlpaXn5+fHx8e/wMC9vb27u7vDw8PKysrq6uqfn58ODg7b29t2
dnZXVlZfXl6cnJyHh4cwMjAWFhZycXGjo6OWlpYRCgYhFQ8ZEAuLiop3Wkmrgmy9kHbKmX7VoYac
dWKJaFVjVUdbRjhhYmPlrY/+vpz/xKP/waH/wJ/3upplZmbdqY//x6btspP/u5f9zbX98uz82cn/
6d+6n5+/t7VpaWqYQkWFBwiaAQKpCg1hb3YnPjhUJihRAgKWLjGyJCiNVlnQJSqSh4QYMS2QFxuL
fnrCEhjrICbltp0FHSFvDg/LsKKwkYcFFhu5sK65ubk3KyOzs7NkWVTjmoDGbVy1SkDTg20hHBdw
mo2Htac/W1ORzrupw8tyyd6Z18RMZl5h4v5ReHCYzNpb2/9h3PZgeX99oKhmho4JJyqBeHSLg4B9
jpQrZmxxuctZ0ulZyN8weINk7P87kKFQwNZ6qbZi1/ExfZcZREth5P9f5/9i5/9DorRRscVnw9hn
zeUbTmVMvOpBi8RDmdNTy/9Gp+5Juf9Crv9EtP9DsP9Aq/9X0f9Nwf81iLNzZ2Nmn61klaNqYl9V
hbBKoOJZnMFmnPYPAAAAQnRSTlMABA8VIjBUfZqzz93o8/uPaULXqqjB69v5uJaHzeXCxbZhSizj
+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
FAAAAABJRU5ErkJggg==" />
</svg>
<a title="盛之羽翼
" href="/">盛书强</a></div>
    <nav>
      <ul><li><a href="/">主页</a></li><li><a href="/all.html">归档</a></li><li><a href="/about.html">关于</a></li><li><a type="application/rss+xml" href="/feed.xml">RSS</a></li>
      </ul>
    </nav>
  </div>
</header>
<div class="m-page-main"><div class="m-post">
	<div class="main clearfix js-main">
		<div class="col-2 js-col-2">
			<aside class="js-article-aside"><div class="m-toc js-toc"></div></aside>
		</div>
		<div class="col-1">
			<article class="js-article" itemscope itemtype="http://schema.org/BlogPosting">
				<meta itemprop="mainEntityOfPage" itemscope itemType="https://schema.org/WebPage"/>
				<header class="main-header"><h1 itemprop="headline" itemprop="name headline">Android事件分发-来龙去脉</h1><div class="m-article-data clearfix"><meta itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="盛书强"/></meta><ul class="tag-wrapper"><li>
          <a class="pill-button" href="/all.html?tag=Android">Android</a>
        </li><li>
          <a class="pill-button" href="/all.html?tag=%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91">事件分发</a>
        </li><li>
          <a class="pill-button" href="/all.html?tag=%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90">源码剖析</a>
        </li></ul><div class="other-wrapper"><div class="view-wrapper">
        <span class="article-view" id="post-key-20180210">0
        </span> 阅读
      </div><div class="date-wrapper"><time class="article-meta" datetime="2018-02-10T00:00:00+00:00"
          itemprop="datePublished">2018年 02月10日
        </time></div>
  </div>
</div>
</header>
				<div class="m-article-content js-article-content" itemprop="articleBody"><!-- 添加目录 http://blog.csdn.net/hengwei_vc/article/details/47122103 -->
<script src="/javascripts/jquery-2.1.4.min.js" type="text/javascript"></script>

<script src="/javascripts/toc.js" type="text/javascript"></script>

<script type="text/javascript">
$(document).ready(function() {
    $('#toc').toc();
}); </script>

<div id="toc"></div>

<h1 id="情境situation">情境(Situation)</h1>

<p class="info">1. 专注于移动互联网数年，作为高P的我【鼓掌】竟然对事件分发机制见招拆招，似懂非懂。不专业，没法忍。
<br />2. View树的递归嵌套逻辑让广大一线同行云里雾里，手足无措。</p>

<h1 id="冲突complication">冲突(Complication)</h1>

<p class="warning">1. 网上好多相关主题的博客，描述信息点非常多（但是ACTION_CANCEL描述很少），看完后不明觉厉。
<br />2. 事件分发主要用于解决自定义炫酷控件以及滑动嵌套引发的冲突问题（程序傻傻分不清是横滑还是竖滑），发现同行各种写法都有，雷无处不在【人在家中坐，锅从天上来】。</p>

<!--more-->

<hr />

<p><strong><center>我的机会来了<img src="http://www.linglingfa.net/new/face/233.gif" /></center></strong></p>

<hr />

<h1 id="疑问question">疑问(Question)</h1>

<p class="success">1. 有没有体系化剖析套路？
<br />2. 指出常见错误，给出最佳实践？
<br />3. 清晰明了的给出一张图，便于查阅？
<br />4. “鱼”和“渔”可以兼得？</p>

<h1 id="答案answer">答案(Answer)</h1>

<h2 id="剖析">剖析</h2>

<h3 id="论点">论点</h3>

<h4 id="约法三章">约法三章</h4>

<p class="warning">1. 限于个人水平，本文只包含单点触控事件（ACTION_DOWN，ACTION_MOVE，ACTION_UP，ACTION_CANCEL）。
<br />2. Window类相关的我不会，肤浅的认为和事件分发关系不大（求大牛点拨），直接跳过。
<br />3. 一家之言，姑妄言之，姑妄听之。</p>

<h4 id="点">点</h4>

<p class="info">1. <a href="https://developer.android.com/reference/android/view/MotionEvent.html">事件流一致性保证(Consistency Guarantees)</a>：按下开始，中间可能伴随着移动，松开或者取消结束。ACTION_DOWN -&gt; ACTION_MOVE(*) -&gt; ACTION_UP/ACTION_CANCEL。
<br />2. View类的dispatchTouchEvent方法完成事件的消费处理，ViewGroup的dispatchTouchEvent方法完成事件的分发处理。正常情况下不建议重写该方法改变系统事件分发机制。
<br />3. ViewGroup类的onInterceptTouchEvent方法完成事件的拦截处理。事件分发路径上的ViewGroup，在ACTION_DOWN或者不是自己直接消费事件时一定会调用onInterceptTouchEvent方法。
<br />4. View类的onTouchEvent方法完成具体处理事件消费，即触发点击监听（OnClickListener）和长时间点击监听(OnLongClickListener)以及按键状态、焦点相关处理。
<br />  1. 如果设置了OnTouchListener，会先调用OnTouchListener，如果该监听onTouch返回true，则不会调用onTouchEvent，直接返回已消费；
<br />  2. 如果设置了TouchDelegate ，onTouchEvent中会先调用TouchDelegate，如果该类onTouchEvent返回true，则直接返回已消费；
<br />  3. 如果View 可点击，执行onTouchEvent中事件处理，并返回true；
<br />    1. ACTION_DOWN：置按键标志位为按下状态，并触发延时（500ms）执行长按点击事件。
<br />    2. ACTION_MOVE：如果按键坐标超出该控件区域，则置按键标志位为非按下状态，并且移除ACTION_DOWN触发的延时执行长按点击事件。
<br />    3. ACTION_UP：如果按键标志位为按下状态，并且ACTION_DOWN触发的长按点击事件还未执行，则移除长按点击事件，执行点击事件。
<br />    4. ACTION_CANCEL：置按键标志位为非按下状态，移除ACTION_DOWN触发的延时执行长按点击事件。
<br />  4. 否则不可点击，返回false；</p>

<h3 id="论据">论据</h3>

<p class="info">基于<strong>Android 8.0 （API Level 28）</strong>源码解析</p>

<h4 id="人机交互">人机交互</h4>

<p><img src="http://localhost:4000/assets/人机交互流程图-tiny.png" alt="人机交互流程图" /></p>

<p><img src="http://localhost:4000/assets/事件分发Java栈-tiny.png" alt="事件分发Java栈" /></p>

<p><strong>赏析</strong></p>

<p class="info">用户的按键行为-&gt;手机传感器-&gt;ViewRootImpl-&gt;DecorView-&gt;WindowCallbackWrapper-&gt;Activity-&gt;PhoneWindow-&gt;DecorView-&gt;ViewGroup*-&gt;View-&gt;程序员的代码逻辑-&gt;硬件（显示器、扬声器等）响应输出-&gt;用户感知</p>

<h4 id="view树">View树</h4>

<p><img src="http://localhost:4000/assets/AndroidView树布局结构-tiny.png" alt="AndroidView树布局结构" /></p>

<p><strong>赏析</strong></p>

<p class="info">1. View是由树形结构组织，节点为ViewGroup或者View。ViewGroup可以包含多个子节点，View没有子节点。
<br />2. Android中View树的根节点为DecorView（父View为FrameLayout，属于ViewGroup）。
<br />3. Android中用户可自定义的View子树根节点id为“android:id/content”。</p>

<h4 id="类图">类图</h4>

<p><img src="http://localhost:4000/assets/View和ViewGroup类图-tiny.png" alt="View和ViewGroup类图" /></p>

<p><strong>赏析</strong></p>

<p class="info">1. ViewRootImpl是Android层逻辑起始点，用于接收来自系统底层的事件消息。相当于View管理类，本身不是View。（BTW：View绘制流程的三部曲（measure、layout、draw）也由该类触发的。）
<br />2. DecorView是Android View树的根节点，持有window对象。本身能够直接进行真正事件分发能力（继承了父类ViewGroup和View的事件分发处理功能），但是事件分发会直接调用window，间接传递到Activity的事件分发，后续会由Activity回调DecorView的真正事件分发能力。对应图中的环形依赖。
<br />3. Activity是Android中的页面，真正的事件分发由该类的dispatchTouchEvent触发。（Easter Eggs：如果你想让用户操作不了你的界面，蒙一层透明的View是不是有点low，直接重写该方法就可以控制。）
<br />4. ViewGroup负责事件分发和拦截处理。按下事件和后续事件（移动、释放或者取消）处理不相同。
<br />  1. 按下事件，先判断是否拦截。
<br />    1. 如果不拦截的话，分发事件寻找目标消费子View（逆序遍历子View，递归调用子View的事件分发，判断是否有子View消费。mFirstTouchTarget存储目标消费子View对象）。
<br />      1. 如果有子View消费，则目标子View消费事件。
<br />      2. 否则自己尝试消费事件。
<br />    2. 否则直接自己尝试消费事件。
<br />  2. 后续事件
<br />    1. 如果按下事件找到了目标消费子View，则判断是否拦截，否则不拦截。
<br />    2. 如果有目标消费子View，则根据是否拦截。
<br />      1. 如果没有拦截，正常传送后续事件；
<br />      2. 如果有拦截，则当前事件转换为取消事件发送给目标消费子View，并且重置目标消费子View为空，接下来的后续事件直接自己尝试消费事件（不管是否消费，后续事件都会接收到&amp;尝试处理事件分发）；
<br />    3. 否则自己尝试消费事件。（不会调用是否拦截，其实拦截或者不拦截，都是自己消费事件。）
<br />5. View负责事件消费事件处理。
<br />  1. 调用mOnTouchListener的onTouch。
<br />    1. 如果消费，直接返回true；
<br />    2. 否则，继续调用onTouchEvent方法；
<br />      1. 如果为启用的（enable），返回可点击（clickable）。
<br />      2. 否则，调用mTouchDelegate的onTouchEvent。
<br />        1. 如果消费，直接返回true；
<br />        2. 否则，
<br />          1. 如果可点击（clickable）
<br />            1. 进行事件流（ACTION_DOWN，ACTION_MOVE，ACTION_UP，ACTION_CANCEL）处理（包含焦点、按键状态、按键和长时间按键）；
<br />            2. 返回true。
<br />          2. 否则返回false；</p>

<h4 id="注释">注释</h4>

<h5 id="decorview">DecorView</h5>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="code"><pre><span class="cm">/**
  * Decor的意思是：装饰，布置。
  * View树的根节点。
  * 事件分发的启点，ViewRootImpl最先调用dispatchPointerEvent（实现在父类View里面）。
  * 事件调用在DecorView里面形成了一个环。（先通过Window交由Activity分发，Activity再调用DecorView中的真正事件分发方法）
  */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DecorView</span> <span class="kd">extends</span> <span class="n">FrameLayout</span>  <span class="o">{</span>
    <span class="kd">private</span> <span class="n">PhoneWindow</span> <span class="n">mWindow</span><span class="o">;</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">dispatchTouchEvent</span><span class="o">(</span><span class="n">MotionEvent</span> <span class="n">ev</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// DecorView直接覆盖ViewGroup的事件分发实现，其实这只是饶了个圈，</span>
        <span class="c1">// 正真的事件分发会由Activity回调到superDispatchTouchEvent（ViewGroup的事件分发处理）。</span>
        <span class="c1">// 调用Window的WindowCallbackWrapper对象继续分发。</span>
        <span class="kd">final</span> <span class="n">Window</span><span class="o">.</span><span class="na">Callback</span> <span class="n">cb</span> <span class="o">=</span> <span class="n">mWindow</span><span class="o">.</span><span class="na">getCallback</span><span class="o">();</span>
        <span class="k">return</span> <span class="n">cb</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">mWindow</span><span class="o">.</span><span class="na">isDestroyed</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">mFeatureId</span> <span class="o">&lt;</span> <span class="mi">0</span>
                <span class="o">?</span> <span class="n">cb</span><span class="o">.</span><span class="na">dispatchTouchEvent</span><span class="o">(</span><span class="n">ev</span><span class="o">)</span> <span class="o">:</span> <span class="kd">super</span><span class="o">.</span><span class="na">dispatchTouchEvent</span><span class="o">(</span><span class="n">ev</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">superDispatchTouchEvent</span><span class="o">(</span><span class="n">MotionEvent</span> <span class="n">event</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 调用父类ViewGroup进行事件分发处理。</span>
        <span class="k">return</span> <span class="kd">super</span><span class="o">.</span><span class="na">dispatchTouchEvent</span><span class="o">(</span><span class="n">event</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h5 id="windowcallbackwrapper">WindowCallbackWrapper</h5>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="cm">/**
  * Wrapper的意思是包装材料。
  * 实实在在的一个壳，包裹着Activity。
  */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">WindowCallbackWrapper</span> <span class="kd">implements</span> <span class="n">Window</span><span class="o">.</span><span class="na">Callback</span>   <span class="o">{</span>
    <span class="kd">final</span> <span class="n">Window</span><span class="o">.</span><span class="na">Callback</span> <span class="n">mWrapped</span><span class="o">;</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">dispatchTouchEvent</span><span class="o">(</span><span class="n">MotionEvent</span> <span class="n">event</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 交给Callback（具体对象为Activity）接力事件分发。</span>
        <span class="k">return</span> <span class="n">mWrapped</span><span class="o">.</span><span class="na">dispatchTouchEvent</span><span class="o">(</span><span class="n">event</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h5 id="activity">Activity</h5>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre></td><td class="code"><pre><span class="cm">/**
  * Activity和View不一样，Activity就是一个壳，没有事件分发机制，View树如果没有消费，Activity捡个漏。
  */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Activity</span> <span class="kd">implements</span> <span class="n">Window</span><span class="o">.</span><span class="na">Callback</span>  <span class="o">{</span>
    <span class="kd">private</span> <span class="n">Window</span> <span class="n">mWindow</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">dispatchTouchEvent</span><span class="o">(</span><span class="n">MotionEvent</span> <span class="n">ev</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">ev</span><span class="o">.</span><span class="na">getAction</span><span class="o">()</span> <span class="o">==</span> <span class="n">MotionEvent</span><span class="o">.</span><span class="na">ACTION_DOWN</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">onUserInteraction</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="c1">// 交给Window（具体对象为PhoneWindow）接力事件分发。</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">getWindow</span><span class="o">().</span><span class="na">superDispatchTouchEvent</span><span class="o">(</span><span class="n">ev</span><span class="o">))</span> <span class="o">{</span>
            <span class="c1">// View树消费掉事件</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// 如果View树没有消费事件，Activity消费事件的机会来了。</span>
        <span class="c1">// 启示：如果View树消费事件，在按下事件的后续事件中，如果父ViewGroup进行拦截，</span>
        <span class="c1">// 虽然后续返回的消费状态对整个事件流没有影响，但是会对Activity有影响（View数不消费，Activity有机会消费）。</span>
        <span class="k">return</span> <span class="nf">onTouchEvent</span><span class="o">(</span><span class="n">ev</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">onTouchEvent</span><span class="o">(</span><span class="n">MotionEvent</span> <span class="n">event</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 事件消费处理，系统默认基本不干啥</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">mWindow</span><span class="o">.</span><span class="na">shouldCloseOnTouch</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">event</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">finish</span><span class="o">();</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h5 id="phonewindow">PhoneWindow</h5>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="cm">/**
  * PhoneWindow也是一个壳，将事件转回给DecorView分发处理。
  */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">PhoneWindow</span> <span class="kd">extends</span> <span class="n">Window</span>  <span class="o">{</span>
    <span class="kd">private</span> <span class="n">DecorView</span> <span class="n">mDecor</span><span class="o">;</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">superDispatchTouchEvent</span><span class="o">(</span><span class="n">MotionEvent</span> <span class="n">event</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 交给DecorView接力事件分发（自此，环形结束，开始ViewGroup和View中事件分发和消费闪亮登场）。</span>
        <span class="k">return</span> <span class="n">mDecor</span><span class="o">.</span><span class="na">superDispatchTouchEvent</span><span class="o">(</span><span class="n">event</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h5 id="viewgroup">ViewGroup</h5>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326
327
</pre></td><td class="code"><pre><span class="cm">/**
  * ViewGroup，View容器的意思。
  * dispatchTouchEvent完成时间分发逻辑。
  * onInterceptTouchEvent：为事件拦截接口，父控件可以主动截留事件自己消费，否则只能等子Viwe树都不消费才能捡漏。【有控制权就是爸爸】
  */</span>
<span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">ViewGroup</span> <span class="kd">extends</span> <span class="n">View</span> <span class="kd">implements</span> <span class="n">ViewParent</span>  <span class="o">{</span>
    
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">dispatchTouchEvent</span><span class="o">(</span><span class="n">MotionEvent</span> <span class="n">ev</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">mInputEventConsistencyVerifier</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">mInputEventConsistencyVerifier</span><span class="o">.</span><span class="na">onTouchEvent</span><span class="o">(</span><span class="n">ev</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// If the event targets the accessibility focused view and this is it, start</span>
        <span class="c1">// normal event dispatch. Maybe a descendant is what will handle the click.</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">ev</span><span class="o">.</span><span class="na">isTargetAccessibilityFocus</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">isAccessibilityFocusedViewOrHost</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">ev</span><span class="o">.</span><span class="na">setTargetAccessibilityFocus</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="kt">boolean</span> <span class="n">handled</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">onFilterTouchEventForSecurity</span><span class="o">(</span><span class="n">ev</span><span class="o">))</span> <span class="o">{</span>
            <span class="kd">final</span> <span class="kt">int</span> <span class="n">action</span> <span class="o">=</span> <span class="n">ev</span><span class="o">.</span><span class="na">getAction</span><span class="o">();</span>
            <span class="kd">final</span> <span class="kt">int</span> <span class="n">actionMasked</span> <span class="o">=</span> <span class="n">action</span> <span class="o">&amp;</span> <span class="n">MotionEvent</span><span class="o">.</span><span class="na">ACTION_MASK</span><span class="o">;</span>

            <span class="c1">// Handle an initial down.</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">actionMasked</span> <span class="o">==</span> <span class="n">MotionEvent</span><span class="o">.</span><span class="na">ACTION_DOWN</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Throw away all previous state when starting a new touch gesture.</span>
                <span class="c1">// The framework may have dropped the up or cancel event for the previous gesture</span>
                <span class="c1">// due to an app switch, ANR, or some other state change.</span>
                <span class="c1">// 按下事件会进行状态重置。（才有外部拦截法解决滑动冲突的小伙伴要注意这里重置，拦截调用必须要做此之后。）</span>
                <span class="n">cancelAndClearTouchTargets</span><span class="o">(</span><span class="n">ev</span><span class="o">);</span>
                <span class="n">resetTouchState</span><span class="o">();</span>
            <span class="o">}</span>

            <span class="c1">// Check for interception.</span>
            <span class="c1">// 是否拦截判断</span>
            <span class="kd">final</span> <span class="kt">boolean</span> <span class="n">intercepted</span><span class="o">;</span>
            <span class="c1">// 拦截条件1，要么是按下事件，要么自己不直接消费事件。</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">actionMasked</span> <span class="o">==</span> <span class="n">MotionEvent</span><span class="o">.</span><span class="na">ACTION_DOWN</span>
                    <span class="o">||</span> <span class="n">mFirstTouchTarget</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// 拦截条件2，允许拦截开关打开。</span>
                <span class="c1">//（默认状态是打开的，其他View可以调用requestDisallowInterceptTouchEvent进行控制，</span>
                <span class="c1">// 多为子View掉父View，滑动冲突外部拦截法就是靠调用这个接口控制父View拦截）。【爸爸的权利也不是绝对的】</span>
                <span class="kd">final</span> <span class="kt">boolean</span> <span class="n">disallowIntercept</span> <span class="o">=</span> <span class="o">(</span><span class="n">mGroupFlags</span> <span class="o">&amp;</span> <span class="n">FLAG_DISALLOW_INTERCEPT</span><span class="o">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">;</span>
                <span class="k">if</span> <span class="o">(!</span><span class="n">disallowIntercept</span><span class="o">)</span> <span class="o">{</span>
                    <span class="c1">// 满足两个条件才会调到拦截控制（只能通过重写该方法，默认不拦截）。</span>
                    <span class="n">intercepted</span> <span class="o">=</span> <span class="n">onInterceptTouchEvent</span><span class="o">(</span><span class="n">ev</span><span class="o">);</span>
                    <span class="n">ev</span><span class="o">.</span><span class="na">setAction</span><span class="o">(</span><span class="n">action</span><span class="o">);</span> <span class="c1">// restore action in case it was changed</span>
                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                    <span class="n">intercepted</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// There are no touch targets and this action is not an initial down</span>
                <span class="c1">// so this view group continues to intercept touches.</span>
                <span class="c1">// 这种场景我没有遇到过，可能多点触控会调到【说错了当我放屁】</span>
                <span class="n">intercepted</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// If intercepted, start normal event dispatch. Also if there is already</span>
            <span class="c1">// a view that is handling the gesture, do normal event dispatch.</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">intercepted</span> <span class="o">||</span> <span class="n">mFirstTouchTarget</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">ev</span><span class="o">.</span><span class="na">setTargetAccessibilityFocus</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span>
            <span class="o">}</span>

            <span class="c1">// Check for cancelation.</span>
            <span class="kd">final</span> <span class="kt">boolean</span> <span class="n">canceled</span> <span class="o">=</span> <span class="n">resetCancelNextUpFlag</span><span class="o">(</span><span class="k">this</span><span class="o">)</span>
                    <span class="o">||</span> <span class="n">actionMasked</span> <span class="o">==</span> <span class="n">MotionEvent</span><span class="o">.</span><span class="na">ACTION_CANCEL</span><span class="o">;</span>

            <span class="c1">// Update list of touch targets for pointer down, if needed.</span>
            <span class="kd">final</span> <span class="kt">boolean</span> <span class="n">split</span> <span class="o">=</span> <span class="o">(</span><span class="n">mGroupFlags</span> <span class="o">&amp;</span> <span class="n">FLAG_SPLIT_MOTION_EVENTS</span><span class="o">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="n">TouchTarget</span> <span class="n">newTouchTarget</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
            <span class="kt">boolean</span> <span class="n">alreadyDispatchedToNewTouchTarget</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
            <span class="c1">// 递归查找目标消费子View条件1：事件没有被取消，也没有被拦截</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">canceled</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">intercepted</span><span class="o">)</span> <span class="o">{</span>

                <span class="c1">// If the event is targeting accessiiblity focus we give it to the</span>
                <span class="c1">// view that has accessibility focus and if it does not handle it</span>
                <span class="c1">// we clear the flag and dispatch the event to all children as usual.</span>
                <span class="c1">// We are looking up the accessibility focused host to avoid keeping</span>
                <span class="c1">// state since these events are very rare.</span>
                <span class="n">View</span> <span class="n">childWithAccessibilityFocus</span> <span class="o">=</span> <span class="n">ev</span><span class="o">.</span><span class="na">isTargetAccessibilityFocus</span><span class="o">()</span>
                        <span class="o">?</span> <span class="n">findChildWithAccessibilityFocus</span><span class="o">()</span> <span class="o">:</span> <span class="kc">null</span><span class="o">;</span>
                <span class="c1">// 递归查找目标消费子View条件2：事件必须是按下事件。【多点触控的不讨论，关键是我也不会】</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">actionMasked</span> <span class="o">==</span> <span class="n">MotionEvent</span><span class="o">.</span><span class="na">ACTION_DOWN</span>
                        <span class="o">||</span> <span class="o">(</span><span class="n">split</span> <span class="o">&amp;&amp;</span> <span class="n">actionMasked</span> <span class="o">==</span> <span class="n">MotionEvent</span><span class="o">.</span><span class="na">ACTION_POINTER_DOWN</span><span class="o">)</span>
                        <span class="o">||</span> <span class="n">actionMasked</span> <span class="o">==</span> <span class="n">MotionEvent</span><span class="o">.</span><span class="na">ACTION_HOVER_MOVE</span><span class="o">)</span> <span class="o">{</span>
                    <span class="kd">final</span> <span class="kt">int</span> <span class="n">actionIndex</span> <span class="o">=</span> <span class="n">ev</span><span class="o">.</span><span class="na">getActionIndex</span><span class="o">();</span> <span class="c1">// always 0 for down</span>
                    <span class="kd">final</span> <span class="kt">int</span> <span class="n">idBitsToAssign</span> <span class="o">=</span> <span class="n">split</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">ev</span><span class="o">.</span><span class="na">getPointerId</span><span class="o">(</span><span class="n">actionIndex</span><span class="o">)</span>
                            <span class="o">:</span> <span class="n">TouchTarget</span><span class="o">.</span><span class="na">ALL_POINTER_IDS</span><span class="o">;</span>

                    <span class="c1">// Clean up earlier touch targets for this pointer id in case they</span>
                    <span class="c1">// have become out of sync.</span>
                    <span class="n">removePointersFromTouchTargets</span><span class="o">(</span><span class="n">idBitsToAssign</span><span class="o">);</span>

                    <span class="kd">final</span> <span class="kt">int</span> <span class="n">childrenCount</span> <span class="o">=</span> <span class="n">mChildrenCount</span><span class="o">;</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">newTouchTarget</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">childrenCount</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                        <span class="kd">final</span> <span class="kt">float</span> <span class="n">x</span> <span class="o">=</span> <span class="n">ev</span><span class="o">.</span><span class="na">getX</span><span class="o">(</span><span class="n">actionIndex</span><span class="o">);</span>
                        <span class="kd">final</span> <span class="kt">float</span> <span class="n">y</span> <span class="o">=</span> <span class="n">ev</span><span class="o">.</span><span class="na">getY</span><span class="o">(</span><span class="n">actionIndex</span><span class="o">);</span>
                        <span class="c1">// Find a child that can receive the event.</span>
                        <span class="c1">// Scan children from front to back.</span>
                        <span class="c1">// 可以重置顺序，和事件分发关系不大，跳过</span>
                        <span class="kd">final</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">View</span><span class="o">&gt;</span> <span class="n">preorderedList</span> <span class="o">=</span> <span class="n">buildTouchDispatchChildList</span><span class="o">();</span>
                        <span class="kd">final</span> <span class="kt">boolean</span> <span class="n">customOrder</span> <span class="o">=</span> <span class="n">preorderedList</span> <span class="o">==</span> <span class="kc">null</span>
                                <span class="o">&amp;&amp;</span> <span class="n">isChildrenDrawingOrderEnabled</span><span class="o">();</span>
                        <span class="kd">final</span> <span class="n">View</span><span class="o">[]</span> <span class="n">children</span> <span class="o">=</span> <span class="n">mChildren</span><span class="o">;</span>
                        <span class="c1">// 逆序遍历，后面的View后绘制，盖在上面</span>
                        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">childrenCount</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span> <span class="o">{</span>
                            <span class="kd">final</span> <span class="kt">int</span> <span class="n">childIndex</span> <span class="o">=</span> <span class="n">getAndVerifyPreorderedIndex</span><span class="o">(</span>
                                    <span class="n">childrenCount</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">customOrder</span><span class="o">);</span>
                            <span class="kd">final</span> <span class="n">View</span> <span class="n">child</span> <span class="o">=</span> <span class="n">getAndVerifyPreorderedView</span><span class="o">(</span>
                                    <span class="n">preorderedList</span><span class="o">,</span> <span class="n">children</span><span class="o">,</span> <span class="n">childIndex</span><span class="o">);</span>

                            <span class="c1">// If there is a view that has accessibility focus we want it</span>
                            <span class="c1">// to get the event first and if not handled we will perform a</span>
                            <span class="c1">// normal dispatch. We may do a double iteration but this is</span>
                            <span class="c1">// safer given the timeframe.</span>
                            <span class="k">if</span> <span class="o">(</span><span class="n">childWithAccessibilityFocus</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                                <span class="k">if</span> <span class="o">(</span><span class="n">childWithAccessibilityFocus</span> <span class="o">!=</span> <span class="n">child</span><span class="o">)</span> <span class="o">{</span>
                                    <span class="k">continue</span><span class="o">;</span>
                                <span class="o">}</span>
                                <span class="n">childWithAccessibilityFocus</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                                <span class="n">i</span> <span class="o">=</span> <span class="n">childrenCount</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
                            <span class="o">}</span>
                            <span class="c1">// 消费事件View资格1：事件的坐标在View区域内。</span>
                            <span class="k">if</span> <span class="o">(!</span><span class="n">canViewReceivePointerEvents</span><span class="o">(</span><span class="n">child</span><span class="o">)</span>
                                    <span class="o">||</span> <span class="o">!</span><span class="n">isTransformedTouchPointInView</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">child</span><span class="o">,</span> <span class="kc">null</span><span class="o">))</span> <span class="o">{</span>
                                <span class="n">ev</span><span class="o">.</span><span class="na">setTargetAccessibilityFocus</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span>
                                <span class="k">continue</span><span class="o">;</span>
                            <span class="o">}</span>

                            <span class="n">newTouchTarget</span> <span class="o">=</span> <span class="n">getTouchTarget</span><span class="o">(</span><span class="n">child</span><span class="o">);</span>
                            <span class="k">if</span> <span class="o">(</span><span class="n">newTouchTarget</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                                <span class="c1">// Child is already receiving touch within its bounds.</span>
                                <span class="c1">// Give it the new pointer in addition to the ones it is handling.</span>
                                <span class="n">newTouchTarget</span><span class="o">.</span><span class="na">pointerIdBits</span> <span class="o">|=</span> <span class="n">idBitsToAssign</span><span class="o">;</span>
                                <span class="k">break</span><span class="o">;</span>
                            <span class="o">}</span>

                            <span class="n">resetCancelNextUpFlag</span><span class="o">(</span><span class="n">child</span><span class="o">);</span>
                            <span class="c1">// 消费事件View资格2：自己或者子View树消费事件。进入递归事件分发。</span>
                            <span class="k">if</span> <span class="o">(</span><span class="n">dispatchTransformedTouchEvent</span><span class="o">(</span><span class="n">ev</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="n">child</span><span class="o">,</span> <span class="n">idBitsToAssign</span><span class="o">))</span> <span class="o">{</span>
                                <span class="c1">// Child wants to receive touch within its bounds.</span>
                                <span class="n">mLastTouchDownTime</span> <span class="o">=</span> <span class="n">ev</span><span class="o">.</span><span class="na">getDownTime</span><span class="o">();</span>
                                <span class="k">if</span> <span class="o">(</span><span class="n">preorderedList</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                                    <span class="c1">// childIndex points into presorted list, find original index</span>
                                    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">childrenCount</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                                        <span class="k">if</span> <span class="o">(</span><span class="n">children</span><span class="o">[</span><span class="n">childIndex</span><span class="o">]</span> <span class="o">==</span> <span class="n">mChildren</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="o">{</span>
                                            <span class="n">mLastTouchDownIndex</span> <span class="o">=</span> <span class="n">j</span><span class="o">;</span>
                                            <span class="k">break</span><span class="o">;</span>
                                        <span class="o">}</span>
                                    <span class="o">}</span>
                                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                                    <span class="n">mLastTouchDownIndex</span> <span class="o">=</span> <span class="n">childIndex</span><span class="o">;</span>
                                <span class="o">}</span>
                                <span class="n">mLastTouchDownX</span> <span class="o">=</span> <span class="n">ev</span><span class="o">.</span><span class="na">getX</span><span class="o">();</span>
                                <span class="n">mLastTouchDownY</span> <span class="o">=</span> <span class="n">ev</span><span class="o">.</span><span class="na">getY</span><span class="o">();</span>
                                <span class="c1">// 标记当前View为目标消费子View，消费路径上都是父View标记直接子View（下发分发不用再找了）。不存在跨级。</span>
                                <span class="c1">// 我也没有搞明白为啥整一个链式结构存目标消费子View。我没有遇到多余1个目标消费子View的情况。【看逻辑，如果有子View消费，则跳出循环，不会继续分发】</span>
                                <span class="n">newTouchTarget</span> <span class="o">=</span> <span class="n">addTouchTarget</span><span class="o">(</span><span class="n">child</span><span class="o">,</span> <span class="n">idBitsToAssign</span><span class="o">);</span>
                                <span class="n">alreadyDispatchedToNewTouchTarget</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                                <span class="k">break</span><span class="o">;</span>
                            <span class="o">}</span>

                            <span class="c1">// The accessibility focus didn't handle the event, so clear</span>
                            <span class="c1">// the flag and do a normal dispatch to all children.</span>
                            <span class="n">ev</span><span class="o">.</span><span class="na">setTargetAccessibilityFocus</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span>
                        <span class="o">}</span>
                        <span class="k">if</span> <span class="o">(</span><span class="n">preorderedList</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="n">preorderedList</span><span class="o">.</span><span class="na">clear</span><span class="o">();</span>
                    <span class="o">}</span>

                    <span class="k">if</span> <span class="o">(</span><span class="n">newTouchTarget</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">mFirstTouchTarget</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                        <span class="c1">// Did not find a child to receive the event.</span>
                        <span class="c1">// Assign the pointer to the least recently added target.</span>
                        <span class="n">newTouchTarget</span> <span class="o">=</span> <span class="n">mFirstTouchTarget</span><span class="o">;</span>
                        <span class="k">while</span> <span class="o">(</span><span class="n">newTouchTarget</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                            <span class="n">newTouchTarget</span> <span class="o">=</span> <span class="n">newTouchTarget</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                        <span class="o">}</span>
                        <span class="n">newTouchTarget</span><span class="o">.</span><span class="na">pointerIdBits</span> <span class="o">|=</span> <span class="n">idBitsToAssign</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>

            <span class="c1">// Dispatch to touch targets.</span>
            <span class="c1">// 没有目标子View消费，自己消费。（要么自己拦截了，要么子View树没有消费）</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">mFirstTouchTarget</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// No touch targets so treat this as an ordinary view.</span>
                <span class="n">handled</span> <span class="o">=</span> <span class="n">dispatchTransformedTouchEvent</span><span class="o">(</span><span class="n">ev</span><span class="o">,</span> <span class="n">canceled</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span>
                        <span class="n">TouchTarget</span><span class="o">.</span><span class="na">ALL_POINTER_IDS</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// Dispatch to touch targets, excluding the new touch target if we already</span>
                <span class="c1">// dispatched to it.  Cancel touch targets if necessary.</span>
                <span class="n">TouchTarget</span> <span class="n">predecessor</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                <span class="n">TouchTarget</span> <span class="n">target</span> <span class="o">=</span> <span class="n">mFirstTouchTarget</span><span class="o">;</span>
                <span class="k">while</span> <span class="o">(</span><span class="n">target</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="kd">final</span> <span class="n">TouchTarget</span> <span class="n">next</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                    <span class="c1">// 如果是按下事件，则已消费，直接置消费状态为true</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">alreadyDispatchedToNewTouchTarget</span> <span class="o">&amp;&amp;</span> <span class="n">target</span> <span class="o">==</span> <span class="n">newTouchTarget</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">handled</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                        <span class="kd">final</span> <span class="kt">boolean</span> <span class="n">cancelChild</span> <span class="o">=</span> <span class="n">resetCancelNextUpFlag</span><span class="o">(</span><span class="n">target</span><span class="o">.</span><span class="na">child</span><span class="o">)</span>
                                <span class="o">||</span> <span class="n">intercepted</span><span class="o">;</span>
                        <span class="c1">// 非按下事件，要么持续正常处理消费，要么被拦截（事件转成取消事件，还是继续分发给目标View）</span>
                        <span class="k">if</span> <span class="o">(</span><span class="n">dispatchTransformedTouchEvent</span><span class="o">(</span><span class="n">ev</span><span class="o">,</span> <span class="n">cancelChild</span><span class="o">,</span>
                                <span class="n">target</span><span class="o">.</span><span class="na">child</span><span class="o">,</span> <span class="n">target</span><span class="o">.</span><span class="na">pointerIdBits</span><span class="o">))</span> <span class="o">{</span>
                            <span class="n">handled</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                        <span class="o">}</span>
                        <span class="k">if</span> <span class="o">(</span><span class="n">cancelChild</span><span class="o">)</span> <span class="o">{</span>
                            <span class="c1">// 如果是取消事件（要么被拦截，要么传过来的就是取消事件），则清空目标消费子View。</span>
                            <span class="k">if</span> <span class="o">(</span><span class="n">predecessor</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                                <span class="n">mFirstTouchTarget</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
                            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                                <span class="n">predecessor</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
                            <span class="o">}</span>
                            <span class="n">target</span><span class="o">.</span><span class="na">recycle</span><span class="o">();</span>
                            <span class="n">target</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
                            <span class="k">continue</span><span class="o">;</span>
                        <span class="o">}</span>
                    <span class="o">}</span>
                    <span class="n">predecessor</span> <span class="o">=</span> <span class="n">target</span><span class="o">;</span>
                    <span class="n">target</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>

            <span class="c1">// Update list of touch targets for pointer up or cancel, if needed.</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">canceled</span>
                    <span class="o">||</span> <span class="n">actionMasked</span> <span class="o">==</span> <span class="n">MotionEvent</span><span class="o">.</span><span class="na">ACTION_UP</span>
                    <span class="o">||</span> <span class="n">actionMasked</span> <span class="o">==</span> <span class="n">MotionEvent</span><span class="o">.</span><span class="na">ACTION_HOVER_MOVE</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">resetTouchState</span><span class="o">();</span>
            <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">split</span> <span class="o">&amp;&amp;</span> <span class="n">actionMasked</span> <span class="o">==</span> <span class="n">MotionEvent</span><span class="o">.</span><span class="na">ACTION_POINTER_UP</span><span class="o">)</span> <span class="o">{</span>
                <span class="kd">final</span> <span class="kt">int</span> <span class="n">actionIndex</span> <span class="o">=</span> <span class="n">ev</span><span class="o">.</span><span class="na">getActionIndex</span><span class="o">();</span>
                <span class="kd">final</span> <span class="kt">int</span> <span class="n">idBitsToRemove</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">ev</span><span class="o">.</span><span class="na">getPointerId</span><span class="o">(</span><span class="n">actionIndex</span><span class="o">);</span>
                <span class="n">removePointersFromTouchTargets</span><span class="o">(</span><span class="n">idBitsToRemove</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">if</span> <span class="o">(!</span><span class="n">handled</span> <span class="o">&amp;&amp;</span> <span class="n">mInputEventConsistencyVerifier</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">mInputEventConsistencyVerifier</span><span class="o">.</span><span class="na">onUnhandledEvent</span><span class="o">(</span><span class="n">ev</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="c1">// 返回消费状态</span>
        <span class="k">return</span> <span class="n">handled</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 拦截处理</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">onInterceptTouchEvent</span><span class="o">(</span><span class="n">MotionEvent</span> <span class="n">ev</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">ev</span><span class="o">.</span><span class="na">isFromSource</span><span class="o">(</span><span class="n">InputDevice</span><span class="o">.</span><span class="na">SOURCE_MOUSE</span><span class="o">)</span>
                <span class="o">&amp;&amp;</span> <span class="n">ev</span><span class="o">.</span><span class="na">getAction</span><span class="o">()</span> <span class="o">==</span> <span class="n">MotionEvent</span><span class="o">.</span><span class="na">ACTION_DOWN</span>
                <span class="o">&amp;&amp;</span> <span class="n">ev</span><span class="o">.</span><span class="na">isButtonPressed</span><span class="o">(</span><span class="n">MotionEvent</span><span class="o">.</span><span class="na">BUTTON_PRIMARY</span><span class="o">)</span>
                <span class="o">&amp;&amp;</span> <span class="n">isOnScrollbarThumb</span><span class="o">(</span><span class="n">ev</span><span class="o">.</span><span class="na">getX</span><span class="o">(),</span> <span class="n">ev</span><span class="o">.</span><span class="na">getY</span><span class="o">()))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 事件分发处理封装部分逻辑的子方法，实现取消事件转换</span>
    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">dispatchTransformedTouchEvent</span><span class="o">(</span><span class="n">MotionEvent</span> <span class="n">event</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">cancel</span><span class="o">,</span>
            <span class="n">View</span> <span class="n">child</span><span class="o">,</span> <span class="kt">int</span> <span class="n">desiredPointerIdBits</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">final</span> <span class="kt">boolean</span> <span class="n">handled</span><span class="o">;</span>

        <span class="c1">// Canceling motions is a special case.  We don't need to perform any transformations</span>
        <span class="c1">// or filtering.  The important part is the action, not the contents.</span>
        <span class="kd">final</span> <span class="kt">int</span> <span class="n">oldAction</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="na">getAction</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">cancel</span> <span class="o">||</span> <span class="n">oldAction</span> <span class="o">==</span> <span class="n">MotionEvent</span><span class="o">.</span><span class="na">ACTION_CANCEL</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 转换成取消事件</span>
            <span class="n">event</span><span class="o">.</span><span class="na">setAction</span><span class="o">(</span><span class="n">MotionEvent</span><span class="o">.</span><span class="na">ACTION_CANCEL</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">child</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">handled</span> <span class="o">=</span> <span class="kd">super</span><span class="o">.</span><span class="na">dispatchTouchEvent</span><span class="o">(</span><span class="n">event</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">handled</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="na">dispatchTouchEvent</span><span class="o">(</span><span class="n">event</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="n">event</span><span class="o">.</span><span class="na">setAction</span><span class="o">(</span><span class="n">oldAction</span><span class="o">);</span>
            <span class="k">return</span> <span class="n">handled</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Calculate the number of pointers to deliver.</span>
        <span class="kd">final</span> <span class="kt">int</span> <span class="n">oldPointerIdBits</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="na">getPointerIdBits</span><span class="o">();</span>
        <span class="kd">final</span> <span class="kt">int</span> <span class="n">newPointerIdBits</span> <span class="o">=</span> <span class="n">oldPointerIdBits</span> <span class="o">&amp;</span> <span class="n">desiredPointerIdBits</span><span class="o">;</span>

        <span class="c1">// If for some reason we ended up in an inconsistent state where it looks like we</span>
        <span class="c1">// might produce a motion event with no pointers in it, then drop the event.</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">newPointerIdBits</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// If the number of pointers is the same and we don't need to perform any fancy</span>
        <span class="c1">// irreversible transformations, then we can reuse the motion event for this</span>
        <span class="c1">// dispatch as long as we are careful to revert any changes we make.</span>
        <span class="c1">// Otherwise we need to make a copy.</span>
        <span class="kd">final</span> <span class="n">MotionEvent</span> <span class="n">transformedEvent</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">newPointerIdBits</span> <span class="o">==</span> <span class="n">oldPointerIdBits</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">child</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">child</span><span class="o">.</span><span class="na">hasIdentityMatrix</span><span class="o">())</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">child</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">handled</span> <span class="o">=</span> <span class="kd">super</span><span class="o">.</span><span class="na">dispatchTouchEvent</span><span class="o">(</span><span class="n">event</span><span class="o">);</span>
                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                    <span class="kd">final</span> <span class="kt">float</span> <span class="n">offsetX</span> <span class="o">=</span> <span class="n">mScrollX</span> <span class="o">-</span> <span class="n">child</span><span class="o">.</span><span class="na">mLeft</span><span class="o">;</span>
                    <span class="kd">final</span> <span class="kt">float</span> <span class="n">offsetY</span> <span class="o">=</span> <span class="n">mScrollY</span> <span class="o">-</span> <span class="n">child</span><span class="o">.</span><span class="na">mTop</span><span class="o">;</span>
                    <span class="n">event</span><span class="o">.</span><span class="na">offsetLocation</span><span class="o">(</span><span class="n">offsetX</span><span class="o">,</span> <span class="n">offsetY</span><span class="o">);</span>

                    <span class="n">handled</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="na">dispatchTouchEvent</span><span class="o">(</span><span class="n">event</span><span class="o">);</span>

                    <span class="n">event</span><span class="o">.</span><span class="na">offsetLocation</span><span class="o">(-</span><span class="n">offsetX</span><span class="o">,</span> <span class="o">-</span><span class="n">offsetY</span><span class="o">);</span>
                <span class="o">}</span>
                <span class="k">return</span> <span class="n">handled</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">transformedEvent</span> <span class="o">=</span> <span class="n">MotionEvent</span><span class="o">.</span><span class="na">obtain</span><span class="o">(</span><span class="n">event</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">transformedEvent</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="n">newPointerIdBits</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// Perform any necessary transformations and dispatch.</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">child</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">handled</span> <span class="o">=</span> <span class="kd">super</span><span class="o">.</span><span class="na">dispatchTouchEvent</span><span class="o">(</span><span class="n">transformedEvent</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="kd">final</span> <span class="kt">float</span> <span class="n">offsetX</span> <span class="o">=</span> <span class="n">mScrollX</span> <span class="o">-</span> <span class="n">child</span><span class="o">.</span><span class="na">mLeft</span><span class="o">;</span>
            <span class="kd">final</span> <span class="kt">float</span> <span class="n">offsetY</span> <span class="o">=</span> <span class="n">mScrollY</span> <span class="o">-</span> <span class="n">child</span><span class="o">.</span><span class="na">mTop</span><span class="o">;</span>
            <span class="n">transformedEvent</span><span class="o">.</span><span class="na">offsetLocation</span><span class="o">(</span><span class="n">offsetX</span><span class="o">,</span> <span class="n">offsetY</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(!</span> <span class="n">child</span><span class="o">.</span><span class="na">hasIdentityMatrix</span><span class="o">())</span> <span class="o">{</span>
                <span class="n">transformedEvent</span><span class="o">.</span><span class="na">transform</span><span class="o">(</span><span class="n">child</span><span class="o">.</span><span class="na">getInverseMatrix</span><span class="o">());</span>
            <span class="o">}</span>

            <span class="n">handled</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="na">dispatchTouchEvent</span><span class="o">(</span><span class="n">transformedEvent</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// Done.</span>
        <span class="n">transformedEvent</span><span class="o">.</span><span class="na">recycle</span><span class="o">();</span>
        <span class="k">return</span> <span class="n">handled</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<p><img src="http://localhost:4000/assets/事件DispatchTouchEvent流程图-tiny.png" alt="事件DispatchTouchEvent流程图" /></p>

<h5 id="view">View</h5>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
</pre></td><td class="code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">View</span>  <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">dispatchPointerEvent</span><span class="o">(</span><span class="n">MotionEvent</span> <span class="n">event</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// View树接收事件的起点，由ViewRootImpl调用DecorView的该方法开始，</span>
        <span class="c1">// 接下来会调用到DecorView的dispatchTouchEvent方法。</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">event</span><span class="o">.</span><span class="na">isTouchEvent</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">return</span> <span class="nf">dispatchTouchEvent</span><span class="o">(</span><span class="n">event</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="k">return</span> <span class="nf">dispatchGenericMotionEvent</span><span class="o">(</span><span class="n">event</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// 事件消费处理</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">dispatchTouchEvent</span><span class="o">(</span><span class="n">MotionEvent</span> <span class="n">event</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// If the event should be handled by accessibility focus first.</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">event</span><span class="o">.</span><span class="na">isTargetAccessibilityFocus</span><span class="o">())</span> <span class="o">{</span>
            <span class="c1">// We don't have focus or no virtual descendant has it, do not handle the event.</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">isAccessibilityFocusedViewOrHost</span><span class="o">())</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="c1">// We have focus and got the event, then use normal event dispatch.</span>
            <span class="n">event</span><span class="o">.</span><span class="na">setTargetAccessibilityFocus</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="kt">boolean</span> <span class="n">result</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">mInputEventConsistencyVerifier</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">mInputEventConsistencyVerifier</span><span class="o">.</span><span class="na">onTouchEvent</span><span class="o">(</span><span class="n">event</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="kd">final</span> <span class="kt">int</span> <span class="n">actionMasked</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="na">getActionMasked</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">actionMasked</span> <span class="o">==</span> <span class="n">MotionEvent</span><span class="o">.</span><span class="na">ACTION_DOWN</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Defensive cleanup for new gesture</span>
            <span class="n">stopNestedScroll</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">onFilterTouchEventForSecurity</span><span class="o">(</span><span class="n">event</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">((</span><span class="n">mViewFlags</span> <span class="o">&amp;</span> <span class="n">ENABLED_MASK</span><span class="o">)</span> <span class="o">==</span> <span class="n">ENABLED</span> <span class="o">&amp;&amp;</span> <span class="n">handleScrollBarDragging</span><span class="o">(</span><span class="n">event</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">result</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="c1">//noinspection SimplifiableIfStatement</span>
            <span class="n">ListenerInfo</span> <span class="n">li</span> <span class="o">=</span> <span class="n">mListenerInfo</span><span class="o">;</span>
            <span class="c1">// 优先mOnTouchListener消费处理，如果消费，直接返回已消费</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">li</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">li</span><span class="o">.</span><span class="na">mOnTouchListener</span> <span class="o">!=</span> <span class="kc">null</span>
                    <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">mViewFlags</span> <span class="o">&amp;</span> <span class="n">ENABLED_MASK</span><span class="o">)</span> <span class="o">==</span> <span class="n">ENABLED</span>
                    <span class="o">&amp;&amp;</span> <span class="n">li</span><span class="o">.</span><span class="na">mOnTouchListener</span><span class="o">.</span><span class="na">onTouch</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">event</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">result</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// 自己处理消费，封装在onTouchEvent内</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">result</span> <span class="o">&amp;&amp;</span> <span class="n">onTouchEvent</span><span class="o">(</span><span class="n">event</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">result</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">if</span> <span class="o">(!</span><span class="n">result</span> <span class="o">&amp;&amp;</span> <span class="n">mInputEventConsistencyVerifier</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">mInputEventConsistencyVerifier</span><span class="o">.</span><span class="na">onUnhandledEvent</span><span class="o">(</span><span class="n">event</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// Clean up after nested scrolls if this is the end of a gesture;</span>
        <span class="c1">// also cancel it if we tried an ACTION_DOWN but we didn't want the rest</span>
        <span class="c1">// of the gesture.</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">actionMasked</span> <span class="o">==</span> <span class="n">MotionEvent</span><span class="o">.</span><span class="na">ACTION_UP</span> <span class="o">||</span>
                <span class="n">actionMasked</span> <span class="o">==</span> <span class="n">MotionEvent</span><span class="o">.</span><span class="na">ACTION_CANCEL</span> <span class="o">||</span>
                <span class="o">(</span><span class="n">actionMasked</span> <span class="o">==</span> <span class="n">MotionEvent</span><span class="o">.</span><span class="na">ACTION_DOWN</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">result</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">stopNestedScroll</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 针对完整事件流（ACTION\_DOWN -&gt; ACTION\_MOVE(*) -&gt; ACTION\_UP/ACTION\_CANCEL）完成按键监听、长时间按键监听、焦点以及按键状态处理。</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">onTouchEvent</span><span class="o">(</span><span class="n">MotionEvent</span> <span class="n">event</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">final</span> <span class="kt">float</span> <span class="n">x</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="na">getX</span><span class="o">();</span>
        <span class="kd">final</span> <span class="kt">float</span> <span class="n">y</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="na">getY</span><span class="o">();</span>
        <span class="kd">final</span> <span class="kt">int</span> <span class="n">viewFlags</span> <span class="o">=</span> <span class="n">mViewFlags</span><span class="o">;</span>
        <span class="kd">final</span> <span class="kt">int</span> <span class="n">action</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="na">getAction</span><span class="o">();</span>

        <span class="kd">final</span> <span class="kt">boolean</span> <span class="n">clickable</span> <span class="o">=</span> <span class="o">((</span><span class="n">viewFlags</span> <span class="o">&amp;</span> <span class="n">CLICKABLE</span><span class="o">)</span> <span class="o">==</span> <span class="n">CLICKABLE</span>
                <span class="o">||</span> <span class="o">(</span><span class="n">viewFlags</span> <span class="o">&amp;</span> <span class="n">LONG_CLICKABLE</span><span class="o">)</span> <span class="o">==</span> <span class="n">LONG_CLICKABLE</span><span class="o">)</span>
                <span class="o">||</span> <span class="o">(</span><span class="n">viewFlags</span> <span class="o">&amp;</span> <span class="n">CONTEXT_CLICKABLE</span><span class="o">)</span> <span class="o">==</span> <span class="n">CONTEXT_CLICKABLE</span><span class="o">;</span>

        <span class="k">if</span> <span class="o">((</span><span class="n">viewFlags</span> <span class="o">&amp;</span> <span class="n">ENABLED_MASK</span><span class="o">)</span> <span class="o">==</span> <span class="n">DISABLED</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 按键未启用，直接返回点击状态。</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">action</span> <span class="o">==</span> <span class="n">MotionEvent</span><span class="o">.</span><span class="na">ACTION_UP</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">mPrivateFlags</span> <span class="o">&amp;</span> <span class="n">PFLAG_PRESSED</span><span class="o">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">setPressed</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="n">mPrivateFlags3</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PFLAG3_FINGER_DOWN</span><span class="o">;</span>
            <span class="c1">// A disabled view that is clickable still consumes the touch</span>
            <span class="c1">// events, it just doesn't respond to them.</span>
            <span class="k">return</span> <span class="n">clickable</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">// 有效触摸代理消费事件，可用于扩大点击热点控制。如果消费，直接返回已消费。</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">mTouchDelegate</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">mTouchDelegate</span><span class="o">.</span><span class="na">onTouchEvent</span><span class="o">(</span><span class="n">event</span><span class="o">))</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">clickable</span> <span class="o">||</span> <span class="o">(</span><span class="n">viewFlags</span> <span class="o">&amp;</span> <span class="n">TOOLTIP</span><span class="o">)</span> <span class="o">==</span> <span class="n">TOOLTIP</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 可点击情况下进行按键处理。</span>
            <span class="k">switch</span> <span class="o">(</span><span class="n">action</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">case</span> <span class="n">MotionEvent</span><span class="o">.</span><span class="na">ACTION_UP</span><span class="o">:</span>
                    <span class="n">mPrivateFlags3</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PFLAG3_FINGER_DOWN</span><span class="o">;</span>
                    <span class="k">if</span> <span class="o">((</span><span class="n">viewFlags</span> <span class="o">&amp;</span> <span class="n">TOOLTIP</span><span class="o">)</span> <span class="o">==</span> <span class="n">TOOLTIP</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">handleTooltipUp</span><span class="o">();</span>
                    <span class="o">}</span>
                    <span class="k">if</span> <span class="o">(!</span><span class="n">clickable</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">removeTapCallback</span><span class="o">();</span>
                        <span class="n">removeLongPressCallback</span><span class="o">();</span>
                        <span class="n">mInContextButtonPress</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                        <span class="n">mHasPerformedLongPress</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                        <span class="n">mIgnoreNextUpEvent</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                        <span class="k">break</span><span class="o">;</span>
                    <span class="o">}</span>
                    <span class="kt">boolean</span> <span class="n">prepressed</span> <span class="o">=</span> <span class="o">(</span><span class="n">mPrivateFlags</span> <span class="o">&amp;</span> <span class="n">PFLAG_PREPRESSED</span><span class="o">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">;</span>
                    <span class="c1">// 检查按键标志位状态，只有为按下状态才接着处理。</span>
                    <span class="k">if</span> <span class="o">((</span><span class="n">mPrivateFlags</span> <span class="o">&amp;</span> <span class="n">PFLAG_PRESSED</span><span class="o">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">prepressed</span><span class="o">)</span> <span class="o">{</span>
                        <span class="c1">// take focus if we don't have it already and we should in</span>
                        <span class="c1">// touch mode.</span>
                        <span class="kt">boolean</span> <span class="n">focusTaken</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                        <span class="k">if</span> <span class="o">(</span><span class="n">isFocusable</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">isFocusableInTouchMode</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">isFocused</span><span class="o">())</span> <span class="o">{</span>
                            <span class="n">focusTaken</span> <span class="o">=</span> <span class="n">requestFocus</span><span class="o">();</span>
                        <span class="o">}</span>

                        <span class="k">if</span> <span class="o">(</span><span class="n">prepressed</span><span class="o">)</span> <span class="o">{</span>
                            <span class="c1">// The button is being released before we actually</span>
                            <span class="c1">// showed it as pressed.  Make it show the pressed</span>
                            <span class="c1">// state now (before scheduling the click) to ensure</span>
                            <span class="c1">// the user sees it.</span>
                            <span class="n">setPressed</span><span class="o">(</span><span class="kc">true</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">);</span>
                        <span class="o">}</span>

                        <span class="k">if</span> <span class="o">(!</span><span class="n">mHasPerformedLongPress</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">mIgnoreNextUpEvent</span><span class="o">)</span> <span class="o">{</span>
                            <span class="c1">// This is a tap, so remove the longpress check</span>
                            <span class="c1">// ACTION_DOWN触发的长按点击事件还未执行，则移除长按点击事件，</span>
                            <span class="n">removeLongPressCallback</span><span class="o">();</span>

                            <span class="c1">// Only perform take click actions if we were in the pressed state</span>
                            <span class="k">if</span> <span class="o">(!</span><span class="n">focusTaken</span><span class="o">)</span> <span class="o">{</span>
                                <span class="c1">// Use a Runnable and post this rather than calling</span>
                                <span class="c1">// performClick directly. This lets other visual state</span>
                                <span class="c1">// of the view update before click actions start.</span>
                                <span class="k">if</span> <span class="o">(</span><span class="n">mPerformClick</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                                    <span class="n">mPerformClick</span> <span class="o">=</span> <span class="k">new</span> <span class="n">PerformClick</span><span class="o">();</span>
                                <span class="o">}</span>
                                <span class="c1">// 执行点击事件。</span>
                                <span class="k">if</span> <span class="o">(!</span><span class="n">post</span><span class="o">(</span><span class="n">mPerformClick</span><span class="o">))</span> <span class="o">{</span>
                                    <span class="n">performClick</span><span class="o">();</span>
                                <span class="o">}</span>
                            <span class="o">}</span>
                        <span class="o">}</span>

                        <span class="k">if</span> <span class="o">(</span><span class="n">mUnsetPressedState</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                            <span class="n">mUnsetPressedState</span> <span class="o">=</span> <span class="k">new</span> <span class="n">UnsetPressedState</span><span class="o">();</span>
                        <span class="o">}</span>

                        <span class="k">if</span> <span class="o">(</span><span class="n">prepressed</span><span class="o">)</span> <span class="o">{</span>
                            <span class="n">postDelayed</span><span class="o">(</span><span class="n">mUnsetPressedState</span><span class="o">,</span>
                                    <span class="n">ViewConfiguration</span><span class="o">.</span><span class="na">getPressedStateDuration</span><span class="o">());</span>
                        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(!</span><span class="n">post</span><span class="o">(</span><span class="n">mUnsetPressedState</span><span class="o">))</span> <span class="o">{</span>
                            <span class="c1">// If the post failed, unpress right now</span>
                            <span class="n">mUnsetPressedState</span><span class="o">.</span><span class="na">run</span><span class="o">();</span>
                        <span class="o">}</span>

                        <span class="n">removeTapCallback</span><span class="o">();</span>
                    <span class="o">}</span>
                    <span class="n">mIgnoreNextUpEvent</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                    <span class="k">break</span><span class="o">;</span>

                <span class="k">case</span> <span class="n">MotionEvent</span><span class="o">.</span><span class="na">ACTION_DOWN</span><span class="o">:</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">event</span><span class="o">.</span><span class="na">getSource</span><span class="o">()</span> <span class="o">==</span> <span class="n">InputDevice</span><span class="o">.</span><span class="na">SOURCE_TOUCHSCREEN</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">mPrivateFlags3</span> <span class="o">|=</span> <span class="n">PFLAG3_FINGER_DOWN</span><span class="o">;</span>
                    <span class="o">}</span>
                    <span class="n">mHasPerformedLongPress</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>

                    <span class="k">if</span> <span class="o">(!</span><span class="n">clickable</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">checkForLongClick</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">);</span>
                        <span class="k">break</span><span class="o">;</span>
                    <span class="o">}</span>

                    <span class="k">if</span> <span class="o">(</span><span class="n">performButtonActionOnTouchDown</span><span class="o">(</span><span class="n">event</span><span class="o">))</span> <span class="o">{</span>
                        <span class="k">break</span><span class="o">;</span>
                    <span class="o">}</span>

                    <span class="c1">// Walk up the hierarchy to determine if we're inside a scrolling container.</span>
                    <span class="kt">boolean</span> <span class="n">isInScrollingContainer</span> <span class="o">=</span> <span class="n">isInScrollingContainer</span><span class="o">();</span>

                    <span class="c1">// For views inside a scrolling container, delay the pressed feedback for</span>
                    <span class="c1">// a short period in case this is a scroll.</span>
                    <span class="c1">// 置按键标志位为按下状态，并触发延时（500ms）执行长按点击事件。</span>
                    <span class="c1">// 以下为滚动和非滚动下的处理。</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">isInScrollingContainer</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">mPrivateFlags</span> <span class="o">|=</span> <span class="n">PFLAG_PREPRESSED</span><span class="o">;</span>
                        <span class="k">if</span> <span class="o">(</span><span class="n">mPendingCheckForTap</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                            <span class="n">mPendingCheckForTap</span> <span class="o">=</span> <span class="k">new</span> <span class="n">CheckForTap</span><span class="o">();</span>
                        <span class="o">}</span>
                        <span class="n">mPendingCheckForTap</span><span class="o">.</span><span class="na">x</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="na">getX</span><span class="o">();</span>
                        <span class="n">mPendingCheckForTap</span><span class="o">.</span><span class="na">y</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="na">getY</span><span class="o">();</span>
                        <span class="n">postDelayed</span><span class="o">(</span><span class="n">mPendingCheckForTap</span><span class="o">,</span> <span class="n">ViewConfiguration</span><span class="o">.</span><span class="na">getTapTimeout</span><span class="o">());</span>
                    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                        <span class="c1">// Not inside a scrolling container, so show the feedback right away</span>
                        <span class="n">setPressed</span><span class="o">(</span><span class="kc">true</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">);</span>
                        <span class="n">checkForLongClick</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">);</span>
                    <span class="o">}</span>
                    <span class="k">break</span><span class="o">;</span>

                <span class="k">case</span> <span class="n">MotionEvent</span><span class="o">.</span><span class="na">ACTION_CANCEL</span><span class="o">:</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">clickable</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">setPressed</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span>
                    <span class="o">}</span>
                    <span class="c1">// 置按键标志位为非按下状态，移除ACTION_DOWN触发的延时执行长按点击事件。</span>
                    <span class="n">removeTapCallback</span><span class="o">();</span>
                    <span class="n">removeLongPressCallback</span><span class="o">();</span>
                    <span class="n">mInContextButtonPress</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                    <span class="n">mHasPerformedLongPress</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                    <span class="n">mIgnoreNextUpEvent</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                    <span class="n">mPrivateFlags3</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PFLAG3_FINGER_DOWN</span><span class="o">;</span>
                    <span class="k">break</span><span class="o">;</span>

                <span class="k">case</span> <span class="n">MotionEvent</span><span class="o">.</span><span class="na">ACTION_MOVE</span><span class="o">:</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">clickable</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">drawableHotspotChanged</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">);</span>
                    <span class="o">}</span>

                    <span class="c1">// Be lenient about moving outside of buttons</span>
                    <span class="c1">// 检查按键坐标是否超出该View区域。</span>
                    <span class="k">if</span> <span class="o">(!</span><span class="n">pointInView</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">mTouchSlop</span><span class="o">))</span> <span class="o">{</span>
                        <span class="c1">// Outside button</span>
                        <span class="c1">// Remove any future long press/tap checks</span>
                        <span class="c1">// 置按键标志位为非按下状态，并且移除ACTION\_DOWN触发的延时执行长按点击事件。</span>
                        <span class="n">removeTapCallback</span><span class="o">();</span>
                        <span class="n">removeLongPressCallback</span><span class="o">();</span>
                        <span class="k">if</span> <span class="o">((</span><span class="n">mPrivateFlags</span> <span class="o">&amp;</span> <span class="n">PFLAG_PRESSED</span><span class="o">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                            <span class="n">setPressed</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span>
                        <span class="o">}</span>
                        <span class="n">mPrivateFlags3</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PFLAG3_FINGER_DOWN</span><span class="o">;</span>
                    <span class="o">}</span>
                    <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<p><img src="http://localhost:4000/assets/事件OnTouchEvent流程图-tiny.png" alt="事件OnTouchEvent流程图" /></p>

<h4 id="事件流">事件流</h4>

<p><strong>Demo</strong><a href="https://github.com/shengshuqiang/viewdispatchtouchevent/blob/master/app/src/main/java/com/example/shengshuqiang/viewdispatchtouchevent/ParentInterceptTouchEventActivity.java">ParentInterceptTouchEventActivity页面git仓库</a></p>

<p>使用<a href="https://www.jianshu.com/p/d968645067d7"><strong>MECE</strong></a>（Mutually Exclusive Collectively Exhaustive，相互独立，完全穷尽）法则</p>

<p><img src="http://localhost:4000/assets/事件流MEMC图-tiny.png" alt="事件流MEMC图" /></p>

<table>
  <thead>
    <tr>
      <th>条件</th>
      <th>结果</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1.父控件ACTION_DOWN拦截<br />2.父控件消费事件</td>
      <td>1. 接收按下事件 -DOWN-&gt; Parent.dispatchTouchEvent -DOWN-&gt; Parent.onInterceptTouchEvent -true-&gt; Parent.dispatchTouchEvent -DOWN-&gt; Parent.(super)dispatchTouchEvent{Parent处理消费} -DOWN-&gt;  Parent.onTouchEvent -true-&gt; Parent.dispatchTouchEvent-true-&gt; 返回消费状态true<br />2. 接收移动事件 -MOVE-&gt; Parent.dispatchTouchEvent -MOVE-&gt; Parent.(super)dispatchTouchEvent{Parent处理消费} -MOVE-&gt; Parent.onTouchEvent -消费状态-&gt; Parent.dispatchTouchEvent -true-&gt; 返回消费状态true<br />3. 接收释放事件 -UP-&gt; Parent.dispatchTouchEvent -UP-&gt; Parent.(super)dispatchTouchEvent{Parent处理消费} -UP-&gt; Parent.onTouchEvent -true-&gt; Parent.dispatchTouchEvent -true-&gt; 返回消费状态true</td>
    </tr>
    <tr>
      <td>1.父控件ACTION_DOWN拦截<br />2.父控件不消费事件</td>
      <td>4. 接收按下事件 -DOWN-&gt; Parent.dispatchTouchEvent -DOWN-&gt; Parent.onInterceptTouchEvent -true-&gt; Parent.dispatchTouchEvent -DOWN-&gt; Parent.(super)dispatchTouchEvent{Parent处理消费} -DOWN-&gt;  Parent.onTouchEvent -false-&gt; Parent.dispatchTouchEvent-false-&gt; 返回消费状态false<br />5. 接收不到移动事件<br />6. 同5</td>
    </tr>
    <tr>
      <td>1.父控件ACTION_MOVE拦截<br />2.子控件消费事件</td>
      <td>7. 接收按下事件 -DOWN-&gt; Parent.dispatchTouchEvent -DOWN-&gt; Parent.onInterceptTouchEvent  -false-&gt; Parent.dispatchTouchEvent -DOWN-&gt; Child.dispatchTouchEvent{Parent分发，遍历调用Child分发消息，Child内部递归分发消息} -DOWN-&gt; TargetChild（目标子控件，区别Child，子控件消费事件，要么是自己消费了，要么是自己的后代或者后代的后代消费了）.onTouchEvent{存在调用多个Child该方法，前提是前面的Child均返回false} -true-&gt; Child.dispatchTouchEvent -true-&gt; Parent.dispatchTouchEvent{记录目标消费Child为该View}-true-&gt; 返回消费状态true<br />8. 接收移动事件 -MOVE-&gt; Parent.dispatchTouchEvent -MOVE-&gt; Parent.onInterceptTouchEvent  -true-&gt; Parent.dispatchTouchEvent -CANCEL-&gt; Child（目标消费Child）.dispatchTouchEvent{Child处理消费} -CANCEL-&gt;Child.onTouchEvent -消费状态-&gt; Child.dispatchTouchEvent-消费状态-&gt; 返回消费状态<br />9. 接收释放事件 -UP-&gt; Parent.dispatchTouchEvent -UP-&gt; Parent.(super)dispatchTouchEvent{Parent处理消费} -UP-&gt; Parent.onTouchEvent -消费状态-&gt; Parent.dispatchTouchEvent -消费状态-&gt; 返回消费状态</td>
    </tr>
    <tr>
      <td>1.父控件ACTION_MOVE拦截<br />2.子控件不消费事件<br />3.父控件消费事件</td>
      <td>10. 接收按下事件 -DOWN-&gt; Parent.dispatchTouchEvent -DOWN-&gt; Parent.onInterceptTouchEvent  -false-&gt; Parent.dispatchTouchEvent -DOWN-&gt; Child.dispatchTouchEvent{Parent分发，遍历调用Child分发消息，Child内部递归分发消息} -DOWN-&gt; TargetChild（目标子控件，区别Child，子控件处理消费事件）.onTouchEvent{满足事件坐标在控件内的子View或者子View的后代均会调用到} -false-&gt; Child.dispatchTouchEvent -false-&gt; Parent.dispatchTouchEvent{没有目标消费Child} -DOWN-&gt; Parent.(super)dispatchTouchEvent{Parent处理消费} -DOWN-&gt;  Parent.onTouchEvent -true-&gt; 返回消费状态true<br />11. 同2<br />12. 同3</td>
    </tr>
    <tr>
      <td>1.父控件ACTION_MOVE拦截<br />2.子控件不消费事件<br />3.父控件不消费事件</td>
      <td>13. 接收按下事件 -DOWN-&gt; Parent.dispatchTouchEvent -DOWN-&gt; Parent.onInterceptTouchEvent  -false-&gt; Parent.dispatchTouchEvent -DOWN-&gt; Child.dispatchTouchEvent{Parent分发，遍历调用Child分发消息，Child内部递归分发消息} -DOWN-&gt; TargetChild（目标子控件，区别Child，子控件处理消费事件）.onTouchEvent{满足事件坐标在控件内的子View或者子View的后代均会调用到} -false-&gt; Child.dispatchTouchEvent -false-&gt; Parent.dispatchTouchEvent{没有目标消费Child} -DOWN-&gt; Parent.(super)dispatchTouchEvent{Parent处理消费} -DOWN-&gt;  Parent.onTouchEvent -false-&gt; 返回消费状态false<br />14. 同5<br />15. 同5</td>
    </tr>
    <tr>
      <td>1.父控件ACTION_UP拦截<br />2.子控件消费事件</td>
      <td>16. 同7<br />17. 接收移动事件 -MOVE-&gt; Parent.dispatchTouchEvent -MOVE-&gt; Parent.onInterceptTouchEvent  -false-&gt; Parent.dispatchTouchEvent -MOVE-&gt; Child(目标消费Child).dispatchTouchEvent -MOVE-&gt; Child.onTouchEvent -true-&gt; Child.dispatchTouchEvent -true-&gt; Parent.dispatchTouchEvent -true-&gt; 返回消费状态true<br />18. 接收释放事件 -UP-&gt; Parent.dispatchTouchEvent -UP-&gt; Parent.onInterceptTouchEvent -true-&gt; Parent.dispatchTouchEvent -CANCEL-&gt; Child(目标消费Child).dispatchTouchEvent{Child处理消费} -CANCEL-&gt; Child.onTouchEvent -消费状态-&gt; Child.dispatchTouchEvent -true-&gt; Parent.dispatchTouchEvent -true-&gt; 返回消费状态true</td>
    </tr>
    <tr>
      <td>1.父控件ACTION_UP拦截<br />2.子控件不消费事件<br />3.父控件消费事件</td>
      <td>19. 同10<br />20. 同2<br />21. 同3</td>
    </tr>
    <tr>
      <td>1.父控件ACTION_UP拦截<br />2.子控件不消费事件<br />3.父控件不消费事件</td>
      <td>22. 同13<br />23. 同5<br />24. 同5</td>
    </tr>
    <tr>
      <td>1. 父控件不拦截<br />2. 子控件消费事件</td>
      <td>25. 同7<br />26. 同17<br />27. 接收释放事件 -UP-&gt; Parent.dispatchTouchEvent -UP-&gt; Parent.onInterceptTouchEvent  -false-&gt; Parent.dispatchTouchEvent -UP-&gt; Child(目标消费Child).dispatchTouchEvent -UP-&gt; Child.onTouchEvent -true-&gt; Child.dispatchTouchEvent -true-&gt; Parent.dispatchTouchEvent -true-&gt; 返回消费状态true</td>
    </tr>
    <tr>
      <td>1. 父控件不拦截<br />2. 子控件不消费事件<br />3. 父控件消费事件</td>
      <td>28. 同10<br />29. 同2<br />30. 同3</td>
    </tr>
    <tr>
      <td>1. 父控件不拦截<br />2. 子控件不消费事件<br />3. 父控件不消费事件</td>
      <td>31. 同13<br />32. 同5<br />33. 同5</td>
    </tr>
  </tbody>
</table>

<p><strong>启示</strong></p>

<p class="info">1. ACTION_DOWN执行事件分发查找（遍历子View，递归分发查找，如果子View未消费，则回退到自己消费，依次向上回溯，找到目标消费View为止）找到目标消费子View。后续事件不再需要查找，直接发送给目标消费子View，如果没有，则自己消费。<br /><img src="http://localhost:4000/assets/事件分发路径-tiny.png" alt="事件分发路径" />
<br />2. 事件已消费路径上（终点为目标消费View），如果有父控件拦截事件，则第一次拦截后，会将当前事件转为ACTION_CANCEL传递给目标消费子View，后续事件则直接自己处理消费，不论是否消费，均能收到后续事件流<br /> <img src="http://localhost:4000/assets/事件分发拦截路径-tiny.png" alt="事件分发拦截路径" /></p>

<h3 id="论证">论证</h3>

<p class="success">1. 从事件流可证明事件一致性保证(Consistency Guarantees)：
<br />  1. ViewGroup在ACTION_DOWN的事件分发返回false（不消费事件），则不再会收到后续事件（ACTION_MOVE、ACTION_UP/ACTION_CANCEL）。
<br />  2. ViewGroup在ACTION_DOWN的事件分发返回true（消费事件），则会收到后续事件（ACTION_MOVE、ACTION_UP/ACTION_CANCEL），如果ViewGroup拦截后续事件，则第一次拦截会将事件转为ACTION_CANCEL传递给目标消费子View（终止子View接收后续事件），接下来的后续事件自己消费。
<br />  3.  ViewGroup在非ACTION_DOWN的事件分发返回消费状态对整体事件流没有影响。
<br />2. 从注释可证明:<br />View.dispatchTouchEvent方法完成事件的消费处理；<br />ViewGroup.dispatchTouchEvent方法完成事件的分发处理；<br />ViewGroup.onInterceptTouchEvent方法完成事件的拦截处理；<br />事件分发路径上的ViewGroup，在ACTION_DOWN或者不是自己直接消费事件时一定会调用onInterceptTouchEvent方法。<br />以及View类的onTouchEvent方法完成具体处理事件消费。</p>

<h2 id="一张图">一张图</h2>

<p><img src="http://localhost:4000/assets/事件分发一张图-tiny.png" alt="事件分发一张图" /></p>

<p><strong>赏析</strong></p>

<p class="info">1. ACTION_DOWN会触发查找目标消费View，优先子View尝试消费，如果子View仍然没有消费，则依次回溯到父控件尝试消费（直至DecorView，然后Activity尝试消费），如果找到了，则回溯返回true。
<br />2. ACTION_DOWN后续事件执行的前提是事件分发路径的终点就是目标消费View，目标消费View的父控件均会调用到事件拦截（让父控件有机会拦截下来，改变事件流），如果目标消费View的父控件拦截，拦截时的事件会转换为ACTION_CANCEL继续按原路径分发，后续的事件则不再分发给目标消费View，而是拦截的父控件自己消费。
<br />3. 非ACTION_DOWN返回的消费状态对事件流没有影响，如果未消费，会回调给Activity处理。</p>

<h2 id="标准">标准</h2>

<h3 id="常见错误">常见错误</h3>

<p class="error">1. 不知道onInterceptTouchEvent和onTouchEvent什么时候会调用，但是知道dispatchTouchEvent每次都会调用，就把逻辑直接写在dispatchTouchEvent的重写方法里面。<br /><strong>问题：</strong>不满足事件流一致性，存在目标消费View没有接收到ACTION_UP/ACTION_CANCEL就结束了，导致焦点、按键状态或者按键事件不符合预期。
<br />2. 发现onInterceptTouchEvent经常调用到，逻辑写在onInterceptTouchEvent里面。<br /><strong>问题：</strong>onInterceptTouchEvent在View自己消费情况下或者拦截之后的事件流不再会调用到，会把坑隐藏得更深【不好复现的Bug才是最难解决的Bug】。
<br />3. 鸟枪法，dispatchTouchEvent、onInterceptTouchEvent、onTouchEvent均会调用到逻辑。<br /><strong>问题：</strong>路子太野。。。
<br />4. 觉得自己很牛X，逻辑分散在dispatchTouchEvent、onInterceptTouchEvent、onTouchEvent里面。<br /><strong>问题：</strong>可读性差，逻辑混乱。
<br />5. 事件消息只处理了ACTION_DOWN、ACTION_MOVE、ACTION_UP，没有对ACTION_CANCEL或者其他多点触控事件容错处理。<br /><strong>问题：</strong>总会出现不常见的问题。</p>

<h3 id="最佳实践">最佳实践</h3>

<p class="success">1. 明确事件流调用顺序以及拦截后的事件流。
<br />2. dispatchTouchEvent：正常情况下不建议重写dispatchTouchEvent方法改变系统事件分发机制，可以看到，Google就没有几个类重新该方法。最多记下坐标点，但千万调用super. dispatchTouchEvent保证系统事件分发正常调用。
<br />3. onInterceptTouchEvent：只处理拦截逻辑，在合适事件将事件流导到onTouchEvent。
<br />4. onTouchEvent：真正处理逻辑。
<br />5. 除常见事件处理外，一定要上剩余事件容错处理。</p>

<h2 id="渔">渔</h2>

<h3 id="方法论">方法论</h3>

<p class="info">1. <a href="https://www.jianshu.com/p/d968645067d7">MECE法则和金字塔原理</a>
<br />2. <a href="https://www.zhihu.com/question/27880205">SCQA 架构如何理解？</a></p>

<h3 id="利器">利器</h3>
<p class="info">1. AS源码英文翻译，参考<a href="http://blog.csdn.net/luofen521/article/details/74295716">AS翻译插件Translation</a>
<br />2. Android源码调试
<br />  1. <a href="http://www.genymotion.net/">Android模拟器GenyMotion</a>
<br />  2. GenyMotion创建和App的build.gradle中targetSdkVersion相同API Level模拟器即可Debug对应上源码。进阶参考<a href="http://weishu.me/2016/05/30/how-to-debug-android-framework/">如何调试Android Framework？</a>
<br />  3. <a href="http://weishu.me/2015/12/21/android-studio-debug-tips-you-may-not-know/">Android Studio你不知道的调试技巧</a>
<br />3. 关键日志输出，使用静态代理，进阶参考<a href="http://weishu.me/2016/01/28/understand-plugin-framework-proxy-hook/">Android插件化原理解析——Hook机制之动态代理</a>
<br />4. 绘图工具
<br />  1. <a href="https://www.processon.com/i/5a633502e4b0332f153dd897">ProcessOn</a>
<br />  2. <a href="https://www.edrawsoft.com/download-edrawmax-mac.php">Edraw</a>
<br />5. 个人主页
<br />  1. <a href="https://www.jekyll.com.cn/">将纯文本转化为静态网站和博客</a>
<br />  2. <a href="https://github.com/kitian616/jekyll-TeXt-theme">TeXt主题模板</a>
<br />  3. <a href="https://www.zhihu.com/question/20409634">怎样引导新手使用 Markdown？</a></p>

<h1 id="利">利</h1>

<p class="success">1. 随心所欲控制事件流【大权在手，天下我有】
<br />2. 事件分发不再是个事，怕个球
<br />3. 各种酷炫动画和自定义控件燥起来
<br />4. 再也不用担心面试中尬聊事件分发
<br />5. 借鉴上述不成熟的“渔”去爱干嘛干嘛</p>

<h1 id="进阶">进阶</h1>

<p class="info">1. 滚动控件和按键冲突处理，界面布局滚动
<br />2. 滑动冲突
<br />  1. <a href="https://segmentfault.com/a/1190000002873657">NestedScrolling机制</a>
<br />  2. <a href="http://blog.csdn.net/lmj623565791/article/details/52204039">Android NestedScrolling机制完全解析 带你玩转嵌套滑动</a>
<br />  3. <a href="https://www.jianshu.com/p/982a83271327">外部拦截法&amp;内部拦截法</a>
<br />3. 手势（GestureDecetor）</p>

<h1 id="参考">参考</h1>
<p class="info">1. <a href="https://www.jianshu.com/p/e99b5e8bd67b">图解 Android 事件分发机制</a>
<br />2. <a href="http://blog.ingphone.com/android/2013/11/13/Android-%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6.html">Android 响应用户屏幕手势操作</a>
<br />3. <a href="https://www.jianshu.com/p/0c863bbde8eb">Android MotionEvent详解</a>
<br />4. <a href="https://my.oschina.net/banxi/blog/56421">android触控,先了解MotionEvent(一)</a>
<br />5. <a href="http://blog.csdn.net/woshimalingyi/article/details/50383578">Android多点触控之——MotionEvent(触控事件)</a>
<br />6. <a href="http://ztelur.github.io/2016/02/04/%E5%9B%BE%E8%A7%A3Android%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E4%B9%8BView%E7%AF%87/">图解Android事件传递之View篇</a>
<br />7. <a href="http://ztelur.github.io/2016/02/11/%E5%9B%BE%E8%A7%A3Android%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E4%B9%8BViewGroup%E7%AF%87/">图解Android事件传递之ViewGroup篇</a></p>

<h1 id="长歌">长歌</h1>

<p class="info"><strong>念奴娇·天丁震怒</strong>
<br />完颜亮(金代)
<br />
<br />天丁震怒，掀翻银海，散乱珠箔（bó）。
<br />六出奇花飞滚滚，平填了山中丘壑。(六出：雪花六角，因用为雪花的别名。)
<br />皓虎颠狂，素麟猖獗(chāng jué)，掣(chè, 拉)断珍珠索。(皓虎：白色的老虎。素麟：白色的麒麟。)
<br />玉龙酣战，鳞甲满天飘落。
<br />
<br />谁念万里关山，征夫僵立，缟（gǎo）带沾旗脚。(僵立：因寒冷而冻得僵硬直立。缟带：白色的衣带。)
<br />色映戈矛，光摇剑戟(jǐ )，杀气横戎幕。(戎幕：行军作战时的营帐。)
<br />貔（pí）虎豪雄，偏裨（pí）英勇，共与谈兵略。（裨：副，偏，小。）
<br />须拼一醉，看取碧空寥廓(liáo kuò)。</p>
</div>
				<footer><meta itemprop="dateModified" content="2018-02-10T00:00:00+00:00"><div class="article-license"><div class="m-license"><div class="clearfix"><p>本文遵守 <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> 许可协议。</p><a class="license" rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">
      <img alt="Creative Commons License" src="/assets/images/license-cc4.png" />
    </a><p>欢迎转载，转载需注明出处，且禁止用于商业目的。</p>
  </div>
</div></div>
				</footer>
			</article>
			<div class="article-previous-next clearfix"></div></div>
	</div>
</div></div>
      </div>
    </div><div class="m-page-footer js-page-footer">
  <div class="main">
    <aside><div class="follow-me"><ul itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="盛书强">
    <link itemprop="url" href="http://localhost:4000/"><li title="在 Github 上关注我。">
        <div class="floating-action-round-button github">
          <a itemprop="sameAs" href="https://github.com/https://github.com/shengshuqiang" target="_blank">
            <div class="icon"><svg fill="#000000" width="24px" height="24px" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path class="svgpath" data-index="path_0" fill="#272636" d="M0 525.2c0 223.6 143.3 413.7 343 483.5 26.9 6.8 22.8-12.4 22.8-25.4l0-88.7c-155.3 18.2-161.5-84.6-172-101.7-21.1-36-70.8-45.2-56-62.3 35.4-18.2 71.4 4.6 113.1 66.3 30.2 44.7 89.1 37.2 119 29.7 6.5-26.9 20.5-50.9 39.7-69.6C248.8 728.2 181.7 630 181.7 513.2c0-56.6 18.7-108.7 55.3-150.7-23.3-69.3 2.2-128.5 5.6-137.3 66.5-6 135.5 47.6 140.9 51.8 37.8-10.2 80.9-15.6 129.1-15.6 48.5 0 91.8 5.6 129.8 15.9 12.9-9.8 77-55.8 138.8-50.2 3.3 8.8 28.2 66.7 6.3 135 37.1 42.1 56 94.6 56 151.4 0 117-67.5 215.3-228.8 243.7 26.9 26.6 43.6 63.4 43.6 104.2l0 128.8c0.9 10.3 0 20.5 17.2 20.5C878.1 942.4 1024 750.9 1024 525.3c0-282.9-229.3-512-512-512C229.1 13.2 0 242.3 0 525.2L0 525.2z" />
</svg>
</div>
          </a>
        </div>
      </li></ul><p class="email">
      <a title="给我发邮件。" href="mailto:674329414@qq.com" target="_self">674329414@qq.com</a>
    </p></div>
</aside>
    <footer class="site-info">
      <p>© 盛书强 2018</p>
      <p>Powered by <a title="Jekyll is a simple, blog-aware, static site generator." href="http://jekyllrb.com/">Jekyll</a> & <a
        title="TeXt is a succinct theme for blogging." href="https://github.com/kitian616/jekyll-TeXt-theme">TeXt Theme</a>.</p>
    </footer>
  </div>
</div><script>
  (function () {
    var root = document.body
    function classnames(classes) {
      var i, cur, _classes = '';
      if (window.isString(classes)) {
        _classes =  classes;
      } else if (window.isArray(classes)) {
        for (i = 0; i < classes.length; i++) {
          cur = classes[i];
          if (window.isString(cur)) {
            _classes = _classes.concat(_classes ? ' ' + cur : cur);
          }
        }
      } else {
        return '';
      }
      return _classes;
    }
    function addClass(dom, classname) {
      dom.setAttribute('class', classnames([dom.getAttribute('class'), classname]));
    }
    if (window.hasEvent('touchstart')) {
      addClass(root, 'is-touch');
      document.addEventListener("touchstart", function(){}, false);
    } else {
      addClass(root, 'not-touch');
    }
  })();
</script><script>
  (function() {
    function scrollAnimateTo(destination, duration, callback) {
      var $body = $('html, body'), bodyScrollTop = $body.scrollTop();
      if(bodyScrollTop === destination) { return; }
      $body.animate({ scrollTop: destination }, duration, callback);
    }
    window.scrollTopAnchor = function(anchor, callback) {
      scrollAnimateTo($(anchor).offset().top, 400, function() {
        window.history.replaceState(null, '', window.location.href.split('#')[0] + anchor);
        callback && callback();
      });
    }
  })();
  window.Lazyload.js('https://cdn.bootcss.com/jquery/3.1.1/jquery.min.js', function() {
    var $articleContent = $('.m-post, .m-page').find('.m-article-content'), $this;
    $articleContent.children('.highlight').each(function() {
      $this = $(this);
      $this.attr('data-lang', $this.find('code').attr('data-lang'));
    });

    $articleContent.children('h1, h2, h3, h4, h5, h6').each(function() {
      $this = $(this);
      $this.append($('<a class="anchor" aria-hidden="true"></a>').html('<svg fill="#000000" width="16px" height="16px" viewBox="0 0 16 16" version="1.1" xmlns="http://www.w3.org/2000/svg"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'));
    });
    $articleContent.on('click', '.anchor', function() {
      window.scrollTopAnchor('#' + $(this).parent().attr('id'));
    });
  });
</script><script>
  window.Lazyload.js('https://cdn.bootcss.com/jquery/3.1.1/jquery.min.js', function() {
    var $window = $(window);
    var $pageStage = $('.js-page-stage');
    var $pageMain = $('.js-main');
    var $pageFooter = $('.js-page-footer');
    var $articleContent = $('.js-article-content');
    var $articleAside = $('.js-article-aside');
    var $toc = $('.js-toc');
    var $col2 = $('.js-col-2');
    var hasTitle = $articleContent.find('h1,h2,h3').length > 0;
    function asideSticky() {
      return $col2.css('display') !== 'none' && $pageStage.hasClass('has-toc');
    }
    function setTocClass() {
      if (hasTitle) {
        !$pageStage.hasClass('has-toc') && $pageStage.addClass('has-toc');
      }
    }
    function setAsideTOC() {
      var asideTop, asideLeft, scrollBottom, asideBottomTop, lastScrollTop;
      function init() {
        var asideOffset = $articleAside.offset();
        var footerOffset = $pageFooter.offset();
        var mainOffset = $pageMain.offset();
        asideTop = mainOffset.top;
        asideHeight = $toc.outerHeight() + parseInt($articleAside.css('padding-top'), 10) + parseInt($articleAside.css('padding-bottom'), 10);
        asideLeft = mainOffset.left + $pageMain.outerWidth() - $articleAside.outerWidth() - parseInt($pageMain.css('padding-right'), 10);
        scrollBottom = footerOffset.top - asideHeight;
        asideBottomTop = scrollBottom - mainOffset.top;
      }
      function setAside(force) {
        force !== true && (force = false);
        var scrollTop = $window.scrollTop();
        if (scrollTop >= asideTop && scrollTop <= scrollBottom) {
          (!force && lastScrollTop >= asideTop && lastScrollTop <= scrollBottom) ||
          $articleAside.addClass('fixed').css({
            left: asideLeft + 'px',
            top: 0
          });
        } else if (scrollTop < asideTop) {
          (!force && lastScrollTop < asideTop) ||
          $articleAside.removeClass('fixed').css({
            left: 0,
            top: 0
          });
        } else {
          (!force && lastScrollTop > scrollBottom) ||
          $articleAside.removeClass('fixed').css({
            left: 0,
            top: asideBottomTop + 'px'
          });
        }
        lastScrollTop = scrollTop;
      }
      asideSticky() && (init(), setAside());
      $window.on('scroll', function() {
        asideSticky() && setAside();
      });
      $window.on('resize', window.throttle(function() {
        setTocClass();
        asideSticky() && (init(), setAside(true));
      }, 100));
      setTimeout(init, 4000);
    }
    function toc() {
      var $tocUl = $('<ul></ul>'), $tocLi, $headings = $articleContent.find('h1,h2,h3'), headingsTop = [],
        scrolling, activeLast, activeCur, rendered = false;
      function init() {
        $headings.each(function() {
          headingsTop.push(Math.floor($(this).offset().top));
        });
      }
      function setActiveHeading(element, disabled) {
        var scrollTop = $window.scrollTop(), i;
        if (disabled || headingsTop.length < 1) { return; }
        if (element) {
          activeCur = element;
        } else {
          for (i = 0; i < headingsTop.length; i++) {
            if (scrollTop >= headingsTop[i]) {
              activeCur = $tocLi.eq(i);
            } else {
              activeCur || (activeCur = $tocLi.eq(i));
              break;
            }
          }
        }
        activeLast && activeLast.removeClass('toc-active');
        (activeLast = activeCur).addClass('toc-active');
      }
      function render() {
        $toc.append($tocUl);
        $headings.each(function() {
          var $this = $(this);
          $tocUl.append($('<li></li>').addClass('toc-' + $this.prop("tagName").toLowerCase())
            .append($('<a></a>').text($this.text()).attr('href', '#' + $this.prop('id'))));
        });
        $tocLi = $tocUl.children('li');
        $tocUl.on('click', 'a', function(e) {
          e.preventDefault();
          var $this = $(this);
          scrolling = true;
          setActiveHeading($this.parent());
          window.scrollTopAnchor($this.attr('href'), function() {
            scrolling = false;
          });
        });
        rendered = true;
      }
      asideSticky() && (render(), $window.on('load', function() {
        setTimeout(function() {
          init();
          setActiveHeading(null, scrolling);
        }, 1000);
      }));
      $window.on('resize', window.throttle(function() {
        if (asideSticky()) {
          rendered || render();
          init();
          setActiveHeading(null, scrolling);
        }
      }));
      $window.on('scroll', function() {
        asideSticky() && setActiveHeading(null, scrolling);
      });
    }
    setTocClass();
    toc();
    setTimeout(function() {
      setAsideTOC();
    }, 1000);
  });</script></body>
</html>
