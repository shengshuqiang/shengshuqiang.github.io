<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

 <title>Poole</title>
 <link href="http://localhost:4000/atom.xml" rel="self"/>
 <link href="http://localhost:4000/"/>
 <updated>2018-02-10T12:07:26+08:00</updated>
 <id>http://localhost:4000</id>
 <author>
   <name>Mark Otto</name>
   <email>markdotto@gmail.com</email>
 </author>

 
 <entry>
   <title>Android事件分发“来龙去脉”</title>
   <link href="http://localhost:4000/2018/02/10/Android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91-%E6%9D%A5%E9%BE%99%E5%8E%BB%E8%84%89/"/>
   <updated>2018-02-10T00:00:00+08:00</updated>
   <id>http://localhost:4000/2018/02/10/Android事件分发“来龙去脉” </id>
   <content type="html">&lt;!--# Android事件分发“来龙去脉”--&gt;

&lt;!--高亮代码块--&gt;
&lt;!--&lt;link rel=&quot;stylesheet&quot; href=&quot;http://yandex.st/highlightjs/8.0/styles/solarized_dark.min.css&quot;&gt;&lt;script src=&quot;http://yandex.st/highlightjs/8.0/highlight.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;hljs.initHighlightingOnLoad();&lt;/script&gt;--&gt;

&lt;!----&gt;
&lt;p&gt;[toc]&lt;/p&gt;

&lt;h1 id=&quot;情境situation&quot;&gt;情境(Situation)&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;专注于移动互联网数年，作为高P的我【鼓掌】竟然对事件分发机制见招拆招，似懂非懂。不专业，没法忍。&lt;/li&gt;
  &lt;li&gt;View树的递归嵌套逻辑让广大一线同行云里雾里，手足无措。&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;冲突complication&quot;&gt;冲突(Complication)&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;网上好多相关主题的博客，描述信息点非常多（但是ACTION_CANCEL描述很少），看完后不明觉厉。&lt;/li&gt;
  &lt;li&gt;事件分发主要用于解决滑动冲突问题（程序傻傻分不清是横滑还是竖滑），发现同行各种写法都有，雷无处不在【人在家中坐，锅从天上来】。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;我的机会来了&lt;/strong&gt;【大笑】&lt;/p&gt;

&lt;h1 id=&quot;疑问question&quot;&gt;疑问(Question)&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;有没有体系化剖析套路？&lt;/li&gt;
  &lt;li&gt;指出常见错误，给出最佳实践？&lt;/li&gt;
  &lt;li&gt;清晰明了的给出一张图，便于查阅？&lt;/li&gt;
  &lt;li&gt;“鱼”和“渔”可以兼得？&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;答案answer&quot;&gt;答案(Answer)&lt;/h1&gt;

&lt;h2 id=&quot;剖析&quot;&gt;剖析&lt;/h2&gt;

&lt;h3 id=&quot;论点&quot;&gt;论点&lt;/h3&gt;

&lt;h4 id=&quot;约法三章&quot;&gt;约法三章&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;限于个人水平，本文只包含单点触控事件（ACTION_DOWN，ACTION_MOVE，ACTION_UP，ACTION_CANCEL）。&lt;/li&gt;
  &lt;li&gt;Window类相关的我不会，肤浅的认为和事件分发关系不大（求大牛点拨），直接跳过。&lt;/li&gt;
  &lt;li&gt;一家之言，姑妄言之，姑妄听之。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;点&quot;&gt;点&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.android.com/reference/android/view/MotionEvent.html&quot;&gt;事件流一致性保证(Consistency Guarantees)&lt;/a&gt;：按下开始，中间可能伴随着移动，松开或者取消结束。ACTION_DOWN -&amp;gt; ACTION_MOVE(*) -&amp;gt; ACTION_UP/ACTION_CANCEL。（Motion events are always delivered to views as a consistent stream of events.What constitutes a consistent stream varies depending on the type of device. For touch events, consistency implies that pointers go down one at a time,move around as a group and then go up one at a time or are canceled.）&lt;/li&gt;
  &lt;li&gt;View类的dispatchTouchEvent方法完成事件的消费处理，ViewGroup的dispatchTouchEvent方法完成事件的分发处理。正常情况下不建议重写该方法改变系统事件分发机制。&lt;/li&gt;
  &lt;li&gt;ViewGroup类的onInterceptTouchEvent方法完成事件的拦截处理。事件分发路径上的ViewGroup，在ACTION_DOWN或者不是自己直接消费事件时一定会调用onInterceptTouchEvent方法。&lt;/li&gt;
  &lt;li&gt;View类的onTouchEvent方法完成具体处理事件消费，即触发点击监听（OnClickListener）和长时间点击监听(OnLongClickListener)以及按键状态、焦点相关处理。
    &lt;ol&gt;
      &lt;li&gt;如果设置了OnTouchListener，会先调用OnTouchListener，如果该监听onTouch返回true，则不会调用onTouchEvent，直接返回已消费；&lt;/li&gt;
      &lt;li&gt;如果设置了TouchDelegate ，onTouchEvent中会先调用TouchDelegate，如果该类onTouchEvent返回true，则直接返回已消费；&lt;/li&gt;
      &lt;li&gt;如果View 可点击，执行onTouchEvent中事件处理，并返回true；
        &lt;ol&gt;
          &lt;li&gt;ACTION_DOWN：置按键标志位为按下状态，并触发延时（500ms）执行长按点击事件。&lt;/li&gt;
          &lt;li&gt;ACTION_MOVE：如果按键坐标超出该控件区域，则置按键标志位为非按下状态，并且移除ACTION_DOWN触发的延时执行长按点击事件。&lt;/li&gt;
          &lt;li&gt;ACTION_UP：如果按键标志位为按下状态，并且ACTION_DOWN触发的长按点击事件还未执行，则移除长按点击事件，执行点击事件。&lt;/li&gt;
          &lt;li&gt;ACTION_CANCEL：置按键标志位为非按下状态，移除ACTION_DOWN触发的延时执行长按点击事件。&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;否则不可点击，返回false；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;论据&quot;&gt;论据&lt;/h3&gt;

&lt;p&gt;基于&lt;strong&gt;Android 8.0 （API Level 28）&lt;/strong&gt;源码解析&lt;/p&gt;

&lt;h4 id=&quot;人机交互&quot;&gt;人机交互&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/人机交互流程图.png&quot; alt=&quot;人机交互流程图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/事件分发Java栈.png&quot; alt=&quot;事件分发Java栈&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;赏析&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;用户的按键行为-&amp;gt;手机传感器-&amp;gt;ViewRootImpl-&amp;gt;DecorView-&amp;gt;WindowCallbackWrapper-&amp;gt;Activity-&amp;gt;PhoneWindow-&amp;gt;DecorView-&amp;gt;ViewGroup*-&amp;gt;View-&amp;gt;程序员的代码逻辑-&amp;gt;硬件（显示器、扬声器等）响应输出-&amp;gt;用户感知&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;view树&quot;&gt;View树&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/AndroidView树布局结构.png&quot; alt=&quot;AndroidView树布局结构&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;赏析&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;View是由树形结构组织，节点为ViewGroup或者View。ViewGroup可以包含多个子节点，View没有子节点。&lt;/li&gt;
  &lt;li&gt;Android中View树的根节点为DecorView（父View为FrameLayout，属于ViewGroup）。&lt;/li&gt;
  &lt;li&gt;Android中用户可自定义的View子树根节点id为“android:id/content”。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;类图&quot;&gt;类图&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/View和ViewGroup类图.png&quot; alt=&quot;View和ViewGroup类图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;赏析&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;ViewRootImpl是Android层逻辑起始点，用于接收来自系统底层的事件消息。相当于View管理类，本身不是View。（BTW：View绘制流程的三部曲（measure、layout、draw）也由该类触发的。）&lt;/li&gt;
  &lt;li&gt;DecorView是Android View树的根节点，持有window对象。本身能够直接进行真正事件分发能力（继承了父类ViewGroup和View的事件分发处理功能），但是事件分发会直接调用window，间接传递到Activity的事件分发，后续会由Activity回调DecorView的真正事件分发能力。对应图中的环形依赖。&lt;/li&gt;
  &lt;li&gt;Activity是Android中的页面，真正的事件分发由该类的dispatchTouchEvent触发。（Easter Eggs：如果你想让用户操作不了你的界面，蒙一层透明的View是不是有点low，直接重写该方法就可以控制。）&lt;/li&gt;
  &lt;li&gt;ViewGroup负责事件分发和拦截处理。按下事件和后续事件（移动、释放或者取消）处理不相同。
    &lt;ol&gt;
      &lt;li&gt;按下事件，先判断是否拦截。
        &lt;ol&gt;
          &lt;li&gt;如果不拦截的话，分发事件寻找目标消费子View（逆序遍历子View，递归调用子View的事件分发，判断是否有子View消费。mFirstTouchTarget存储目标消费子View对象）。
            &lt;ol&gt;
              &lt;li&gt;如果有子View消费，则目标子View消费事件。&lt;/li&gt;
              &lt;li&gt;否则自己尝试消费事件。&lt;/li&gt;
            &lt;/ol&gt;
          &lt;/li&gt;
          &lt;li&gt;否则直接自己尝试消费事件。&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;后续事件
        &lt;ol&gt;
          &lt;li&gt;如果按下事件找到了目标消费子View，则判断是否拦截，否则不拦截。&lt;/li&gt;
          &lt;li&gt;如果有目标消费子View，则根据是否拦截。
            &lt;ol&gt;
              &lt;li&gt;如果没有拦截，正常传送后续事件；&lt;/li&gt;
              &lt;li&gt;如果有拦截，则当前事件转换为取消事件发送给目标消费子View，并且重置目标消费子View为空，接下来的后续事件直接自己尝试消费事件（不管是否消费，后续事件都会接收到&amp;amp;尝试处理事件分发）；&lt;/li&gt;
            &lt;/ol&gt;
          &lt;/li&gt;
          &lt;li&gt;否则自己尝试消费事件。（不会调用是否拦截，其实拦截或者不拦截，都是自己消费事件。）&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;View负责事件消费事件处理。
    &lt;ol&gt;
      &lt;li&gt;调用mOnTouchListener的onTouch。
        &lt;ol&gt;
          &lt;li&gt;如果消费，直接返回true；&lt;/li&gt;
          &lt;li&gt;否则，继续调用onTouchEvent方法；
            &lt;ol&gt;
              &lt;li&gt;如果为启用的（enable），返回可点击（clickable）。&lt;/li&gt;
              &lt;li&gt;否则，调用mTouchDelegate的onTouchEvent。
                &lt;ol&gt;
                  &lt;li&gt;如果消费，直接返回true；&lt;/li&gt;
                  &lt;li&gt;否则，
                    &lt;ol&gt;
                      &lt;li&gt;如果可点击（clickable）
                        &lt;ol&gt;
                          &lt;li&gt;进行事件流（ACTION_DOWN，ACTION_MOVE，ACTION_UP，ACTION_CANCEL）处理（包含焦点、按键状态、按键和长时间按键）；&lt;/li&gt;
                          &lt;li&gt;返回true。&lt;/li&gt;
                        &lt;/ol&gt;
                      &lt;/li&gt;
                      &lt;li&gt;否则返回false；&lt;/li&gt;
                    &lt;/ol&gt;
                  &lt;/li&gt;
                &lt;/ol&gt;
              &lt;/li&gt;
            &lt;/ol&gt;
          &lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;注释&quot;&gt;注释&lt;/h4&gt;

&lt;h5 id=&quot;decorview&quot;&gt;DecorView&lt;/h5&gt;
&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kp&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DecorView&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;FrameLayout&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kp&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;PhoneWindow&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mWindow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;vi&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kp&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dispatchTouchEvent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;MotionEvent&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;Window&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;Callback&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cb&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mWindow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;getCallback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cb&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mWindow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;isDestroyed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mFeatureId&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;dispatchTouchEvent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;dispatchTouchEvent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;kp&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;superDispatchTouchEvent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;MotionEvent&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;dispatchTouchEvent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;windowcallbackwrapper&quot;&gt;WindowCallbackWrapper&lt;/h5&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class WindowCallbackWrapper implements Window.Callback   {
    @Override
    public boolean dispatchTouchEvent(MotionEvent event) {
        return mWrapped.dispatchTouchEvent(event);
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;activity&quot;&gt;Activity&lt;/h5&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Activity implements Window.Callback  {
    public boolean dispatchTouchEvent(MotionEvent ev) {
        if (ev.getAction() == MotionEvent.ACTION_DOWN) {
            onUserInteraction();
        }
        if (getWindow().superDispatchTouchEvent(ev)) {
            return true;
        }
        return onTouchEvent(ev);
    }
    
    public boolean onTouchEvent(MotionEvent event) {
        if (mWindow.shouldCloseOnTouch(this, event)) {
            finish();
            return true;
        }

        return false;
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;phonewindow&quot;&gt;PhoneWindow&lt;/h5&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class PhoneWindow extends Window  {
    @Override
    public boolean superDispatchTouchEvent(MotionEvent event) {
        return mDecor.superDispatchTouchEvent(event);
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;viewgroup&quot;&gt;ViewGroup&lt;/h5&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public abstract class ViewGroup extends View implements ViewParent  {
    
    @Override
    public boolean dispatchTouchEvent(MotionEvent ev) {
        if (mInputEventConsistencyVerifier != null) {
            mInputEventConsistencyVerifier.onTouchEvent(ev, 1);
        }

        // If the event targets the accessibility focused view and this is it, start
        // normal event dispatch. Maybe a descendant is what will handle the click.
        if (ev.isTargetAccessibilityFocus() &amp;amp;&amp;amp; isAccessibilityFocusedViewOrHost()) {
            ev.setTargetAccessibilityFocus(false);
        }

        boolean handled = false;
        if (onFilterTouchEventForSecurity(ev)) {
            final int action = ev.getAction();
            final int actionMasked = action &amp;amp; MotionEvent.ACTION_MASK;

            // Handle an initial down.
            if (actionMasked == MotionEvent.ACTION_DOWN) {
                // Throw away all previous state when starting a new touch gesture.
                // The framework may have dropped the up or cancel event for the previous gesture
                // due to an app switch, ANR, or some other state change.
                cancelAndClearTouchTargets(ev);
                resetTouchState();
            }

            // Check for interception.
            final boolean intercepted;
            if (actionMasked == MotionEvent.ACTION_DOWN
                    || mFirstTouchTarget != null) {
                final boolean disallowIntercept = (mGroupFlags &amp;amp; FLAG_DISALLOW_INTERCEPT) != 0;
                if (!disallowIntercept) {
                    intercepted = onInterceptTouchEvent(ev);
                    ev.setAction(action); // restore action in case it was changed
                } else {
                    intercepted = false;
                }
            } else {
                // There are no touch targets and this action is not an initial down
                // so this view group continues to intercept touches.
                intercepted = true;
            }

            // If intercepted, start normal event dispatch. Also if there is already
            // a view that is handling the gesture, do normal event dispatch.
            if (intercepted || mFirstTouchTarget != null) {
                ev.setTargetAccessibilityFocus(false);
            }

            // Check for cancelation.
            final boolean canceled = resetCancelNextUpFlag(this)
                    || actionMasked == MotionEvent.ACTION_CANCEL;

            // Update list of touch targets for pointer down, if needed.
            final boolean split = (mGroupFlags &amp;amp; FLAG_SPLIT_MOTION_EVENTS) != 0;
            TouchTarget newTouchTarget = null;
            boolean alreadyDispatchedToNewTouchTarget = false;
            if (!canceled &amp;amp;&amp;amp; !intercepted) {

                // If the event is targeting accessiiblity focus we give it to the
                // view that has accessibility focus and if it does not handle it
                // we clear the flag and dispatch the event to all children as usual.
                // We are looking up the accessibility focused host to avoid keeping
                // state since these events are very rare.
                View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus()
                        ? findChildWithAccessibilityFocus() : null;

                if (actionMasked == MotionEvent.ACTION_DOWN
                        || (split &amp;amp;&amp;amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)
                        || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
                    final int actionIndex = ev.getActionIndex(); // always 0 for down
                    final int idBitsToAssign = split ? 1 &amp;lt;&amp;lt; ev.getPointerId(actionIndex)
                            : TouchTarget.ALL_POINTER_IDS;

                    // Clean up earlier touch targets for this pointer id in case they
                    // have become out of sync.
                    removePointersFromTouchTargets(idBitsToAssign);

                    final int childrenCount = mChildrenCount;
                    if (newTouchTarget == null &amp;amp;&amp;amp; childrenCount != 0) {
                        final float x = ev.getX(actionIndex);
                        final float y = ev.getY(actionIndex);
                        // Find a child that can receive the event.
                        // Scan children from front to back.
                        final ArrayList&amp;lt;View&amp;gt; preorderedList = buildTouchDispatchChildList();
                        final boolean customOrder = preorderedList == null
                                &amp;amp;&amp;amp; isChildrenDrawingOrderEnabled();
                        final View[] children = mChildren;
                        for (int i = childrenCount - 1; i &amp;gt;= 0; i--) {
                            final int childIndex = getAndVerifyPreorderedIndex(
                                    childrenCount, i, customOrder);
                            final View child = getAndVerifyPreorderedView(
                                    preorderedList, children, childIndex);

                            // If there is a view that has accessibility focus we want it
                            // to get the event first and if not handled we will perform a
                            // normal dispatch. We may do a double iteration but this is
                            // safer given the timeframe.
                            if (childWithAccessibilityFocus != null) {
                                if (childWithAccessibilityFocus != child) {
                                    continue;
                                }
                                childWithAccessibilityFocus = null;
                                i = childrenCount - 1;
                            }

                            if (!canViewReceivePointerEvents(child)
                                    || !isTransformedTouchPointInView(x, y, child, null)) {
                                ev.setTargetAccessibilityFocus(false);
                                continue;
                            }

                            newTouchTarget = getTouchTarget(child);
                            if (newTouchTarget != null) {
                                // Child is already receiving touch within its bounds.
                                // Give it the new pointer in addition to the ones it is handling.
                                newTouchTarget.pointerIdBits |= idBitsToAssign;
                                break;
                            }

                            resetCancelNextUpFlag(child);
                            if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
                                // Child wants to receive touch within its bounds.
                                mLastTouchDownTime = ev.getDownTime();
                                if (preorderedList != null) {
                                    // childIndex points into presorted list, find original index
                                    for (int j = 0; j &amp;lt; childrenCount; j++) {
                                        if (children[childIndex] == mChildren[j]) {
                                            mLastTouchDownIndex = j;
                                            break;
                                        }
                                    }
                                } else {
                                    mLastTouchDownIndex = childIndex;
                                }
                                mLastTouchDownX = ev.getX();
                                mLastTouchDownY = ev.getY();
                                newTouchTarget = addTouchTarget(child, idBitsToAssign);
                                alreadyDispatchedToNewTouchTarget = true;
                                break;
                            }

                            // The accessibility focus didn't handle the event, so clear
                            // the flag and do a normal dispatch to all children.
                            ev.setTargetAccessibilityFocus(false);
                        }
                        if (preorderedList != null) preorderedList.clear();
                    }

                    if (newTouchTarget == null &amp;amp;&amp;amp; mFirstTouchTarget != null) {
                        // Did not find a child to receive the event.
                        // Assign the pointer to the least recently added target.
                        newTouchTarget = mFirstTouchTarget;
                        while (newTouchTarget.next != null) {
                            newTouchTarget = newTouchTarget.next;
                        }
                        newTouchTarget.pointerIdBits |= idBitsToAssign;
                    }
                }
            }

            // Dispatch to touch targets.
            if (mFirstTouchTarget == null) {
                // No touch targets so treat this as an ordinary view.
                handled = dispatchTransformedTouchEvent(ev, canceled, null,
                        TouchTarget.ALL_POINTER_IDS);
            } else {
                // Dispatch to touch targets, excluding the new touch target if we already
                // dispatched to it.  Cancel touch targets if necessary.
                TouchTarget predecessor = null;
                TouchTarget target = mFirstTouchTarget;
                while (target != null) {
                    final TouchTarget next = target.next;
                    if (alreadyDispatchedToNewTouchTarget &amp;amp;&amp;amp; target == newTouchTarget) {
                        handled = true;
                    } else {
                        final boolean cancelChild = resetCancelNextUpFlag(target.child)
                                || intercepted;
                        if (dispatchTransformedTouchEvent(ev, cancelChild,
                                target.child, target.pointerIdBits)) {
                            handled = true;
                        }
                        if (cancelChild) {
                            if (predecessor == null) {
                                mFirstTouchTarget = next;
                            } else {
                                predecessor.next = next;
                            }
                            target.recycle();
                            target = next;
                            continue;
                        }
                    }
                    predecessor = target;
                    target = next;
                }
            }

            // Update list of touch targets for pointer up or cancel, if needed.
            if (canceled
                    || actionMasked == MotionEvent.ACTION_UP
                    || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
                resetTouchState();
            } else if (split &amp;amp;&amp;amp; actionMasked == MotionEvent.ACTION_POINTER_UP) {
                final int actionIndex = ev.getActionIndex();
                final int idBitsToRemove = 1 &amp;lt;&amp;lt; ev.getPointerId(actionIndex);
                removePointersFromTouchTargets(idBitsToRemove);
            }
        }

        if (!handled &amp;amp;&amp;amp; mInputEventConsistencyVerifier != null) {
            mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1);
        }
        return handled;
    }
    
    public boolean onInterceptTouchEvent(MotionEvent ev) {
        if (ev.isFromSource(InputDevice.SOURCE_MOUSE)
                &amp;amp;&amp;amp; ev.getAction() == MotionEvent.ACTION_DOWN
                &amp;amp;&amp;amp; ev.isButtonPressed(MotionEvent.BUTTON_PRIMARY)
                &amp;amp;&amp;amp; isOnScrollbarThumb(ev.getX(), ev.getY())) {
            return true;
        }
        return false;
    }
    
        private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel,
            View child, int desiredPointerIdBits) {
        final boolean handled;

        // Canceling motions is a special case.  We don't need to perform any transformations
        // or filtering.  The important part is the action, not the contents.
        final int oldAction = event.getAction();
        if (cancel || oldAction == MotionEvent.ACTION_CANCEL) {
            event.setAction(MotionEvent.ACTION_CANCEL);
            if (child == null) {
                handled = super.dispatchTouchEvent(event);
            } else {
                handled = child.dispatchTouchEvent(event);
            }
            event.setAction(oldAction);
            return handled;
        }

        // Calculate the number of pointers to deliver.
        final int oldPointerIdBits = event.getPointerIdBits();
        final int newPointerIdBits = oldPointerIdBits &amp;amp; desiredPointerIdBits;

        // If for some reason we ended up in an inconsistent state where it looks like we
        // might produce a motion event with no pointers in it, then drop the event.
        if (newPointerIdBits == 0) {
            return false;
        }

        // If the number of pointers is the same and we don't need to perform any fancy
        // irreversible transformations, then we can reuse the motion event for this
        // dispatch as long as we are careful to revert any changes we make.
        // Otherwise we need to make a copy.
        final MotionEvent transformedEvent;
        if (newPointerIdBits == oldPointerIdBits) {
            if (child == null || child.hasIdentityMatrix()) {
                if (child == null) {
                    handled = super.dispatchTouchEvent(event);
                } else {
                    final float offsetX = mScrollX - child.mLeft;
                    final float offsetY = mScrollY - child.mTop;
                    event.offsetLocation(offsetX, offsetY);

                    handled = child.dispatchTouchEvent(event);

                    event.offsetLocation(-offsetX, -offsetY);
                }
                return handled;
            }
            transformedEvent = MotionEvent.obtain(event);
        } else {
            transformedEvent = event.split(newPointerIdBits);
        }

        // Perform any necessary transformations and dispatch.
        if (child == null) {
            handled = super.dispatchTouchEvent(transformedEvent);
        } else {
            final float offsetX = mScrollX - child.mLeft;
            final float offsetY = mScrollY - child.mTop;
            transformedEvent.offsetLocation(offsetX, offsetY);
            if (! child.hasIdentityMatrix()) {
                transformedEvent.transform(child.getInverseMatrix());
            }

            handled = child.dispatchTouchEvent(transformedEvent);
        }

        // Done.
        transformedEvent.recycle();
        return handled;
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/事件DispatchTouchEvent流程图.png&quot; alt=&quot;事件DispatchTouchEvent流程图&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;view&quot;&gt;View&lt;/h5&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class View  {
    public final boolean dispatchPointerEvent(MotionEvent event) {
        if (event.isTouchEvent()) {
            return dispatchTouchEvent(event);
        } else {
            return dispatchGenericMotionEvent(event);
        }
    }
    
    public boolean dispatchTouchEvent(MotionEvent event) {
        // If the event should be handled by accessibility focus first.
        if (event.isTargetAccessibilityFocus()) {
            // We don't have focus or no virtual descendant has it, do not handle the event.
            if (!isAccessibilityFocusedViewOrHost()) {
                return false;
            }
            // We have focus and got the event, then use normal event dispatch.
            event.setTargetAccessibilityFocus(false);
        }

        boolean result = false;

        if (mInputEventConsistencyVerifier != null) {
            mInputEventConsistencyVerifier.onTouchEvent(event, 0);
        }

        final int actionMasked = event.getActionMasked();
        if (actionMasked == MotionEvent.ACTION_DOWN) {
            // Defensive cleanup for new gesture
            stopNestedScroll();
        }

        if (onFilterTouchEventForSecurity(event)) {
            if ((mViewFlags &amp;amp; ENABLED_MASK) == ENABLED &amp;amp;&amp;amp; handleScrollBarDragging(event)) {
                result = true;
            }
            //noinspection SimplifiableIfStatement
            ListenerInfo li = mListenerInfo;
            if (li != null &amp;amp;&amp;amp; li.mOnTouchListener != null
                    &amp;amp;&amp;amp; (mViewFlags &amp;amp; ENABLED_MASK) == ENABLED
                    &amp;amp;&amp;amp; li.mOnTouchListener.onTouch(this, event)) {
                result = true;
            }

            if (!result &amp;amp;&amp;amp; onTouchEvent(event)) {
                result = true;
            }
        }

        if (!result &amp;amp;&amp;amp; mInputEventConsistencyVerifier != null) {
            mInputEventConsistencyVerifier.onUnhandledEvent(event, 0);
        }

        // Clean up after nested scrolls if this is the end of a gesture;
        // also cancel it if we tried an ACTION_DOWN but we didn't want the rest
        // of the gesture.
        if (actionMasked == MotionEvent.ACTION_UP ||
                actionMasked == MotionEvent.ACTION_CANCEL ||
                (actionMasked == MotionEvent.ACTION_DOWN &amp;amp;&amp;amp; !result)) {
            stopNestedScroll();
        }

        return result;
    }
    
    public boolean onTouchEvent(MotionEvent event) {
        final float x = event.getX();
        final float y = event.getY();
        final int viewFlags = mViewFlags;
        final int action = event.getAction();

        final boolean clickable = ((viewFlags &amp;amp; CLICKABLE) == CLICKABLE
                || (viewFlags &amp;amp; LONG_CLICKABLE) == LONG_CLICKABLE)
                || (viewFlags &amp;amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE;

        if ((viewFlags &amp;amp; ENABLED_MASK) == DISABLED) {
            if (action == MotionEvent.ACTION_UP &amp;amp;&amp;amp; (mPrivateFlags &amp;amp; PFLAG_PRESSED) != 0) {
                setPressed(false);
            }
            mPrivateFlags3 &amp;amp;= ~PFLAG3_FINGER_DOWN;
            // A disabled view that is clickable still consumes the touch
            // events, it just doesn't respond to them.
            return clickable;
        }
        if (mTouchDelegate != null) {
            if (mTouchDelegate.onTouchEvent(event)) {
                return true;
            }
        }

        if (clickable || (viewFlags &amp;amp; TOOLTIP) == TOOLTIP) {
            switch (action) {
                case MotionEvent.ACTION_UP:
                    mPrivateFlags3 &amp;amp;= ~PFLAG3_FINGER_DOWN;
                    if ((viewFlags &amp;amp; TOOLTIP) == TOOLTIP) {
                        handleTooltipUp();
                    }
                    if (!clickable) {
                        removeTapCallback();
                        removeLongPressCallback();
                        mInContextButtonPress = false;
                        mHasPerformedLongPress = false;
                        mIgnoreNextUpEvent = false;
                        break;
                    }
                    boolean prepressed = (mPrivateFlags &amp;amp; PFLAG_PREPRESSED) != 0;
                    if ((mPrivateFlags &amp;amp; PFLAG_PRESSED) != 0 || prepressed) {
                        // take focus if we don't have it already and we should in
                        // touch mode.
                        boolean focusTaken = false;
                        if (isFocusable() &amp;amp;&amp;amp; isFocusableInTouchMode() &amp;amp;&amp;amp; !isFocused()) {
                            focusTaken = requestFocus();
                        }

                        if (prepressed) {
                            // The button is being released before we actually
                            // showed it as pressed.  Make it show the pressed
                            // state now (before scheduling the click) to ensure
                            // the user sees it.
                            setPressed(true, x, y);
                        }

                        if (!mHasPerformedLongPress &amp;amp;&amp;amp; !mIgnoreNextUpEvent) {
                            // This is a tap, so remove the longpress check
                            removeLongPressCallback();

                            // Only perform take click actions if we were in the pressed state
                            if (!focusTaken) {
                                // Use a Runnable and post this rather than calling
                                // performClick directly. This lets other visual state
                                // of the view update before click actions start.
                                if (mPerformClick == null) {
                                    mPerformClick = new PerformClick();
                                }
                                if (!post(mPerformClick)) {
                                    performClick();
                                }
                            }
                        }

                        if (mUnsetPressedState == null) {
                            mUnsetPressedState = new UnsetPressedState();
                        }

                        if (prepressed) {
                            postDelayed(mUnsetPressedState,
                                    ViewConfiguration.getPressedStateDuration());
                        } else if (!post(mUnsetPressedState)) {
                            // If the post failed, unpress right now
                            mUnsetPressedState.run();
                        }

                        removeTapCallback();
                    }
                    mIgnoreNextUpEvent = false;
                    break;

                case MotionEvent.ACTION_DOWN:
                    if (event.getSource() == InputDevice.SOURCE_TOUCHSCREEN) {
                        mPrivateFlags3 |= PFLAG3_FINGER_DOWN;
                    }
                    mHasPerformedLongPress = false;

                    if (!clickable) {
                        checkForLongClick(0, x, y);
                        break;
                    }

                    if (performButtonActionOnTouchDown(event)) {
                        break;
                    }

                    // Walk up the hierarchy to determine if we're inside a scrolling container.
                    boolean isInScrollingContainer = isInScrollingContainer();

                    // For views inside a scrolling container, delay the pressed feedback for
                    // a short period in case this is a scroll.
                    if (isInScrollingContainer) {
                        mPrivateFlags |= PFLAG_PREPRESSED;
                        if (mPendingCheckForTap == null) {
                            mPendingCheckForTap = new CheckForTap();
                        }
                        mPendingCheckForTap.x = event.getX();
                        mPendingCheckForTap.y = event.getY();
                        postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());
                    } else {
                        // Not inside a scrolling container, so show the feedback right away
                        setPressed(true, x, y);
                        checkForLongClick(0, x, y);
                    }
                    break;

                case MotionEvent.ACTION_CANCEL:
                    if (clickable) {
                        setPressed(false);
                    }
                    removeTapCallback();
                    removeLongPressCallback();
                    mInContextButtonPress = false;
                    mHasPerformedLongPress = false;
                    mIgnoreNextUpEvent = false;
                    mPrivateFlags3 &amp;amp;= ~PFLAG3_FINGER_DOWN;
                    break;

                case MotionEvent.ACTION_MOVE:
                    if (clickable) {
                        drawableHotspotChanged(x, y);
                    }

                    // Be lenient about moving outside of buttons
                    if (!pointInView(x, y, mTouchSlop)) {
                        // Outside button
                        // Remove any future long press/tap checks
                        removeTapCallback();
                        removeLongPressCallback();
                        if ((mPrivateFlags &amp;amp; PFLAG_PRESSED) != 0) {
                            setPressed(false);
                        }
                        mPrivateFlags3 &amp;amp;= ~PFLAG3_FINGER_DOWN;
                    }
                    break;
            }

            return true;
        }

        return false;
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/事件OnTouchEvent流程图.png&quot; alt=&quot;事件OnTouchEvent流程图&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;事件流&quot;&gt;事件流&lt;/h4&gt;

&lt;p&gt;使用&lt;a href=&quot;https://www.jianshu.com/p/d968645067d7&quot;&gt;&lt;strong&gt;MECE&lt;/strong&gt;&lt;/a&gt;（Mutually Exclusive Collectively Exhaustive，相互独立，完全穷尽）法则&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/事件流MEMC图.png&quot; alt=&quot;事件流MEMC图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Demo&lt;/strong&gt;（&lt;a href=&quot;https://github.com/shengshuqiang/viewdispatchtouchevent&quot;&gt;git仓库&lt;/a&gt;）ParentInterceptTouchEventActivity页面
&lt;img src=&quot;http://localhost:4000/assets/ParentInterceptTouchEventActivity.png&quot; alt=&quot;ParentInterceptTouchEventActivity&quot; /&gt;&lt;/p&gt;

&lt;p&gt;1.父控件ACTION_DOWN拦截&lt;br /&gt;
2.父控件消费事件&lt;br /&gt;&lt;img src=&quot;http://localhost:4000/assets/角色事件消费状态-1.png&quot; alt=&quot;角色事件消费状态-1&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
1. 接收按下事件 -DOWN-&amp;gt; Parent.dispatchTouchEvent -DOWN-&amp;gt; Parent.onInterceptTouchEvent -true-&amp;gt; Parent.dispatchTouchEvent -DOWN-&amp;gt; Parent.(super)dispatchTouchEvent{Parent处理消费} -DOWN-&amp;gt;  Parent.onTouchEvent -true-&amp;gt; Parent.dispatchTouchEvent-true-&amp;gt; 返回消费状态true&lt;br /&gt;![事件流-1](事件流-1.png)&lt;br /&gt;
2. 接收移动事件 -MOVE-&amp;gt; Parent.dispatchTouchEvent -MOVE-&amp;gt; Parent.(super)dispatchTouchEvent{Parent处理消费} -MOVE-&amp;gt; Parent.onTouchEvent -消费状态-&amp;gt; Parent.dispatchTouchEvent -true-&amp;gt; 返回消费状态true&lt;br /&gt;![事件流-2](http://localhost:4000/assets/事件流-2.png)&lt;br /&gt;
3. 接收释放事件 -UP-&amp;gt; Parent.dispatchTouchEvent -UP-&amp;gt; Parent.(super)dispatchTouchEvent{Parent处理消费} -UP-&amp;gt; Parent.onTouchEvent -true-&amp;gt; Parent.dispatchTouchEvent -true-&amp;gt; 返回消费状态true![事件流-3](http://localhost:4000/assets/事件流-3.png)&lt;br /&gt;
&lt;/blockquote&gt;
&lt;p&gt;1.父控件ACTION_DOWN拦截&lt;br /&gt;
2.父控件不消费事件&lt;br /&gt;&lt;img src=&quot;http://localhost:4000/assets/角色事件消费状态-2.png&quot; alt=&quot;角色事件消费状态-2&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
4. 接收按下事件 -DOWN-&amp;gt; Parent.dispatchTouchEvent -DOWN-&amp;gt; Parent.onInterceptTouchEvent -true-&amp;gt; Parent.dispatchTouchEvent -DOWN-&amp;gt; Parent.(super)dispatchTouchEvent{Parent处理消费} -DOWN-&amp;gt;  Parent.onTouchEvent -false-&amp;gt; Parent.dispatchTouchEvent-false-&amp;gt; 返回消费状态false&lt;br /&gt;![事件流-4](http://localhost:4000/assets/事件流-4.png)&lt;br /&gt;
5. 接收不到移动事件&lt;br /&gt;
6. 同5
&lt;/blockquote&gt;
&lt;p&gt;1.父控件ACTION_MOVE拦截&lt;br /&gt;
2.子控件消费事件&lt;br /&gt;&lt;img src=&quot;http://localhost:4000/assets/角色事件消费状态-3.png&quot; alt=&quot;角色事件消费状态-3&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
7. 接收按下事件 -DOWN-&amp;gt; Parent.dispatchTouchEvent -DOWN-&amp;gt; Parent.onInterceptTouchEvent  -false-&amp;gt; Parent.dispatchTouchEvent -DOWN-&amp;gt; Child.dispatchTouchEvent{Parent分发，遍历调用Child分发消息，Child内部递归分发消息} -DOWN-&amp;gt; TargetChild（目标子控件，区别Child，子控件消费事件，要么是自己消费了，要么是自己的后代或者后代的后代消费了）.onTouchEvent{存在调用多个Child该方法，前提是前面的Child均返回false} -true-&amp;gt; Child.dispatchTouchEvent -true-&amp;gt; Parent.dispatchTouchEvent{记录目标消费Child为该View}-true-&amp;gt; 返回消费状态true&lt;br /&gt;![事件流-7](http://localhost:4000/assets/事件流-7.png)&lt;br /&gt;
8. 接收移动事件 -MOVE-&amp;gt; Parent.dispatchTouchEvent -MOVE-&amp;gt; Parent.onInterceptTouchEvent  -true-&amp;gt; Parent.dispatchTouchEvent -CANCEL-&amp;gt; Child（目标消费Child）.dispatchTouchEvent{Child处理消费} -CANCEL-&amp;gt;Child.onTouchEvent -消费状态-&amp;gt; Child.dispatchTouchEvent-消费状态-&amp;gt; 返回消费状态&lt;br /&gt;![事件流-8](事件流-8.png)&lt;br /&gt;
9. 接收释放事件 -UP-&amp;gt; Parent.dispatchTouchEvent -UP-&amp;gt; Parent.(super)dispatchTouchEvent{Parent处理消费} -UP-&amp;gt; Parent.onTouchEvent -消费状态-&amp;gt; Parent.dispatchTouchEvent -消费状态-&amp;gt; 返回消费状态&lt;br /&gt;![事件流-9](http://localhost:4000/assets/事件流-9.png)
&lt;/blockquote&gt;
&lt;p&gt;1.父控件ACTION_MOVE拦截&lt;br /&gt;
2.子控件不消费事件&lt;br /&gt;
3.父控件消费事件&lt;br /&gt;&lt;img src=&quot;http://localhost:4000/assets/角色事件消费状态-4.png&quot; alt=&quot;角色事件消费状态-4&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
10. 接收按下事件 -DOWN-&amp;gt; Parent.dispatchTouchEvent -DOWN-&amp;gt; Parent.onInterceptTouchEvent  -false-&amp;gt; Parent.dispatchTouchEvent -DOWN-&amp;gt; Child.dispatchTouchEvent{Parent分发，遍历调用Child分发消息，Child内部递归分发消息} -DOWN-&amp;gt; TargetChild（目标子控件，区别Child，子控件处理消费事件）.onTouchEvent{满足事件坐标在控件内的子View或者子View的后代均会调用到} -false-&amp;gt; Child.dispatchTouchEvent -false-&amp;gt; Parent.dispatchTouchEvent{没有目标消费Child} -DOWN-&amp;gt; Parent.(super)dispatchTouchEvent{Parent处理消费} -DOWN-&amp;gt;  Parent.onTouchEvent -true-&amp;gt; 返回消费状态true&lt;br /&gt;![事件流-10](http://localhost:4000/assets/事件流-10.png)&lt;br /&gt;
11. 同2&lt;br /&gt;
12. 同3&lt;br /&gt;
&lt;/blockquote&gt;
&lt;p&gt;1.父控件ACTION_MOVE拦截&lt;br /&gt;
2.子控件不消费事件&lt;br /&gt;
3.父控件不消费事件&lt;br /&gt;&lt;img src=&quot;http://localhost:4000/assets/角色事件消费状态-5.png&quot; alt=&quot;角色事件消费状态-5&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
13. 接收按下事件 -DOWN-&amp;gt; Parent.dispatchTouchEvent -DOWN-&amp;gt; Parent.onInterceptTouchEvent  -false-&amp;gt; Parent.dispatchTouchEvent -DOWN-&amp;gt; Child.dispatchTouchEvent{Parent分发，遍历调用Child分发消息，Child内部递归分发消息} -DOWN-&amp;gt; TargetChild（目标子控件，区别Child，子控件处理消费事件）.onTouchEvent{满足事件坐标在控件内的子View或者子View的后代均会调用到} -false-&amp;gt; Child.dispatchTouchEvent -false-&amp;gt; Parent.dispatchTouchEvent{没有目标消费Child} -DOWN-&amp;gt; Parent.(super)dispatchTouchEvent{Parent处理消费} -DOWN-&amp;gt;  Parent.onTouchEvent -false-&amp;gt; 返回消费状态false&lt;br /&gt;![事件流-13](http://localhost:4000/assets/事件流-13.png)&lt;br /&gt;
14. 同5&lt;br /&gt;
15. 同5&lt;br /&gt;
&lt;/blockquote&gt;
&lt;p&gt;1.父控件ACTION_UP拦截&lt;br /&gt;
2.子控件消费事件&lt;br /&gt;&lt;img src=&quot;http://localhost:4000/assets/角色事件消费状态-6.png&quot; alt=&quot;角色事件消费状态-6&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
16. 同7&lt;br /&gt;
17. 接收移动事件 -MOVE-&amp;gt; Parent.dispatchTouchEvent -MOVE-&amp;gt; Parent.onInterceptTouchEvent  -false-&amp;gt; Parent.dispatchTouchEvent -MOVE-&amp;gt; Child(目标消费Child).dispatchTouchEvent -MOVE-&amp;gt; Child.onTouchEvent -true-&amp;gt; Child.dispatchTouchEvent -true-&amp;gt; Parent.dispatchTouchEvent -true-&amp;gt; 返回消费状态true&lt;br /&gt;![事件流-17](http://localhost:4000/assets/事件流-17.png)&lt;br /&gt;
18. 接收释放事件 -UP-&amp;gt; Parent.dispatchTouchEvent -UP-&amp;gt; Parent.onInterceptTouchEvent -true-&amp;gt; Parent.dispatchTouchEvent -CANCEL-&amp;gt; Child(目标消费Child).dispatchTouchEvent{Child处理消费} -CANCEL-&amp;gt; Child.onTouchEvent -消费状态-&amp;gt; Child.dispatchTouchEvent -true-&amp;gt; Parent.dispatchTouchEvent -true-&amp;gt; 返回消费状态true&lt;br /&gt;![事件流-18](http://localhost:4000/assets/事件流-18.png)
&lt;/blockquote&gt;
&lt;p&gt;1.父控件ACTION_UP拦截&lt;br /&gt;
2.子控件不消费事件&lt;br /&gt;
3.父控件消费事件&lt;br /&gt;&lt;img src=&quot;http://localhost:4000/assets/角色事件消费状态-7.png&quot; alt=&quot;角色事件消费状态-7&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
19. 同10&lt;br /&gt;
20. 同2&lt;br /&gt;
21. 同3&lt;br /&gt;
&lt;/blockquote&gt;
&lt;p&gt;1.父控件ACTION_UP拦截&lt;br /&gt;
2.子控件不消费事件&lt;br /&gt;
3.父控件不消费事件&lt;br /&gt;&lt;img src=&quot;http://localhost:4000/assets/角色事件消费状态-8.png&quot; alt=&quot;角色事件消费状态-8&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
22. 同13&lt;br /&gt;
23. 同5&lt;br /&gt;
24. 同5
&lt;/blockquote&gt;
&lt;ol&gt;
  &lt;li&gt;父控件不拦截&lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;子控件消费事件&lt;br /&gt;&lt;img src=&quot;http://localhost:4000/assets/角色事件消费状态-9.png&quot; alt=&quot;角色事件消费状态-9&quot; /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
25. 同7&lt;br /&gt;
26. 同17&lt;br /&gt;
27. 接收释放事件 -UP-&amp;gt; Parent.dispatchTouchEvent -UP-&amp;gt; Parent.onInterceptTouchEvent  -false-&amp;gt; Parent.dispatchTouchEvent -UP-&amp;gt; Child(目标消费Child).dispatchTouchEvent -UP-&amp;gt; Child.onTouchEvent -true-&amp;gt; Child.dispatchTouchEvent -true-&amp;gt; Parent.dispatchTouchEvent -true-&amp;gt; 返回消费状态true&lt;br /&gt;![事件流-27](http://localhost:4000/assets/事件流-27.png)
&lt;/blockquote&gt;
&lt;ol&gt;
  &lt;li&gt;父控件不拦截&lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;子控件不消费事件&lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;父控件消费事件&lt;br /&gt;&lt;img src=&quot;http://localhost:4000/assets/角色事件消费状态-10.png&quot; alt=&quot;角色事件消费状态-10&quot; /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
28. 同10&lt;br /&gt;
29. 同2&lt;br /&gt;
30. 同3&lt;br /&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
  &lt;li&gt;父控件不拦截&lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;子控件不消费事件&lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;父控件不消费事件&lt;br /&gt;&lt;img src=&quot;http://localhost:4000/assets/角色事件消费状态-11.png&quot; alt=&quot;角色事件消费状态-11&quot; /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
31. 同13&lt;br /&gt;
32. 同5&lt;br /&gt;
33. 同5&lt;br /&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;lt;/blockquote&amp;gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;启示&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;ACTION_DOWN执行事件分发查找（遍历子View，递归分发查找，如果子View未消费，则回退到自己消费，依次向上回溯，找到目标消费View为止）找到目标消费子View。后续事件不再需要查找，直接发送给目标消费子View，如果没有，则自己消费。&lt;br /&gt;&lt;img src=&quot;http://localhost:4000/assets/事件分发路径.png&quot; alt=&quot;事件分发路径&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;事件已消费路径上（终点为目标消费View），如果有父控件拦截事件，则第一次拦截后，会将当前事件转为ACTION_CANCEL传递给目标消费子View，后续事件则直接自己处理消费，不论是否消费，均能收到后续事件流&lt;br /&gt; &lt;img src=&quot;http://localhost:4000/assets/事件分发拦截路径.png&quot; alt=&quot;事件分发拦截路径&quot; /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;论证&quot;&gt;论证&lt;/h3&gt;

&lt;p&gt;人机交互
View树
类图
注释
DecorView
WindowCallbackWrapper
Activity
PhoneWindow
ViewGroup
View
事件流&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;从事件流可证明事件一致性保证(Consistency Guarantees)：
    &lt;ol&gt;
      &lt;li&gt;ViewGroup在ACTION_DOWN的事件分发返回false（不消费事件），则不再会收到后续事件（ACTION_MOVE、ACTION_UP/ACTION_CANCEL）。&lt;/li&gt;
      &lt;li&gt;ViewGroup在ACTION_DOWN的事件分发返回true（消费事件），则会收到后续事件（ACTION_MOVE、ACTION_UP/ACTION_CANCEL），如果ViewGroup拦截后续事件，则第一次拦截会将事件转为ACTION_CANCEL传递给目标消费子View（终止子View接收后续事件），接下来的后续事件自己消费。&lt;/li&gt;
      &lt;li&gt;ViewGroup在非ACTION_DOWN的事件分发返回消费状态对整体事件流没有影响。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;从注释可证明View.dispatchTouchEvent方法完成事件的消费处理；ViewGroup.dispatchTouchEvent方法完成事件的分发处理；ViewGroup.onInterceptTouchEvent方法完成事件的拦截处理；事件分发路径上的ViewGroup，在ACTION_DOWN或者不是自己直接消费事件时一定会调用onInterceptTouchEvent方法。以及View类的onTouchEvent方法完成具体处理事件消费。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;一张图&quot;&gt;一张图&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/事件分发一张图.png&quot; alt=&quot;事件分发一张图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;赏析&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;ACTION_DOWN会触发查找目标消费View，优先子View尝试消费，如果子View仍然没有消费，则依次回溯到父控件尝试消费（直至DecorView，然后Activity尝试消费），如果找到了，则回溯返回true。&lt;/li&gt;
  &lt;li&gt;ACTION_DOWN后续事件执行的前提是事件分发路径的终点就是目标消费View，目标消费View的父控件均会调用到事件拦截（让父控件有机会拦截下来，改变事件流），如果目标消费View的父控件拦截，拦截时的事件会转换为ACTION_CANCEL继续按原路径分发，后续的事件则不再分发给目标消费View，而是拦截的父控件自己消费。&lt;/li&gt;
  &lt;li&gt;非ACTION_DOWN返回的消费状态对事件流没有影响。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;标准&quot;&gt;标准&lt;/h2&gt;

&lt;h3 id=&quot;常见错误&quot;&gt;常见错误&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;不知道onInterceptTouchEvent和onTouchEvent什么时候会调用，但是知道dispatchTouchEvent每次都会调用，就把逻辑直接写在dispatchTouchEvent的重写方法里面。&lt;br /&gt;问题：不满足事件流一致性，存在目标消费View没有接收到ACTION_UP/ACTION_CANCEL就结束了，导致焦点、按键状态或者按键事件不符合预期。&lt;/li&gt;
  &lt;li&gt;发现onInterceptTouchEvent经常调用到，逻辑写在onInterceptTouchEvent里面。&lt;br /&gt;问题：onInterceptTouchEvent在View自己消费情况下或者拦截之后的事件流不再会调用到，会把坑隐藏得更深【不好复现的Bug才是最难解决的Bug】。&lt;/li&gt;
  &lt;li&gt;鸟枪法，dispatchTouchEvent、onInterceptTouchEvent、onTouchEvent均会调用到逻辑。&lt;br /&gt;问题：路子太野。。。&lt;/li&gt;
  &lt;li&gt;觉得自己很牛X，逻辑分散在dispatchTouchEvent、onInterceptTouchEvent、onTouchEvent里面。&lt;br /&gt;问题：可读性差，逻辑混乱。&lt;/li&gt;
  &lt;li&gt;事件消息只处理了ACTION_DOWN、ACTION_MOVE、ACTION_UP，没有对ACTION_CANCEL或者其他多点触控事件容错处理。&lt;br /&gt;问题：总会出现不常见的问题。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;最佳实践&quot;&gt;最佳实践&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;明确事件流调用顺序以及拦截后的事件流。&lt;/li&gt;
  &lt;li&gt;dispatchTouchEvent：正常情况下不建议重写dispatchTouchEvent方法改变系统事件分发机制，可以看到，Google就没有几个类重新该方法。最多记下坐标点，但千万调用super. dispatchTouchEvent保证系统事件分发正常调用。&lt;/li&gt;
  &lt;li&gt;onInterceptTouchEvent：只处理拦截逻辑，在合适事件将事件流导到onTouchEvent。&lt;/li&gt;
  &lt;li&gt;onTouchEvent：真正处理逻辑。&lt;/li&gt;
  &lt;li&gt;除常见事件处理外，一定要上剩余事件容错处理。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;渔&quot;&gt;渔&lt;/h2&gt;

&lt;h3 id=&quot;方法论&quot;&gt;方法论&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.jianshu.com/p/d968645067d7&quot;&gt;MECE法则和金字塔原理&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.zhihu.com/question/27880205&quot;&gt;SCQA 架构如何理解？&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;利器&quot;&gt;利器&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;AS源码英文翻译，参考&lt;a href=&quot;http://blog.csdn.net/luofen521/article/details/74295716&quot;&gt;AS翻译插件Translation&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Android源码调试
    &lt;ol&gt;
      &lt;li&gt;&lt;a href=&quot;http://www.genymotion.net/&quot;&gt;Android模拟器GenyMotion&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;GenyMotion创建和App的build.gradle中targetSdkVersion相同API Level模拟器即可Debug对应上源码。进阶参考&lt;a href=&quot;http://weishu.me/2016/05/30/how-to-debug-android-framework/&quot;&gt;如何调试Android Framework？&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;http://weishu.me/2015/12/21/android-studio-debug-tips-you-may-not-know/&quot;&gt;Android Studio你不知道的调试技巧&lt;/a&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;关键日志输出，使用静态代理，进阶参考&lt;a href=&quot;http://weishu.me/2016/01/28/understand-plugin-framework-proxy-hook/&quot;&gt;Android插件化原理解析——Hook机制之动态代理&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;绘图工具
    &lt;ol&gt;
      &lt;li&gt;&lt;a href=&quot;https://www.processon.com/i/5a633502e4b0332f153dd897&quot;&gt;ProcessOn&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://www.edrawsoft.com/download-edrawmax-mac.php&quot;&gt;edraw&lt;/a&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;个人主页
    &lt;ol&gt;
      &lt;li&gt;&lt;a href=&quot;https://www.jekyll.com.cn/&quot;&gt;将纯文本转化为静态网站和博客&lt;/a&gt;
12.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;利&quot;&gt;利&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;随心所欲控制事件流【大权在手，天下我有】&lt;/li&gt;
  &lt;li&gt;事件分发不再是个事，怕个球&lt;/li&gt;
  &lt;li&gt;各种酷炫动画和自定义控件燥起来&lt;/li&gt;
  &lt;li&gt;再也不用担心面试中尬聊事件分发&lt;/li&gt;
  &lt;li&gt;借鉴上述不成熟的“渔”去爱干嘛干嘛&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;进阶&quot;&gt;进阶&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;滚动控件和按键冲突处理，界面布局滚动&lt;/li&gt;
  &lt;li&gt;滑动冲突
    &lt;ol&gt;
      &lt;li&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000002873657&quot;&gt;NestedScrolling机制&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/lmj623565791/article/details/52204039&quot;&gt;Android NestedScrolling机制完全解析 带你玩转嵌套滑动&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://www.jianshu.com/p/982a83271327&quot;&gt;外部拦截法&amp;amp;内部拦截法&lt;/a&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;手势（GestureDecetor）&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;参考&quot;&gt;参考&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.jianshu.com/p/e99b5e8bd67b&quot;&gt;图解 Android 事件分发机制&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.ingphone.com/android/2013/11/13/Android-%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6.html&quot;&gt;Android 响应用户屏幕手势操作&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.jianshu.com/p/0c863bbde8eb&quot;&gt;Android MotionEvent详解&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://my.oschina.net/banxi/blog/56421&quot;&gt;android触控,先了解MotionEvent(一)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/woshimalingyi/article/details/50383578&quot;&gt;Android多点触控之——MotionEvent(触控事件)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://ztelur.github.io/2016/02/04/%E5%9B%BE%E8%A7%A3Android%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E4%B9%8BView%E7%AF%87/&quot;&gt;图解Android事件传递之View篇&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://ztelur.github.io/2016/02/11/%E5%9B%BE%E8%A7%A3Android%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E4%B9%8BViewGroup%E7%AF%87/&quot;&gt;图解Android事件传递之ViewGroup篇&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;歌&quot;&gt;歌&lt;/h1&gt;

&lt;h2 id=&quot;念奴娇天丁震怒&quot;&gt;念奴娇·天丁震怒&lt;/h2&gt;
&lt;p&gt;完颜亮(金代)&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;天丁震怒，掀翻银海，散乱珠箔（bó）。&lt;/li&gt;
  &lt;li&gt;六出奇花飞滚滚，平填了山中丘壑。(六出：雪花六角，因用为雪花的别名。)&lt;/li&gt;
  &lt;li&gt;皓虎颠狂，素麟猖獗(chāng jué)，掣(chè, 拉)断珍珠索。(皓虎：白色的老虎。素麟：白色的麒麟。)&lt;/li&gt;
  &lt;li&gt;玉龙酣战，鳞甲满天飘落。&lt;/li&gt;
  &lt;li&gt;&lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;谁念万里关山，征夫僵立，缟（gǎo）带沾旗脚。(僵立：因寒冷而冻得僵硬直立。缟带：白色的衣带。)&lt;/li&gt;
  &lt;li&gt;色映戈矛，光摇剑戟(jǐ )，杀气横戎幕。(戎幕：行军作战时的营帐。)&lt;/li&gt;
  &lt;li&gt;貔（pí）虎豪雄，偏裨（pí）英勇，共与谈兵略。（裨：pí ，副，偏，小；bì ，增添，补助，如大有～益。）&lt;/li&gt;
  &lt;li&gt;须拼一醉，看取碧空寥廓(liáo kuò)。&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;copy-right&quot;&gt;Copy Right&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;作者： 盛书强，美团点评酒旅前端高级工程师，“九域之广,岂一人之强化,必伫才能,共成羽翼”，我们期待你的加入，简历发送至shengshuqiang@gmail.com。&lt;/li&gt;
  &lt;li&gt;声明： 本文为原创文章，未经许可，请勿转载，如需转载，请留言。&lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>Introduction</title>
   <link href="http://localhost:4000/2016/01/03/introduction/"/>
   <updated>2016-01-03T00:00:00+08:00</updated>
   <id>http://localhost:4000/2016/01/03/introduction</id>
   <content type="html">&lt;p&gt;&lt;em&gt;The Strange Case of Dr. Jekyll and Mr. Hyde&lt;/em&gt; tells the story of a lawyer investigating the connection of two persons, Dr. Henry Jekyll and Mr. Edward Hyde. Chief among the novel’s supporting cast is a man by the name of Mr. Poole, Dr. Jekyll’s loyal butler.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Poole is the butler for &lt;a href=&quot;http://jekyllrb.com&quot;&gt;Jekyll&lt;/a&gt;, the static site generator. It’s designed and developed by &lt;a href=&quot;https://twitter.com/mdo&quot;&gt;@mdo&lt;/a&gt; to provide a clear and concise foundational setup for any Jekyll site. It does so by furnishing a full vanilla Jekyll install with example layouts, pages, posts, and styles.&lt;/p&gt;

&lt;p&gt;There are currently three themes built on Poole:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://hyde.getpoole.com&quot;&gt;Hyde&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://lanyon.getpoole.com&quot;&gt;Lanyon&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://enfield.getpoole.com&quot;&gt;Enfield&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Learn more and contribute on &lt;a href=&quot;https://github.com/poole/poole&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;whats-included&quot;&gt;What’s included&lt;/h3&gt;

&lt;p&gt;Poole is a streamlined Jekyll site designed and built as a foundation for building more meaningful themes. Poole, and every theme built on it like this one, includes the following:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Complete Jekyll setup included (layouts, config, &lt;a href=&quot;/404.html&quot;&gt;404&lt;/a&gt;, &lt;a href=&quot;/atom.xml&quot;&gt;RSS feed&lt;/a&gt;, posts, and &lt;a href=&quot;/about&quot;&gt;example page&lt;/a&gt;)&lt;/li&gt;
  &lt;li&gt;Mobile friendly design and development&lt;/li&gt;
  &lt;li&gt;Easily scalable text and component sizing with &lt;code class=&quot;highlighter-rouge&quot;&gt;rem&lt;/code&gt; units in the CSS&lt;/li&gt;
  &lt;li&gt;Support for a wide gamut of HTML elements&lt;/li&gt;
  &lt;li&gt;Related posts (time-based, because Jekyll) below each post&lt;/li&gt;
  &lt;li&gt;Syntax highlighting, courtesy Jekyll’s built-in support for Rouge&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Additional features are available in individual themes.&lt;/p&gt;

&lt;h3 id=&quot;browser-support&quot;&gt;Browser support&lt;/h3&gt;

&lt;p&gt;Poole and its themes are by preference a forward-thinking project. In addition to the latest versions of Chrome, Safari (mobile and desktop), and Firefox, it is only compatible with Internet Explorer 9 and above.&lt;/p&gt;

&lt;h3 id=&quot;download&quot;&gt;Download&lt;/h3&gt;

&lt;p&gt;These themes are developed on and hosted with GitHub. Head to the &lt;a href=&quot;https://github.com/poole/poole&quot;&gt;GitHub repository&lt;/a&gt; for downloads, bug reports, and features requests.&lt;/p&gt;

&lt;p&gt;Thanks!&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Example content</title>
   <link href="http://localhost:4000/2016/01/02/example-content/"/>
   <updated>2016-01-02T00:00:00+08:00</updated>
   <id>http://localhost:4000/2016/01/02/example-content</id>
   <content type="html">&lt;div class=&quot;message&quot;&gt;
  Howdy! This is an example blog post that shows several types of HTML content supported in this theme.
&lt;/div&gt;

&lt;p&gt;Cum sociis natoque penatibus et magnis &lt;a href=&quot;#&quot;&gt;dis parturient montes&lt;/a&gt;, nascetur ridiculus mus. &lt;em&gt;Aenean eu leo quam.&lt;/em&gt; Pellentesque ornare sem lacinia quam venenatis vestibulum. Sed posuere consectetur est at lobortis. Cras mattis consectetur purus sit amet fermentum.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Curabitur blandit tempus porttitor. Nullam quis risus eget urna mollis ornare vel eu leo. Nullam id dolor id nibh ultricies vehicula ut id elit.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Etiam porta &lt;strong&gt;sem malesuada magna&lt;/strong&gt; mollis euismod. Cras mattis consectetur purus sit amet fermentum. Aenean lacinia bibendum nulla sed consectetur.&lt;/p&gt;

&lt;h2 id=&quot;inline-html-elements&quot;&gt;Inline HTML elements&lt;/h2&gt;

&lt;p&gt;HTML defines a long list of available inline tags, a complete list of which can be found on the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element&quot;&gt;Mozilla Developer Network&lt;/a&gt;.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;To bold text&lt;/strong&gt;, use &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;strong&amp;gt;&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;To italicize text&lt;/em&gt;, use &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;em&amp;gt;&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Abbreviations, like &lt;abbr title=&quot;HyperText Markup Langage&quot;&gt;HTML&lt;/abbr&gt; should use &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;abbr&amp;gt;&lt;/code&gt;, with an optional &lt;code class=&quot;highlighter-rouge&quot;&gt;title&lt;/code&gt; attribute for the full phrase.&lt;/li&gt;
  &lt;li&gt;Citations, like &lt;cite&gt;— Mark otto&lt;/cite&gt;, should use &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;cite&amp;gt;&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;Deleted&lt;/del&gt; text should use &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;del&amp;gt;&lt;/code&gt; and &lt;ins&gt;inserted&lt;/ins&gt; text should use &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;ins&amp;gt;&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Superscript &lt;sup&gt;text&lt;/sup&gt; uses &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;sup&amp;gt;&lt;/code&gt; and subscript &lt;sub&gt;text&lt;/sub&gt; uses &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;sub&amp;gt;&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Most of these elements are styled by browsers with few modifications on our part.&lt;/p&gt;

&lt;h2 id=&quot;footnotes&quot;&gt;Footnotes&lt;/h2&gt;

&lt;p&gt;Footnotes are supported as part of the Markdown syntax. Here’s one in action. Clicking this number&lt;sup id=&quot;fnref:fn-sample_footnote&quot;&gt;&lt;a href=&quot;#fn:fn-sample_footnote&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; will lead you to a footnote. The syntax looks like:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;Clicking this number[^fn-sample_footnote]&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Each footnote needs the &lt;code class=&quot;highlighter-rouge&quot;&gt;^fn-&lt;/code&gt; prefix and a unique ID to be referenced for the footnoted content. The syntax for that list looks something like this:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;[^fn-sample_footnote]: Handy! Now click the return link to go back.&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You can place the footnoted content wherever you like. Markdown parsers should properly place it at the bottom of the post.&lt;/p&gt;

&lt;h2 id=&quot;heading&quot;&gt;Heading&lt;/h2&gt;

&lt;p&gt;Vivamus sagittis lacus vel augue rutrum faucibus dolor auctor. Duis mollis, est non commodo luctus, nisi erat porttitor ligula, eget lacinia odio sem nec elit. Morbi leo risus, porta ac consectetur ac, vestibulum at eros.&lt;/p&gt;

&lt;h3 id=&quot;code&quot;&gt;Code&lt;/h3&gt;

&lt;p&gt;Inline code is available with the &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;code&amp;gt;&lt;/code&gt; element. Snippets of multiple lines of code are supported through Pygments. Longer lines will automatically scroll horizontally when needed.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot; data-lang=&quot;js&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// Example can be run directly in your JavaScript console
&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Create a function that takes two arguments and returns the sum of those arguments
&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;adder&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;a&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;b&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;return a + b&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Call the function
&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;adder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// &amp;gt; 8&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You may also optionally show code snippets with line numbers. Add &lt;code class=&quot;highlighter-rouge&quot;&gt;linenos&lt;/code&gt; to the Pygments tags.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot; data-lang=&quot;js&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c1&quot;&gt;// Example can be run directly in your JavaScript console
&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Create a function that takes two arguments and returns the sum of those arguments
&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;adder&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;a&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;b&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;return a + b&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Call the function
&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;adder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// &amp;gt; 8&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Aenean lacinia bibendum nulla sed consectetur. Etiam porta sem malesuada magna mollis euismod. Fusce dapibus, tellus ac cursus commodo, tortor mauris condimentum nibh, ut fermentum massa.&lt;/p&gt;

&lt;h3 id=&quot;gists-via-github-pages&quot;&gt;Gists via GitHub Pages&lt;/h3&gt;

&lt;p&gt;Vestibulum id ligula porta felis euismod semper. Nullam quis risus eget urna mollis ornare vel eu leo. Donec sed odio dui.&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;400: Invalid request
&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/13f94b734a4ddb132735.js?file=gist.md&quot;&gt; &lt;/script&gt;

&lt;p&gt;Aenean eu leo quam. Pellentesque ornare sem lacinia quam venenatis vestibulum. Nullam quis risus eget urna mollis ornare vel eu leo. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Donec sed odio dui. Vestibulum id ligula porta felis euismod semper.&lt;/p&gt;

&lt;h3 id=&quot;lists&quot;&gt;Lists&lt;/h3&gt;

&lt;p&gt;Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Aenean lacinia bibendum nulla sed consectetur. Etiam porta sem malesuada magna mollis euismod. Fusce dapibus, tellus ac cursus commodo, tortor mauris condimentum nibh, ut fermentum massa justo sit amet risus.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Praesent commodo cursus magna, vel scelerisque nisl consectetur et.&lt;/li&gt;
  &lt;li&gt;Donec id elit non mi porta gravida at eget metus.&lt;/li&gt;
  &lt;li&gt;Nulla vitae elit libero, a pharetra augue.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Donec ullamcorper nulla non metus auctor fringilla. Nulla vitae elit libero, a pharetra augue.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Vestibulum id ligula porta felis euismod semper.&lt;/li&gt;
  &lt;li&gt;Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus.&lt;/li&gt;
  &lt;li&gt;Maecenas sed diam eget risus varius blandit sit amet non magna.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Cras mattis consectetur purus sit amet fermentum. Sed posuere consectetur est at lobortis.&lt;/p&gt;

&lt;dl&gt;
  &lt;dt&gt;HyperText Markup Language (HTML)&lt;/dt&gt;
  &lt;dd&gt;The language used to describe and define the content of a Web page&lt;/dd&gt;

  &lt;dt&gt;Cascading Style Sheets (CSS)&lt;/dt&gt;
  &lt;dd&gt;Used to describe the appearance of Web content&lt;/dd&gt;

  &lt;dt&gt;JavaScript (JS)&lt;/dt&gt;
  &lt;dd&gt;The programming language used to build advanced Web sites and applications&lt;/dd&gt;
&lt;/dl&gt;

&lt;p&gt;Integer posuere erat a ante venenatis dapibus posuere velit aliquet. Morbi leo risus, porta ac consectetur ac, vestibulum at eros. Nullam quis risus eget urna mollis ornare vel eu leo.&lt;/p&gt;

&lt;h3 id=&quot;images&quot;&gt;Images&lt;/h3&gt;

&lt;p&gt;Quisque consequat sapien eget quam rhoncus, sit amet laoreet diam tempus. Aliquam aliquam metus erat, a pulvinar turpis suscipit at.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://placehold.it/800x400&quot; alt=&quot;placeholder&quot; title=&quot;Large example image&quot; /&gt;
&lt;img src=&quot;http://placehold.it/400x200&quot; alt=&quot;placeholder&quot; title=&quot;Medium example image&quot; /&gt;
&lt;img src=&quot;http://placehold.it/200x200&quot; alt=&quot;placeholder&quot; title=&quot;Small example image&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;tables&quot;&gt;Tables&lt;/h3&gt;

&lt;p&gt;Aenean lacinia bibendum nulla sed consectetur. Lorem ipsum dolor sit amet, consectetur adipiscing elit.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Name&lt;/th&gt;
      &lt;th&gt;Upvotes&lt;/th&gt;
      &lt;th&gt;Downvotes&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tfoot&gt;
    &lt;tr&gt;
      &lt;td&gt;Totals&lt;/td&gt;
      &lt;td&gt;21&lt;/td&gt;
      &lt;td&gt;23&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tfoot&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Alice&lt;/td&gt;
      &lt;td&gt;10&lt;/td&gt;
      &lt;td&gt;11&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Bob&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Charlie&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;9&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Nullam id dolor id nibh ultricies vehicula ut id elit. Sed posuere consectetur est at lobortis. Nullam quis risus eget urna mollis ornare vel eu leo.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Want to see something else added? &lt;a href=&quot;https://github.com/poole/poole/issues/new&quot;&gt;Open an issue.&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:fn-sample_footnote&quot;&gt;
      &lt;p&gt;Handy! Now click the return link to go back. &lt;a href=&quot;#fnref:fn-sample_footnote&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>What's Jekyll?</title>
   <link href="http://localhost:4000/2016/01/01/whats-jekyll/"/>
   <updated>2016-01-01T00:00:00+08:00</updated>
   <id>http://localhost:4000/2016/01/01/whats-jekyll</id>
   <content type="html">&lt;p&gt;&lt;a href=&quot;http://jekyllrb.com&quot;&gt;Jekyll&lt;/a&gt; is a static site generator, an open-source tool for creating simple yet powerful websites of all shapes and sizes. From &lt;a href=&quot;https://github.com/jekyll/jekyll/blob/master/README.markdown&quot;&gt;the project’s readme&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Jekyll is a simple, blog aware, static site generator. It takes a template directory […] and spits out a complete, static website suitable for serving with Apache or your favorite web server. This is also the engine behind GitHub Pages, which you can use to host your project’s page or blog right here from GitHub.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;It’s an immensely useful tool. Find out more by &lt;a href=&quot;https://github.com/jekyll/jekyll&quot;&gt;visiting the project on GitHub&lt;/a&gt;.&lt;/p&gt;
</content>
 </entry>
 

</feed>
